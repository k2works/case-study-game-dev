@page "/game"
@using PuyoPuyoTDD.Models
@inject IJSRuntime JSRuntime

<PageTitle>ぷよぷよ</PageTitle>

<h1>ぷよぷよ</h1>

<div class="game-container">
    <div class="game-info">
        <p>スコア: @game.Score.Value</p>
        <p>モード: @game.Mode</p>
    </div>
    <canvas id="stageCanvas" width="@canvasWidth" height="@canvasHeight"></canvas>
</div>

@code {
    private Game game = new();
    private int canvasWidth;
    private int canvasHeight;
    private DotNetObjectReference<GamePage>? dotNetHelper;

    /// <summary>
    /// コンポーネント初期化時の処理.
    /// </summary>
    protected override void OnInitialized()
    {
        game.Initialize();
        game.Player.CreateNewPuyo(); // 最初のぷよを生成
        canvasWidth = game.Config.StageWidth * game.Config.PuyoSize;
        canvasHeight = game.Config.StageHeight * game.Config.PuyoSize;
    }

    /// <summary>
    /// レンダリング完了後の処理.
    /// </summary>
    /// <param name="firstRender">初回レンダリングかどうか.</param>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("initializeGame", dotNetHelper);
            await JSRuntime.InvokeVoidAsync("startGameLoop");
        }
    }

    /// <summary>
    /// JavaScript からキーが押されたときに呼ばれる.
    /// </summary>
    /// <param name="key">押されたキー.</param>
    [JSInvokable]
    public void OnKeyDown(string key)
    {
        switch (key)
        {
            case "ArrowLeft":
                game.Player.SetInputLeft(true);
                game.Player.MoveLeft();
                break;
            case "ArrowRight":
                game.Player.SetInputRight(true);
                game.Player.MoveRight();
                break;
            case "ArrowUp":
                game.Player.SetInputUp(true);
                game.Player.RotateRight();
                break;
            case "ArrowDown":
                game.Player.SetInputDown(true);
                break;
            case "KeyX":
                game.Player.RotateLeft();
                break;
        }

        StateHasChanged();
    }

    /// <summary>
    /// JavaScript からキーが離されたときに呼ばれる.
    /// </summary>
    /// <param name="key">離されたキー.</param>
    [JSInvokable]
    public void OnKeyUp(string key)
    {
        switch (key)
        {
            case "ArrowLeft":
                game.Player.SetInputLeft(false);
                break;
            case "ArrowRight":
                game.Player.SetInputRight(false);
                break;
            case "ArrowUp":
                game.Player.SetInputUp(false);
                break;
            case "ArrowDown":
                game.Player.SetInputDown(false);
                break;
        }
    }

    /// <summary>
    /// ぷよの描画情報を JavaScript に渡す.
    /// </summary>
    /// <returns>ぷよの描画情報.</returns>
    [JSInvokable]
    public object GetPuyoData()
    {
        return new
        {
            x = game.Player.PuyoX,
            y = game.Player.PuyoY,
            type = game.Player.PuyoType,
            rotation = game.Player.Rotation,
        };
    }

    /// <summary>
    /// 落下速度を JavaScript に渡す.
    /// </summary>
    /// <returns>落下速度.</returns>
    [JSInvokable]
    public int GetDropSpeed()
    {
        return game.Player.GetDropSpeed();
    }

    /// <summary>
    /// ぷよを下に移動する.
    /// </summary>
    /// <returns>移動できたかどうか.</returns>
    [JSInvokable]
    public bool MoveDown()
    {
        return game.Player.MoveDown();
    }

    /// <summary>
    /// ぷよが着地したかどうかを判定する.
    /// </summary>
    /// <returns>着地しているかどうか.</returns>
    [JSInvokable]
    public bool HasLanded()
    {
        return game.Player.HasLanded();
    }

    /// <summary>
    /// 新しいぷよを生成する.
    /// </summary>
    [JSInvokable]
    public void CreateNewPuyo()
    {
        game.Player.CreateNewPuyo();
    }

    /// <summary>
    /// 着地したぷよをステージに配置する.
    /// </summary>
    [JSInvokable]
    public void PlacePuyoOnStage()
    {
        game.Player.PlacePuyoOnStage();
    }

    /// <summary>
    /// 連鎖処理を実行してスコアを更新する.
    /// </summary>
    [JSInvokable]
    public void ProcessChainAndUpdateScore()
    {
        // 着地後、まず重力を適用（浮いているぷよを落下させる）
        game.Stage.ApplyGravity();

        // 連鎖処理を実行
        int chainCount = game.Stage.ProcessChain();

        if (chainCount > 0)
        {
            // 連鎖が発生した場合、各連鎖のスコアを計算
            // 簡易実装: 最後の連鎖のみスコア加算
            // 実際のゲームでは各連鎖ごとにスコアを計算する必要がある
            var eraseInfo = game.Stage.CheckErase();
            int points = Score.Calculate(eraseInfo.erasePuyoCount, chainCount);
            game.Score.Add(points);

            // 全消し判定を行い、全消しならボーナスを加算
            if (game.Stage.IsAllClear())
            {
                int allClearBonus = Score.CalculateAllClearBonus();
                game.Score.Add(allClearBonus);
            }
        }
    }

    /// <summary>
    /// ステージのぷよデータを取得する.
    /// </summary>
    /// <returns>ステージのぷよデータ.</returns>
    [JSInvokable]
    public object GetStageData()
    {
        var stagePuyos = new List<object>();
        for (int y = 0; y < game.Config.StageHeight; y++)
        {
            for (int x = 0; x < game.Config.StageWidth; x++)
            {
                int puyoType = game.Stage.GetPuyo(x, y);
                if (puyoType != 0)
                {
                    stagePuyos.Add(new { x, y, type = puyoType });
                }
            }
        }

        return stagePuyos;
    }

    /// <summary>
    /// コンポーネント破棄時の処理.
    /// </summary>
    public void Dispose()
    {
        dotNetHelper?.Dispose();
    }
}
