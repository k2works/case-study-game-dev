module PuyoPuyo.Tests.Domain.盤面テスト

open Xunit
open FsUnit.Xunit
open PuyoPuyo.Domain

[<Fact>]
let ``空のボードを作成できる`` () =
    // Arrange & Act
    let board = 盤面.作成 6 13

    // Assert
    board.列数 |> should equal 6
    board.行数 |> should equal 13

[<Fact>]
let ``作成直後のボードはすべて空である`` () =
    // Arrange & Act
    let _盤面 = 盤面.作成 6 13

    // Assert
    for 行 in 0 .. _盤面.行数 - 1 do
        for 列 in 0 .. _盤面.列数 - 1 do
            盤面.セル取得 _盤面 列 行 |> should equal 空

[<Fact>]
let ``ボードにぷよを配置できる`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    // Act
    let 新しい盤面 = 盤面.セル設定 _盤面 2 10 (埋まっている 赤)

    // Assert
    盤面.セル取得 新しい盤面 2 10 |> should equal (埋まっている 赤)

[<Fact>]
let ``ボードにぷよを配置しても元のボードは変更されない`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    // Act
    let 新しい盤面 = 盤面.セル設定 _盤面 2 10 (埋まっている 赤)

    // Assert
    盤面.セル取得 _盤面 2 10 |> should equal 空
    盤面.セル取得 新しい盤面 2 10 |> should equal (埋まっている 赤)

[<Fact>]
let ``ぷよペアをボードに固定できる`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13
    let ペア = ぷよペア.作成 3 10 赤 緑 0

    // Act
    let 新しい盤面 = 盤面操作.ぷよペア固定 _盤面 ペア

    // Assert
    let (位置1, 位置2) = ぷよペア.位置取得 ペア
    let (x1, y1) = 位置1
    let (x2, y2) = 位置2
    盤面.セル取得 新しい盤面 x1 y1 |> should equal (埋まっている 赤)
    盤面.セル取得 新しい盤面 x2 y2 |> should equal (埋まっている 緑)

[<Fact>]
let ``ぷよペアを固定しても元のボードは変更されない`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13
    let ペア = ぷよペア.作成 3 10 赤 緑 0

    // Act
    let 新しい盤面 = 盤面操作.ぷよペア固定 _盤面 ペア

    // Assert
    let (位置1, _) = ぷよペア.位置取得 ペア
    let (x1, y1) = 位置1
    盤面.セル取得 _盤面 x1 y1 |> should equal 空 // 元のボードは空のまま
    盤面.セル取得 新しい盤面 x1 y1 |> should equal (埋まっている 赤) // 新しいボードには固定

[<Fact>]
let ``横に4つ並んだぷよを検出できる`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 0 12 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 1 12 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 12 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 3 12 (埋まっている 赤))

    // Act
    let グループ = 盤面.つながったグループ検出 _盤面

    // Assert
    グループ |> List.length |> should equal 1
    グループ |> List.head |> List.length |> should equal 4

[<Fact>]
let ``縦に4つ並んだぷよを検出できる`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 2 9 (埋まっている 緑))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 緑))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 緑))
        |> (fun 盤 -> 盤面.セル設定 盤 2 12 (埋まっている 緑))

    // Act
    let グループ = 盤面.つながったグループ検出 _盤面

    // Assert
    グループ |> List.length |> should equal 1
    グループ |> List.head |> List.length |> should equal 4

[<Fact>]
let ``L字型につながった5つのぷよを検出できる`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 1 10 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 1 11 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 1 12 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 12 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 3 12 (埋まっている 青))

    // Act
    let グループ = 盤面.つながったグループ検出 _盤面

    // Assert
    グループ |> List.length |> should equal 1
    グループ |> List.head |> List.length |> should equal 5

[<Fact>]
let ``3つ以下のぷよは検出されない`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 0 12 (埋まっている 黄))
        |> (fun 盤 -> 盤面.セル設定 盤 1 12 (埋まっている 黄))
        |> (fun 盤 -> 盤面.セル設定 盤 2 12 (埋まっている 黄))

    // Act
    let グループ = 盤面.つながったグループ検出 _盤面

    // Assert
    グループ |> List.length |> should equal 0

[<Fact>]
let ``指定位置のぷよを消去できる`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 赤))

    // Act
    let 消去後の盤面 = 盤面.ぷよ消去 _盤面 [ (2, 10); (2, 11) ]

    // Assert
    盤面.セル取得 消去後の盤面 2 10 |> should equal 空
    盤面.セル取得 消去後の盤面 2 11 |> should equal 空

[<Fact>]
let ``ぷよ消去後も元の盤面は変更されない`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 = _盤面 |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))

    // Act
    let 消去後の盤面 = 盤面.ぷよ消去 _盤面 [ (2, 10) ]

    // Assert
    盤面.セル取得 _盤面 2 10 |> should equal (埋まっている 赤)
    盤面.セル取得 消去後の盤面 2 10 |> should equal 空

[<Fact>]
let ``重力適用で浮いているぷよが落下する`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 12 (埋まっている 青))

    // Act - 赤を消去すると青が落下する
    let 消去後 = 盤面.ぷよ消去 _盤面 [ (2, 10) ]
    let 重力適用後 = 盤面.重力適用 消去後

    // Assert
    盤面.セル取得 重力適用後 2 12 |> should equal (埋まっている 青)
    盤面.セル取得 重力適用後 2 11 |> should equal 空
    盤面.セル取得 重力適用後 2 10 |> should equal 空

[<Fact>]
let ``重力適用で複数のぷよが正しく落下する`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 2 8 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 緑))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 青))

    // Act - 緑を消去すると赤が落下
    let 消去後 = 盤面.ぷよ消去 _盤面 [ (2, 10) ]
    let 重力適用後 = 盤面.重力適用 消去後

    // Assert
    盤面.セル取得 重力適用後 2 12 |> should equal (埋まっている 青)
    盤面.セル取得 重力適用後 2 11 |> should equal (埋まっている 赤)
    盤面.セル取得 重力適用後 2 10 |> should equal 空
    盤面.セル取得 重力適用後 2 8 |> should equal 空

[<Fact>]
let ``重力適用で列ごとに独立して落下する`` () =
    // Arrange
    let _盤面 = 盤面.作成 6 13

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 1 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 8 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 緑))

    // Act - 列2の緑を消去
    let 消去後 = 盤面.ぷよ消去 _盤面 [ (2, 10) ]
    let 重力適用後 = 盤面.重力適用 消去後

    // Assert
    // 列1は赤が下端に落下
    盤面.セル取得 重力適用後 1 12 |> should equal (埋まっている 赤)
    盤面.セル取得 重力適用後 1 10 |> should equal 空
    // 列2は青が落下
    盤面.セル取得 重力適用後 2 12 |> should equal (埋まっている 青)
    盤面.セル取得 重力適用後 2 8 |> should equal 空

[<Fact>]
let ``ぷよの消去と落下後、新たな消去パターンがあれば連鎖が発生する`` () =
    // Arrange - 連鎖が発生する盤面を作成
    // 盤面配置:
    // 0 0 0 0 0 0 (行0-6)
    // ...
    // 0 0 2 0 0 0 (行7)  青
    // 0 0 2 0 0 0 (行8)  青
    // 0 0 2 0 0 0 (行9)  青
    // 0 1 1 2 0 0 (行10) 赤赤青
    // 0 1 1 0 0 0 (行11) 赤赤
    let _盤面 = 盤面.作成 6 12

    let _盤面 =
        _盤面
        // 赤ぷよの2×2正方形（消去対象）
        |> (fun 盤 -> 盤面.セル設定 盤 1 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 1 11 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 赤))
        // 青ぷよ（赤消去後に落ちて4つつながる）
        |> (fun 盤 -> 盤面.セル設定 盤 3 10 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 7 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 8 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 9 (埋まっている 青))

    // Act - 最初の消去判定
    let groups1 = 盤面.つながったグループ検出 _盤面

    // Assert - 赤ぷよが検出される
    groups1 |> List.isEmpty |> should equal false

    // Act - 消去実行
    let positions1 = groups1 |> List.concat
    let boardAfterClear1 = 盤面.ぷよ消去 _盤面 positions1

    // Act - 落下処理
    let boardAfterGravity = 盤面.重力適用 boardAfterClear1

    // Act - 連鎖判定（2回目の消去判定）
    let groups2 = 盤面.つながったグループ検出 boardAfterGravity

    // Assert - 連鎖が発生していることを確認（青ぷよが4つつながっている）
    groups2 |> List.isEmpty |> should equal false

[<Fact>]
let ``消去と重力を繰り返し適用で連鎖が自動的に処理される`` () =
    // Arrange - 連鎖が発生する盤面を作成
    let _盤面 = 盤面.作成 6 12

    let _盤面 =
        _盤面
        // 赤ぷよの2×2正方形（最初の消去対象）
        |> (fun 盤 -> 盤面.セル設定 盤 1 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 1 11 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 赤))
        // 青ぷよ（赤消去後に落ちて4つつながる）
        |> (fun 盤 -> 盤面.セル設定 盤 3 10 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 7 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 8 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 9 (埋まっている 青))

    // Act - 連鎖処理を一度に実行
    let 連鎖処理後の盤面 = 盤面.消去と重力を繰り返し適用 _盤面

    // Assert - 赤と青がすべて消去されていることを確認
    盤面.セル取得 連鎖処理後の盤面 1 10 |> should equal 空
    盤面.セル取得 連鎖処理後の盤面 2 10 |> should equal 空
    盤面.セル取得 連鎖処理後の盤面 1 11 |> should equal 空
    盤面.セル取得 連鎖処理後の盤面 2 11 |> should equal 空
    盤面.セル取得 連鎖処理後の盤面 3 10 |> should equal 空
    盤面.セル取得 連鎖処理後の盤面 2 7 |> should equal 空
    盤面.セル取得 連鎖処理後の盤面 2 8 |> should equal 空
    盤面.セル取得 連鎖処理後の盤面 2 9 |> should equal 空

[<Fact>]
let ``連鎖数を正しくカウントできる`` () =
    // Arrange - 2連鎖が発生する盤面を作成
    let _盤面 = 盤面.作成 6 12

    let _盤面 =
        _盤面
        // 赤ぷよの2×2正方形（1連鎖目）
        |> (fun 盤 -> 盤面.セル設定 盤 1 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 1 11 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 赤))
        // 青ぷよ（2連鎖目）
        |> (fun 盤 -> 盤面.セル設定 盤 3 10 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 7 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 8 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 9 (埋まっている 青))

    // Act
    let (_, 連鎖数) = 盤面.連鎖数を数えながら処理 _盤面

    // Assert - 2連鎖が発生する
    連鎖数 |> should equal 2

[<Fact>]
let ``連鎖が発生しない場合は連鎖数が0`` () =
    // Arrange - 消去対象がない盤面
    let _盤面 = 盤面.作成 6 12

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 0 11 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 1 11 (埋まっている 青))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 緑))

    // Act
    let (_, 連鎖数) = 盤面.連鎖数を数えながら処理 _盤面

    // Assert
    連鎖数 |> should equal 0

[<Fact>]
let ``盤面上のぷよがすべて消えると全消しになる`` () =
    // Arrange - 4つの赤ぷよのみ配置（すべて消去可能）
    let _盤面 = 盤面.作成 6 12

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 1 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 1 11 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 赤))

    // Act - 消去処理
    let グループ = 盤面.つながったグループ検出 _盤面
    let 位置リスト = グループ |> List.concat
    let 消去後の盤面 = 盤面.ぷよ消去 _盤面 位置リスト

    // 全消し判定
    let 全消しか = 盤面.全消し判定 消去後の盤面

    // Assert - 全消しになっていることを確認
    全消しか |> should equal true

[<Fact>]
let ``盤面上にぷよが残っていると全消しにならない`` () =
    // Arrange - 赤ぷよ4つと青ぷよ1つ（青は残る）
    let _盤面 = 盤面.作成 6 12

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 1 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 10 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 1 11 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 2 11 (埋まっている 赤))
        |> (fun 盤 -> 盤面.セル設定 盤 3 11 (埋まっている 青)) // 消えないぷよ

    // Act - 消去処理（赤のみ消える）
    let グループ = 盤面.つながったグループ検出 _盤面
    let 位置リスト = グループ |> List.concat
    let 消去後の盤面 = 盤面.ぷよ消去 _盤面 位置リスト

    // 全消し判定
    let 全消しか = 盤面.全消し判定 消去後の盤面

    // Assert - 全消しになっていないことを確認
    全消しか |> should equal false

[<Fact>]
let ``空の盤面は全消し状態である`` () =
    // Arrange - 空の盤面
    let _盤面 = 盤面.作成 6 12

    // Act - 全消し判定
    let 全消しか = 盤面.全消し判定 _盤面

    // Assert - 空なので全消し
    全消しか |> should equal true

[<Fact>]
let ``連鎖数を数えながら処理は消去対象がなくても重力を適用する`` () =
    // Arrange - 浮いているぷよがあるが消去対象はない盤面
    let _盤面 = 盤面.作成 6 12

    let _盤面 =
        _盤面
        |> (fun 盤 -> 盤面.セル設定 盤 2 5 (埋まっている 赤)) // 浮いている赤
        |> (fun 盤 -> 盤面.セル設定 盤 2 8 (埋まっている 青)) // 浮いている青

    // Act - 連鎖数を数えながら処理
    let (最終盤面, 連鎖数) = 盤面.連鎖数を数えながら処理 _盤面

    // Assert - 連鎖は発生しない
    連鎖数 |> should equal 0

    // Assert - 重力が適用されてぷよが下に落ちている
    // 行0から走査して`::`で追加するため、行8の青が先頭、行5の赤が2番目
    // リスト = [青; 赤]、下から配置すると: 行11に青、行10に赤
    盤面.セル取得 最終盤面 2 11 |> should equal (埋まっている 青)
    盤面.セル取得 最終盤面 2 10 |> should equal (埋まっている 赤)
    盤面.セル取得 最終盤面 2 5 |> should equal 空
    盤面.セル取得 最終盤面 2 8 |> should equal 空
