namespace PuyoPuyo.Domain

open PuyoPuyo.Domain

/// セルの状態
type セル =
    | 空
    | 埋まっている of ぷよの色

/// ゲームボード
type 盤面 = { 列数: int; 行数: int; セル配列: セル[][] }

module 盤面 =
    /// 空のボードを作成
    let 作成 (列数: int) (行数: int) : 盤面 =
        { 列数 = 列数
          行数 = 行数
          セル配列 = Array.init 行数 (fun _ -> Array.create 列数 空) }

    /// セルの取得
    let セル取得 (盤面: 盤面) (列: int) (行: int) : セル =
        if 行 >= 0 && 行 < 盤面.行数 && 列 >= 0 && 列 < 盤面.列数 then
            盤面.セル配列.[行].[列]
        else
            空

    /// セルの設定（イミュータブル）
    let セル設定 (盤面: 盤面) (設定列: int) (設定行: int) (設定セル: セル) : 盤面 =
        if 設定行 >= 0 && 設定行 < 盤面.行数 && 設定列 >= 0 && 設定列 < 盤面.列数 then
            let 新しいセル配列 =
                盤面.セル配列
                |> Array.mapi (fun 行 列内セル配列 ->
                    if 行 = 設定行 then
                        列内セル配列 |> Array.mapi (fun 列 セル -> if 列 = 設定列 then 設定セル else セル)
                    else
                        列内セル配列)

            { 盤面 with セル配列 = 新しいセル配列 }
        else
            盤面

    /// 2つの位置にぷよを固定（ぷよペア用のヘルパー関数）
    let ぷよ2つ固定 (盤面: 盤面) (位置1: int * int) (色1: ぷよの色) (位置2: int * int) (色2: ぷよの色) : 盤面 =
        let (x1, y1) = 位置1
        let (x2, y2) = 位置2

        盤面 |> (fun 盤 -> セル設定 盤 x1 y1 (埋まっている 色1)) |> (fun 盤 -> セル設定 盤 x2 y2 (埋まっている 色2))

    /// つながったぷよグループを検出（BFS アルゴリズム）
    let つながったグループ検出 (盤面: 盤面) : (int * int) list list =
        let 訪問済み = Array.init 盤面.行数 (fun _ -> Array.create 盤面.列数 false)
        let mutable グループリスト = []

        /// BFS で同じ色のつながったぷよを探索
        let BFS探索 (開始列: int) (開始行: int) (対象色: ぷよの色) : (int * int) list =
            let キュー = System.Collections.Generic.Queue<int * int>()
            let mutable グループ = []

            キュー.Enqueue((開始列, 開始行))
            訪問済み.[開始行].[開始列] <- true

            while キュー.Count > 0 do
                let (現在列, 現在行) = キュー.Dequeue()
                グループ <- (現在列, 現在行) :: グループ

                // 上下左右の隣接セルをチェック
                let 隣接セル = [ (現在列 - 1, 現在行); (現在列 + 1, 現在行); (現在列, 現在行 - 1); (現在列, 現在行 + 1) ]

                for (隣列, 隣行) in 隣接セル do
                    if 隣行 >= 0 && 隣行 < 盤面.行数 && 隣列 >= 0 && 隣列 < 盤面.列数 && not 訪問済み.[隣行].[隣列] then
                        match セル取得 盤面 隣列 隣行 with
                        | 埋まっている 色 when 色 = 対象色 ->
                            訪問済み.[隣行].[隣列] <- true
                            キュー.Enqueue((隣列, 隣行))
                        | _ -> ()

            グループ

        // すべてのセルをスキャン
        for 行 in 0 .. 盤面.行数 - 1 do
            for 列 in 0 .. 盤面.列数 - 1 do
                if not 訪問済み.[行].[列] then
                    match セル取得 盤面 列 行 with
                    | 埋まっている 色 ->
                        let グループ = BFS探索 列 行 色

                        // 4つ以上つながっている場合のみリストに追加
                        if List.length グループ >= 4 then
                            グループリスト <- グループ :: グループリスト
                    | 空 -> 訪問済み.[行].[列] <- true

        グループリスト

    /// 指定位置のぷよを消去
    let ぷよ消去 (盤面: 盤面) (消去位置リスト: (int * int) list) : 盤面 =
        List.fold (fun 現在の盤面 (列, 行) -> セル設定 現在の盤面 列 行 空) 盤面 消去位置リスト

    /// 重力を適用（浮いているぷよを落下させる）
    let 重力適用 (盤面: 盤面) : 盤面 =
        // 各列に対して重力を適用
        let rec 列を処理 (現在の盤面: 盤面) (列: int) : 盤面 =
            if 列 >= 盤面.列数 then
                現在の盤面
            else
                // 下から順に空でないセルを集める（現在の盤面から読み取る）
                let mutable ぷよリスト = []

                for 行 in 0 .. 盤面.行数 - 1 do
                    match セル取得 現在の盤面 列 行 with
                    | 埋まっている 色 -> ぷよリスト <- 色 :: ぷよリスト
                    | 空 -> ()

                // 列全体をクリア
                let mutable 列クリア後 = 現在の盤面

                for 行 in 0 .. 盤面.行数 - 1 do
                    列クリア後 <- セル設定 列クリア後 列 行 空

                // 下から順にぷよを配置
                let mutable 現在行 = 盤面.行数 - 1
                let mutable 列処理後 = 列クリア後

                for 色 in ぷよリスト do
                    列処理後 <- セル設定 列処理後 列 現在行 (埋まっている 色)
                    現在行 <- 現在行 - 1

                列を処理 列処理後 (列 + 1)

        列を処理 盤面 0

    /// 消去と重力を繰り返し適用（連鎖処理）
    let rec 消去と重力を繰り返し適用 (盤面: 盤面) : 盤面 =
        // まず重力を適用（浮いているぷよを落とす）
        let 重力適用後の盤面 = 重力適用 盤面
        let グループ = つながったグループ検出 重力適用後の盤面

        if List.isEmpty グループ then
            // 消去対象がない場合は終了
            重力適用後の盤面
        else
            // 消去して再帰的に処理
            let 位置リスト = グループ |> List.concat
            let 消去後の盤面 = ぷよ消去 重力適用後の盤面 位置リスト

            // 再帰的に消去判定を繰り返す
            消去と重力を繰り返し適用 消去後の盤面

    /// 連鎖数をカウントしながら消去と重力を繰り返し適用
    let 連鎖数を数えながら処理 (盤面: 盤面) : 盤面 * int =
        let rec 処理 (現在の盤面: 盤面) (連鎖数: int) : 盤面 * int =
            // まず重力を適用（浮いているぷよを落とす）
            let 重力適用後の盤面 = 重力適用 現在の盤面
            let グループ = つながったグループ検出 重力適用後の盤面

            if List.isEmpty グループ then
                // 消去対象がない場合は終了
                (重力適用後の盤面, 連鎖数)
            else
                // 消去して再帰的に処理（連鎖数をインクリメント）
                let 位置リスト = グループ |> List.concat
                let 消去後の盤面 = ぷよ消去 重力適用後の盤面 位置リスト

                // 再帰的に消去判定を繰り返す
                処理 消去後の盤面 (連鎖数 + 1)

        処理 盤面 0

    /// 全消し判定（盤面上にぷよがあるかチェック）
    let 全消し判定 (盤面: 盤面) : bool =
        盤面.セル配列 |> Array.forall (fun row -> row |> Array.forall (fun セル -> セル = 空))
