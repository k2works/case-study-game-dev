# ドメインモデル設計

## 概要

ぷよぷよゲームのドメインモデル設計について説明します。ドメイン駆動設計（DDD）の戦術的設計パターンを適用し、ビジネスロジックを適切にモデル化します。

## ドメイン分析

### ユビキタス言語

```plantuml
@startuml "ユビキタス言語"
card "ゲーム用語" {
  together {
    card "ぷよ"
    card "組ぷよ"
    card "フィールド"
    card "連鎖"
    card "消去"
  }
  
  together {
    card "全消し"
    card "落下"
    card "固定"
    card "回転"
    card "窒息"
  }
}

note right : ドメインエキスパート\n（ぷよぷよプレイヤー）と\n開発者が共通で使用する用語
@enduml
```

**主要用語定義:**

- **ぷよ:** 色付きのゲーム要素
- **組ぷよ:** 2つのぷよがセットになった操作対象
- **フィールド:** ぷよが配置される6×12のグリッド空間
- **連鎖:** ぷよ消去により新たな消去条件が成立すること
- **消去:** 同色のぷよが4つ以上隣接した際の除去処理
- **全消し:** フィールドのすべてのぷよが消去されること
- **落下:** 重力によるぷよの下方移動
- **固定:** 落下中のぷよがフィールドに配置されること
- **回転:** 組ぷよの相対位置変更
- **窒息:** 新しいぷよが配置できない状態
- **壁蹴り:** 回転時の位置調整

## 境界づけられたコンテキスト

```plantuml
@startuml "境界づけられたコンテキスト"
rectangle "ゲームプレイコンテキスト" {
  package "ゲームセッション" {
    [Game]
    [Field] 
    [PuyoPair]
    [GameState]
  }
  
  package "ぷよ操作" {
    [PuyoMovement]
    [PuyoRotation]
    [PuyoPlacement]
  }
  
  package "連鎖システム" {
    [ChainDetection]
    [PuyoErasure]
    [GravityApplication]
  }
}

rectangle "スコアリングコンテキスト" {
  package "得点計算" {
    [Score]
    [ScoreCalculation]
    [ChainBonus]
    [GroupBonus]
  }
  
  package "記録管理" {
    [HighScore]
    [GameRecord]
  }
}

rectangle "ユーザーインタラクションコンテキスト" {
  package "入力処理" {
    [InputCommand]
    [InputValidation]
  }
  
  package "表示制御" {
    [GameView]
    [Animation]
  }
}

[Game] --> [Score] : 参照
[ChainDetection] --> [ScoreCalculation] : 結果提供
[InputCommand] --> [PuyoMovement] : 指示
@enduml
```

## 集約設計

### Game集約

```plantuml
@startuml "Game集約"
class Game <<AggregateRoot>> {
  -id: GameId
  -field: Field
  -currentPuyo: PuyoPair
  -nextPuyo: PuyoPair
  -score: Score
  -state: GameState
  -timer: GameTimer
  
  +startNewGame(): void
  +handleInput(command: InputCommand): DomainEvent[]
  +updateGameLoop(): DomainEvent[]
  +checkGameOver(): boolean
  +pauseGame(): void
  +resumeGame(): void
}

class Field <<Entity>> {
  -width: number
  -height: number  
  -grid: Puyo[][]
  
  +placePuyo(puyo: Puyo, position: Position): void
  +removePuyo(position: Position): Puyo
  +findConnectedPuyos(startPos: Position): Puyo[]
  +detectErasableGroups(): PuyoGroup[]
  +applyGravity(): GravityResult
  +isEmpty(): boolean
  +isValidPosition(pos: Position): boolean
}

class PuyoPair <<ValueObject>> {
  -mainPuyo: Puyo
  -subPuyo: Puyo
  -rotation: Rotation
  -position: Position
  
  +rotate(direction: RotationDirection): PuyoPair
  +move(direction: Direction): PuyoPair
  +getOccupiedPositions(): Position[]
  +canPlaceOn(field: Field): boolean
}

class Puyo <<ValueObject>> {
  -color: PuyoColor
  -position: Position
  
  +moveTo(newPosition: Position): Puyo
  +equals(other: Puyo): boolean
  +isConnectedTo(other: Puyo): boolean
}

class Score <<ValueObject>> {
  -current: number
  -multiplier: number
  
  +add(points: number): Score
  +applyMultiplier(factor: number): Score
  +reset(): Score
}

Game *-- Field
Game *-- PuyoPair
Game *-- Score
Field o-- Puyo
PuyoPair *-- Puyo
@enduml
```

### Chain集約

```plantuml
@startuml "Chain集約"
class ChainProcessor <<AggregateRoot>> {
  -chainCount: number
  -totalErasedCount: number
  -chainMultiplier: ChainMultiplier
  
  +processChain(field: Field): ChainResult
  +calculateChainScore(erasedGroups: PuyoGroup[]): number
  +isChainComplete(): boolean
  +reset(): void
}

class PuyoGroup <<ValueObject>> {
  -puyos: Puyo[]
  -color: PuyoColor
  -erasureScore: number
  
  +size(): number
  +calculateBaseScore(): number
  +getPositions(): Position[]
  +contains(puyo: Puyo): boolean
}

class ChainResult <<ValueObject>> {
  -erasedGroups: PuyoGroup[]
  -score: number
  -chainLength: number
  -isAllClear: boolean
  
  +getTotalScore(): number
  +hasChain(): boolean
  +getChainBonus(): number
}

class GravityResult <<ValueObject>> {
  -movedPuyos: PuyoMovement[]
  -hasMovement: boolean
  
  +getMovements(): PuyoMovement[]
  +hasChanges(): boolean
}

ChainProcessor *-- ChainResult
ChainResult o-- PuyoGroup
@enduml
```

## ドメインサービス

### ゲーム基本サービス

```plantuml
@startuml "ゲーム基本サービス"
class ChainDetectionService <<DomainService>> {
  +detectConnectedPuyos(field: Field, startPosition: Position): PuyoGroup
  +findErasableGroups(field: Field): PuyoGroup[]
  +calculateErasureScore(groups: PuyoGroup[]): number
  +determineChainContinuation(field: Field): boolean
}

class GravityService <<DomainService>> {
  +applyGravity(field: Field): GravityResult
  +calculateFallDistance(puyo: Puyo, field: Field): number
  +simulateGravity(field: Field): Field
}

class CollisionService <<DomainService>> {
  +checkCollision(puyoPair: PuyoPair, field: Field): boolean
  +findLandingPosition(puyoPair: PuyoPair, field: Field): Position
  +validatePlacement(puyo: Puyo, position: Position, field: Field): boolean
}

class ScoreCalculationService <<DomainService>> {
  +calculateBaseScore(puyoCount: number): number
  +calculateChainBonus(chainLength: number): number
  +calculateGroupBonus(groupCount: number): number
  +calculateAllClearBonus(): number
}

ChainDetectionService --> CollisionService
GravityService --> CollisionService
@enduml
```

### AI評価サービス（関数型実装）

```plantuml
@startuml "AI評価サービス"
package "domain/services/ai" {
  class EvaluationService <<FunctionalService>> {
    {static} +evaluateMove(move: PossibleMove, gameState: AIGameState, settings?: EvaluationSettings): MoveEvaluation
    {static} +evaluateMoveWithML(move: PossibleMove, gameState: AIGameState, mlScore: number, settings?: EvaluationSettings): MoveEvaluation
    {static} +getBestMove(moves: PossibleMove[], gameState: AIGameState, settings?: EvaluationSettings): PossibleMove | null
    {static} +evaluateAndSortMoves(moves: PossibleMove[], gameState: AIGameState, settings?: EvaluationSettings): EvaluatedMove[]
    {static} +evaluateAndSortMovesWithML(movesWithML: MoveWithMLScore[], gameState: AIGameState, settings?: EvaluationSettings): EvaluatedMove[]
    {static} +calculateBaseScores(move: PossibleMove, field: AIFieldState, settings: EvaluationSettings): BaseScores
    {static} +createInvalidMoveEvaluation(): MoveEvaluation
    {static} +createBasicMoveEvaluation(move: PossibleMove, gameState: AIGameState, settings: EvaluationSettings): MoveEvaluation
    {static} +createMLEnhancedMoveEvaluation(move: PossibleMove, gameState: AIGameState, mlScore: number, settings: EvaluationSettings): MoveEvaluation
    {static} +updateEvaluationSettings(current: EvaluationSettings, updates: Partial<EvaluationSettings>): EvaluationSettings
  }
  
  class EvaluationSettings <<ValueObject>> {
    +heightWeight: number
    +centerWeight: number
    +mlWeight: number
  }
  
  class MoveEvaluation <<ValueObject>> {
    +heightScore: number
    +centerScore: number
    +modeScore: number
    +totalScore: number
    +averageY: number
    +averageX: number
    +distanceFromCenter: number
    +reason: string
  }
  
  class BaseScores <<ValueObject>> {
    +heightScore: number
    +centerScore: number
    +avgY: number
    +avgX: number
    +distanceFromCenter: number
  }
}

EvaluationService ..> EvaluationSettings : uses
EvaluationService ..> MoveEvaluation : creates
EvaluationService ..> BaseScores : creates
EvaluationService ..> AIGameState : analyzes
EvaluationService ..> PossibleMove : evaluates

note right of EvaluationService
  **関数型設計原則:**
  - 純粋関数のみ（副作用なし）
  - イミュータブルデータ
  - 合成可能な小さな関数
  - 予測可能な動作
  
  **実装特徴:**
  - 全関数がstatic（状態なし）
  - 引数による動作決定
  - 新しいオブジェクト返却
  - テスト容易性
end note
@enduml
```

### 関数型評価サービス実装例

```typescript
// 純粋関数による評価実装例
export const evaluateMove = (
  move: PossibleMove,
  gameState: AIGameState,
  settings: EvaluationSettings = DEFAULT_EVALUATION_SETTINGS,
): MoveEvaluation => {
  if (!move.isValid) {
    return createInvalidMoveEvaluation()
  }
  
  return createBasicMoveEvaluation(move, gameState, settings)
}

// 関数合成による複合評価
export const evaluateAndSortMoves = (
  moves: PossibleMove[],
  gameState: AIGameState,
  settings: EvaluationSettings = DEFAULT_EVALUATION_SETTINGS,
): Array<PossibleMove & { evaluation: MoveEvaluation }> =>
  moves
    .map((move) => ({
      ...move,
      evaluation: evaluateMove(move, gameState, settings),
    }))
    .sort((a, b) => b.evaluation.totalScore - a.evaluation.totalScore)

// 設定の部分更新（イミュータブル）
export const updateEvaluationSettings = (
  currentSettings: EvaluationSettings,
  updates: Partial<EvaluationSettings>,
): EvaluationSettings => ({
  ...currentSettings,
  ...updates,
})
```

### 関数型設計の利点

```plantuml
@startuml "関数型設計の利点"
package "従来のクラスベース" {
  class OldEvaluationService {
    -state: EvaluationState
    +evaluateMove(): void
    +getResult(): MoveEvaluation
  }
  
  note right: 状態を持つため\n・副作用あり\n・テストが複雑\n・予測困難
}

package "関数型アプローチ" {
  class EvaluationService <<FunctionalService>> {
    {static} +evaluateMove(): MoveEvaluation
    {static} +calculateBaseScores(): BaseScores
  }
  
  note right: 純粋関数のため\n・副作用なし\n・テストが容易\n・予測可能\n・合成可能
}

package "利点" {
  class Benefit_Testability as "テスタビリティ向上" <<Benefit>>
  class Benefit_Maintainability as "保守性向上" <<Benefit>>
  class Benefit_Debuggability as "デバッグ容易性" <<Benefit>>
  class Benefit_ConcurrencySafety as "並行処理安全性" <<Benefit>>
  class Benefit_DupReduction as "コード重複削減" <<Benefit>>
}

EvaluationService --> Benefit_Testability
EvaluationService --> Benefit_Maintainability
EvaluationService --> Benefit_Debuggability
EvaluationService --> Benefit_ConcurrencySafety
EvaluationService --> Benefit_DupReduction
@enduml
```

## ドメインイベント

```plantuml
@startuml "ドメインイベント"
abstract class DomainEvent {
  +occurredAt: Date
  +aggregateId: string
  +eventVersion: number
}

class GameStartedEvent {
  +gameId: GameId
  +startedAt: Date
}

class PuyoPlacedEvent {
  +gameId: GameId
  +puyo: Puyo
  +position: Position
}

class PuyosErasedEvent {
  +gameId: GameId
  +erasedGroups: PuyoGroup[]
  +chainCount: number
  +score: number
}

class ChainCompletedEvent {
  +gameId: GameId
  +finalChainCount: number
  +totalScore: number
  +isAllClear: boolean
}

class GameOverEvent {
  +gameId: GameId
  +finalScore: number
  +endedAt: Date
}

class ScoreUpdatedEvent {
  +gameId: GameId
  +previousScore: number
  +newScore: number
  +addedPoints: number
}

class AIDecisionMadeEvent {
  +gameId: GameId
  +strategy: string
  +decision: AIMove
  +confidence: number
}

class StrategyChangedEvent {
  +strategyId: string
  +previousStrategy: string
  +newStrategy: string
}

DomainEvent <|-- GameStartedEvent
DomainEvent <|-- PuyoPlacedEvent
DomainEvent <|-- PuyosErasedEvent
DomainEvent <|-- ChainCompletedEvent
DomainEvent <|-- GameOverEvent
DomainEvent <|-- ScoreUpdatedEvent
DomainEvent <|-- AIDecisionMadeEvent
DomainEvent <|-- StrategyChangedEvent
@enduml
```

## 仕様パターン

### ゲームルール仕様

```plantuml
@startuml "仕様パターン"
interface Specification<T> {
  +isSatisfiedBy(candidate: T): boolean
  +and(other: Specification<T>): Specification<T>
  +or(other: Specification<T>): Specification<T>
  +not(): Specification<T>
}

class ErasableGroupSpecification {
  +isSatisfiedBy(group: PuyoGroup): boolean
}

class ValidPlacementSpecification {
  +isSatisfiedBy(placement: PuyoPlacement): boolean
}

class GameOverSpecification {
  +isSatisfiedBy(game: Game): boolean
}

class ChainContinuationSpecification {
  +isSatisfiedBy(field: Field): boolean
}

Specification <|.. ErasableGroupSpecification
Specification <|.. ValidPlacementSpecification  
Specification <|.. GameOverSpecification
Specification <|.. ChainContinuationSpecification
@enduml
```

**具体的な仕様実装:**

```typescript
class ErasableGroupSpecification implements Specification<PuyoGroup> {
  isSatisfiedBy(group: PuyoGroup): boolean {
    return group.size() >= 4 && 
           group.puyos.every(p => p.color === group.color);
  }
}

class ValidPlacementSpecification implements Specification<PuyoPlacement> {
  constructor(private field: Field) {}
  
  isSatisfiedBy(placement: PuyoPlacement): boolean {
    return this.field.isValidPosition(placement.position) &&
           !this.field.isOccupied(placement.position) &&
           this.hasSupport(placement);
  }
  
  private hasSupport(placement: PuyoPlacement): boolean {
    // 重力サポートの確認ロジック
  }
}
```

## ファクトリーパターン

### ゲーム要素の生成

```plantuml
@startuml "ファクトリーパターン"
class GameFactory {
  +createNewGame(): Game
  +createGameFromSave(data: GameData): Game
}

class PuyoPairFactory {
  +createRandomPuyoPair(): PuyoPair
  +createPuyoPair(color1: PuyoColor, color2: PuyoColor): PuyoPair
  +createTestPuyoPair(): PuyoPair
}

class FieldFactory {
  +createEmptyField(): Field
  +createFieldWithPuyos(puyos: Puyo[]): Field
  +createTestField(pattern: TestPattern): Field
}

class ChainProcessorFactory {
  +createChainProcessor(config: ChainConfig): ChainProcessor
}

GameFactory --> FieldFactory
GameFactory --> PuyoPairFactory
GameFactory --> ChainProcessorFactory
@enduml
```

## リポジトリパターン

### ドメインオブジェクトの永続化

```plantuml
@startuml "リポジトリパターン"
interface GameRepository {
  +save(game: Game): Promise<void>
  +findById(id: GameId): Promise<Game>
  +findLatest(): Promise<Game>
  +delete(id: GameId): Promise<void>
}

interface ScoreRepository {
  +saveHighScore(score: number): Promise<void>
  +getHighScore(): Promise<number>
  +getScoreHistory(): Promise<Score[]>
}

class InMemoryGameRepository {
  -games: Map<GameId, Game>
  +save(game: Game): Promise<void>
  +findById(id: GameId): Promise<Game>
}

class LocalStorageGameRepository {
  -storage: Storage
  -serializer: GameSerializer
  +save(game: Game): Promise<void>
  +findById(id: GameId): Promise<Game>
}

GameRepository <|.. InMemoryGameRepository
GameRepository <|.. LocalStorageGameRepository
@enduml
```

## ドメインルールの実装

### 不変条件 (Invariants)

```typescript
class Game {
  private constructor(
    private readonly id: GameId,
    private field: Field,
    private currentPuyo: PuyoPair,
    private nextPuyo: PuyoPair,
    private score: Score,
    private state: GameState
  ) {
    this.ensureInvariants();
  }
  
  private ensureInvariants(): void {
    if (!this.field) {
      throw new DomainError('Game must have a field');
    }
    
    if (this.state === GameState.PLAYING && !this.currentPuyo) {
      throw new DomainError('Playing game must have current puyo');
    }
    
    if (this.score.current < 0) {
      throw new DomainError('Score cannot be negative');
    }
  }
  
  handleInput(command: InputCommand): DomainEvent[] {
    this.ensureGameIsPlaying();
    
    const events: DomainEvent[] = [];
    
    switch (command.type) {
      case InputType.MOVE_LEFT:
        if (this.canMoveLeft()) {
          this.currentPuyo = this.currentPuyo.move(Direction.LEFT);
          events.push(new PuyoMovedEvent(this.id, this.currentPuyo));
        }
        break;
        
      case InputType.ROTATE:
        if (this.canRotate()) {
          this.currentPuyo = this.currentPuyo.rotate(RotationDirection.CLOCKWISE);
          events.push(new PuyoRotatedEvent(this.id, this.currentPuyo));
        }
        break;
        
      case InputType.DROP:
        events.push(...this.dropCurrentPuyo());
        break;
    }
    
    this.ensureInvariants();
    return events;
  }
}
```

### ビジネスロジックの実装

```typescript
class ChainProcessor {
  processChain(field: Field): ChainResult {
    const erasedGroups: PuyoGroup[] = [];
    let chainCount = 0;
    let totalScore = 0;
    
    while (true) {
      // 消去対象のグループを検索
      const currentErasableGroups = this.chainDetectionService
        .findErasableGroups(field);
        
      if (currentErasableGroups.length === 0) {
        break; // 連鎖終了
      }
      
      chainCount++;
      
      // ぷよを消去
      for (const group of currentErasableGroups) {
        this.eraseGroup(field, group);
        erasedGroups.push(group);
      }
      
      // スコア計算
      const chainScore = this.scoreCalculationService
        .calculateChainScore(currentErasableGroups, chainCount);
      totalScore += chainScore;
      
      // 重力適用
      const gravityResult = this.gravityService.applyGravity(field);
      if (!gravityResult.hasMovement) {
        break; // これ以上の落下なし
      }
    }
    
    const isAllClear = field.isEmpty();
    if (isAllClear) {
      totalScore += this.scoreCalculationService.calculateAllClearBonus();
    }
    
    return new ChainResult(erasedGroups, totalScore, chainCount, isAllClear);
  }
}
```

## エラーハンドリング

### ドメイン例外

```plantuml
@startuml "ドメイン例外"
abstract class DomainError {
  +message: string
  +code: ErrorCode
}

class InvalidGameStateError {
  +currentState: GameState
  +attemptedAction: string
}

class InvalidPuyoPlacementError {
  +position: Position
  +reason: string
}

class GameOverError {
  +cause: string
}

class InvariantViolationError {
  +violatedRule: string
  +objectState: any
}

DomainError <|-- InvalidGameStateError
DomainError <|-- InvalidPuyoPlacementError
DomainError <|-- GameOverError
DomainError <|-- InvariantViolationError
@enduml
```

## テスト戦略

### ドメインモデルのテスト

```plantuml
@startuml "テスト戦略"
package "単体テスト" {
  [Game Tests]
  [Field Tests]
  [PuyoPair Tests]
  [ChainProcessor Tests]
}

package "統合テスト" {
  [ゲームフロー Tests]
  [連鎖システム Tests]
  [スコア計算 Tests]
}

package "仕様テスト" {
  [ビジネスルール Tests]
  [不変条件 Tests]
  [エラーハンドリング Tests]
}

[Game Tests] --> [Field Tests]
[ChainProcessor Tests] --> [ゲームフロー Tests]
[ビジネスルール Tests] --> [不変条件 Tests]
@enduml
```

### テストデータビルダー

```typescript
class GameTestDataBuilder {
  private game: Game;
  
  constructor() {
    this.game = GameFactory.createNewGame();
  }
  
  withField(field: Field): GameTestDataBuilder {
    this.game = new Game(
      this.game.id,
      field,
      this.game.currentPuyo,
      this.game.nextPuyo,
      this.game.score,
      this.game.state
    );
    return this;
  }
  
  withScore(score: number): GameTestDataBuilder {
    this.game = new Game(
      this.game.id,
      this.game.field,
      this.game.currentPuyo,
      this.game.nextPuyo,
      new Score(score, this.game.score.high),
      this.game.state
    );
    return this;
  }
  
  build(): Game {
    return this.game;
  }
}
```

## AI関連ドメインモデル

### AI戦略値オブジェクト

```plantuml
@startuml "AI戦略モデル"
class StrategyValueObject <<ValueObject>> {
  -id: string
  -name: string
  -type: StrategyType
  -description: string
  -parameters: StrategyParameters
  -createdAt: Date
  -updatedAt: Date
  
  +equals(other: StrategyValueObject): boolean
  +toConfig(): StrategyConfig
  +isDefault(): boolean
  +isCustom(): boolean
}

class StrategyParameters <<ValueObject>> {
  -chainWeight: number
  -heightWeight: number
  -centerWeight: number
  -erasureWeight: number
  -riskWeight: number
  
  +validate(): boolean
  +normalize(): StrategyParameters
  +combine(other: StrategyParameters): StrategyParameters
}

class PerformanceMetrics <<Entity>> {
  -id: string
  -gameHistory: GameResult[]
  -averageScore: number
  -averageChainLength: number
  -winRate: number
  -lastUpdated: Date
  
  +addGameResult(result: GameResult): void
  +calculateAverageScore(): number
  +getRecentPerformance(games: number): PerformanceStats
  +compareWith(other: PerformanceMetrics): Comparison
}

class AIDecision <<ValueObject>> {
  -position: Position
  -rotation: number
  -confidence: number
  -evaluationScore: number
  -alternativeMoves: Move[]
  
  +isHighConfidence(): boolean
  +getBestAlternative(): Move
}

StrategyValueObject *-- StrategyParameters
PerformanceMetrics o-- StrategyValueObject
AIDecision o-- StrategyValueObject
@enduml
```

### AIドメインサービス

```plantuml
@startuml "AIドメインサービス"
class EvaluationService <<DomainService>> {
  +evaluateMove(move: PossibleMove, gameState: AIGameState, settings: EvaluationSettings): MoveEvaluation
  +evaluateMoveWithML(move: PossibleMove, gameState: AIGameState, mlScore: number, settings: EvaluationSettings): MoveEvaluation
  +getBestMove(moves: PossibleMove[], gameState: AIGameState): PossibleMove
  +evaluateAndSortMoves(moves: PossibleMove[], gameState: AIGameState): EvaluatedMove[]
  +calculateBaseScores(move: PossibleMove, field: AIFieldState, settings: EvaluationSettings): BaseScores
}

class StrategyOptimizationService <<DomainService>> {
  +optimizeStrategy(metrics: PerformanceMetrics): StrategyParameters
  +suggestStrategyAdjustment(currentStrategy: StrategyValueObject, performance: PerformanceMetrics): StrategyValueObject
  +compareStrategies(strategies: StrategyValueObject[]): StrategyComparison
}

class PerformanceAnalysisService <<DomainService>> {
  +analyzeGamePerformance(game: Game, strategy: StrategyValueObject): GameAnalysis
  +identifyWeaknesses(metrics: PerformanceMetrics): Weakness[]
  +generateImprovement suggestions(analysis: GameAnalysis): Suggestion[]
}

EvaluationService --> AIGameState
EvaluationService --> MoveEvaluation
EvaluationService --> EvaluationSettings
StrategyOptimizationService --> PerformanceMetrics
PerformanceAnalysisService --> PerformanceMetrics
@enduml
```

## まとめ

このドメインモデル設計により以下を実現：

1. **表現力:** ビジネスロジックが自然な言語で表現
2. **整合性:** 不変条件によるデータ整合性保証
3. **拡張性:** 新しいゲームルールやAI戦略の追加が容易
4. **テスタビリティ:** ドメインロジックの独立したテスト
5. **保守性:** 複雑なビジネスルールの明確な構造化
6. **再利用性:** ドメインサービスによる共通ロジックの抽出
7. **AI統合:** 戦略パターンとパフォーマンス分析のドメインモデル化
8. **関数型アプローチ:** 純粋関数による予測可能で安全な評価ロジック

### 関数型リファクタリング成果

#### EvaluationService関数型化（2025-08-19実装）
- **純粋関数化:** 副作用を排除し、予測可能な動作を実現
- **テスタビリティ向上:** 17のテストケースで100%カバレッジ達成
- **コード重複削減:** AIService、MLAIServiceの評価ロジックを統合
- **合成可能性:** 小さな関数の組み合わせによる柔軟な評価システム
- **保守性向上:** 状態管理不要による理解しやすいコード構造

#### 技術的メリット
- **並行処理安全性:** 状態なしによるスレッドセーフな処理
- **デバッグ容易性:** 入力と出力の明確な対応関係
- **拡張性:** 新しい評価関数の追加が容易
- **一貫性:** 関数型パラダイムによる統一されたアプローチ