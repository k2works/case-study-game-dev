# ドメインモデル設計

## 概要

ぷよぷよゲームのドメインモデル設計について説明します。ドメイン駆動設計（DDD）の戦術的設計パターンを適用し、ビジネスロジックを適切にモデル化します。

## ドメイン分析

### ユビキタス言語

```plantuml
@startuml "ユビキタス言語"
card "ゲーム用語" {
  together {
    card "ぷよ"
    card "組ぷよ"
    card "フィールド"
    card "連鎖"
    card "消去"
  }
  
  together {
    card "全消し"
    card "落下"
    card "固定"
    card "回転"
    card "窒息"
  }
}

note right : ドメインエキスパート\n（ぷよぷよプレイヤー）と\n開発者が共通で使用する用語
@enduml
```

**主要用語定義:**

- **ぷよ:** 色付きのゲーム要素
- **組ぷよ:** 2つのぷよがセットになった操作対象
- **フィールド:** ぷよが配置される6×12のグリッド空間
- **連鎖:** ぷよ消去により新たな消去条件が成立すること
- **消去:** 同色のぷよが4つ以上隣接した際の除去処理
- **全消し:** フィールドのすべてのぷよが消去されること
- **落下:** 重力によるぷよの下方移動
- **固定:** 落下中のぷよがフィールドに配置されること
- **回転:** 組ぷよの相対位置変更
- **窒息:** 新しいぷよが配置できない状態
- **壁蹴り:** 回転時の位置調整

## 境界づけられたコンテキスト

```plantuml
@startuml "境界づけられたコンテキスト"
rectangle "ゲームプレイコンテキスト" {
  package "ゲームセッション" {
    [Game]
    [Field] 
    [PuyoPair]
    [GameState]
  }
  
  package "ぷよ操作" {
    [PuyoMovement]
    [PuyoRotation]
    [PuyoPlacement]
  }
  
  package "連鎖システム" {
    [ChainDetection]
    [PuyoErasure]
    [GravityApplication]
  }
}

rectangle "スコアリングコンテキスト" {
  package "得点計算" {
    [Score]
    [ScoreCalculation]
    [ChainBonus]
    [GroupBonus]
  }
  
  package "記録管理" {
    [HighScore]
    [GameRecord]
  }
}

rectangle "ユーザーインタラクションコンテキスト" {
  package "入力処理" {
    [InputCommand]
    [InputValidation]
  }
  
  package "表示制御" {
    [GameView]
    [Animation]
  }
}

[Game] --> [Score] : 参照
[ChainDetection] --> [ScoreCalculation] : 結果提供
[InputCommand] --> [PuyoMovement] : 指示
@enduml
```

## 集約設計

### Game集約

```plantuml
@startuml "Game集約"
class Game <<AggregateRoot>> {
  -id: GameId
  -field: Field
  -currentPuyo: PuyoPair
  -nextPuyo: PuyoPair
  -score: Score
  -state: GameState
  -timer: GameTimer
  
  +startNewGame(): void
  +handleInput(command: InputCommand): DomainEvent[]
  +updateGameLoop(): DomainEvent[]
  +checkGameOver(): boolean
  +pauseGame(): void
  +resumeGame(): void
}

class Field <<Entity>> {
  -width: number
  -height: number  
  -grid: Puyo[][]
  
  +placePuyo(puyo: Puyo, position: Position): void
  +removePuyo(position: Position): Puyo
  +findConnectedPuyos(startPos: Position): Puyo[]
  +detectErasableGroups(): PuyoGroup[]
  +applyGravity(): GravityResult
  +isEmpty(): boolean
  +isValidPosition(pos: Position): boolean
}

class PuyoPair <<ValueObject>> {
  -mainPuyo: Puyo
  -subPuyo: Puyo
  -rotation: Rotation
  -position: Position
  
  +rotate(direction: RotationDirection): PuyoPair
  +move(direction: Direction): PuyoPair
  +getOccupiedPositions(): Position[]
  +canPlaceOn(field: Field): boolean
}

class Puyo <<ValueObject>> {
  -color: PuyoColor
  -position: Position
  
  +moveTo(newPosition: Position): Puyo
  +equals(other: Puyo): boolean
  +isConnectedTo(other: Puyo): boolean
}

class Score <<ValueObject>> {
  -current: number
  -multiplier: number
  
  +add(points: number): Score
  +applyMultiplier(factor: number): Score
  +reset(): Score
}

Game *-- Field
Game *-- PuyoPair
Game *-- Score
Field o-- Puyo
PuyoPair *-- Puyo
@enduml
```

### Chain集約

```plantuml
@startuml "Chain集約"
class ChainProcessor <<AggregateRoot>> {
  -chainCount: number
  -totalErasedCount: number
  -chainMultiplier: ChainMultiplier
  
  +processChain(field: Field): ChainResult
  +calculateChainScore(erasedGroups: PuyoGroup[]): number
  +isChainComplete(): boolean
  +reset(): void
}

class PuyoGroup <<ValueObject>> {
  -puyos: Puyo[]
  -color: PuyoColor
  -erasureScore: number
  
  +size(): number
  +calculateBaseScore(): number
  +getPositions(): Position[]
  +contains(puyo: Puyo): boolean
}

class ChainResult <<ValueObject>> {
  -erasedGroups: PuyoGroup[]
  -score: number
  -chainLength: number
  -isAllClear: boolean
  
  +getTotalScore(): number
  +hasChain(): boolean
  +getChainBonus(): number
}

class GravityResult <<ValueObject>> {
  -movedPuyos: PuyoMovement[]
  -hasMovement: boolean
  
  +getMovements(): PuyoMovement[]
  +hasChanges(): boolean
}

ChainProcessor *-- ChainResult
ChainResult o-- PuyoGroup
@enduml
```

## ドメインサービス

### ChainDetectionService

```plantuml
@startuml "ChainDetectionService"
class ChainDetectionService <<DomainService>> {
  +detectConnectedPuyos(field: Field, startPosition: Position): PuyoGroup
  +findErasableGroups(field: Field): PuyoGroup[]
  +calculateErasureScore(groups: PuyoGroup[]): number
  +determineChainContinuation(field: Field): boolean
}

class GravityService <<DomainService>> {
  +applyGravity(field: Field): GravityResult
  +calculateFallDistance(puyo: Puyo, field: Field): number
  +simulateGravity(field: Field): Field
}

class CollisionService <<DomainService>> {
  +checkCollision(puyoPair: PuyoPair, field: Field): boolean
  +findLandingPosition(puyoPair: PuyoPair, field: Field): Position
  +validatePlacement(puyo: Puyo, position: Position, field: Field): boolean
}

class ScoreCalculationService <<DomainService>> {
  +calculateBaseScore(puyoCount: number): number
  +calculateChainBonus(chainLength: number): number
  +calculateGroupBonus(groupCount: number): number
  +calculateAllClearBonus(): number
}

ChainDetectionService --> CollisionService
GravityService --> CollisionService
@enduml
```

## ドメインイベント

```plantuml
@startuml "ドメインイベント"
abstract class DomainEvent {
  +occurredAt: Date
  +aggregateId: string
  +eventVersion: number
}

class GameStartedEvent {
  +gameId: GameId
  +startedAt: Date
}

class PuyoPlacedEvent {
  +gameId: GameId
  +puyo: Puyo
  +position: Position
}

class PuyosErasedEvent {
  +gameId: GameId
  +erasedGroups: PuyoGroup[]
  +chainCount: number
  +score: number
}

class ChainCompletedEvent {
  +gameId: GameId
  +finalChainCount: number
  +totalScore: number
  +isAllClear: boolean
}

class GameOverEvent {
  +gameId: GameId
  +finalScore: number
  +endedAt: Date
}

class ScoreUpdatedEvent {
  +gameId: GameId
  +previousScore: number
  +newScore: number
  +addedPoints: number
}

DomainEvent <|-- GameStartedEvent
DomainEvent <|-- PuyoPlacedEvent
DomainEvent <|-- PuyosErasedEvent
DomainEvent <|-- ChainCompletedEvent
DomainEvent <|-- GameOverEvent
DomainEvent <|-- ScoreUpdatedEvent
@enduml
```

## 仕様パターン

### ゲームルール仕様

```plantuml
@startuml "仕様パターン"
interface Specification<T> {
  +isSatisfiedBy(candidate: T): boolean
  +and(other: Specification<T>): Specification<T>
  +or(other: Specification<T>): Specification<T>
  +not(): Specification<T>
}

class ErasableGroupSpecification {
  +isSatisfiedBy(group: PuyoGroup): boolean
}

class ValidPlacementSpecification {
  +isSatisfiedBy(placement: PuyoPlacement): boolean
}

class GameOverSpecification {
  +isSatisfiedBy(game: Game): boolean
}

class ChainContinuationSpecification {
  +isSatisfiedBy(field: Field): boolean
}

Specification <|.. ErasableGroupSpecification
Specification <|.. ValidPlacementSpecification  
Specification <|.. GameOverSpecification
Specification <|.. ChainContinuationSpecification
@enduml
```

**具体的な仕様実装:**

```typescript
class ErasableGroupSpecification implements Specification<PuyoGroup> {
  isSatisfiedBy(group: PuyoGroup): boolean {
    return group.size() >= 4 && 
           group.puyos.every(p => p.color === group.color);
  }
}

class ValidPlacementSpecification implements Specification<PuyoPlacement> {
  constructor(private field: Field) {}
  
  isSatisfiedBy(placement: PuyoPlacement): boolean {
    return this.field.isValidPosition(placement.position) &&
           !this.field.isOccupied(placement.position) &&
           this.hasSupport(placement);
  }
  
  private hasSupport(placement: PuyoPlacement): boolean {
    // 重力サポートの確認ロジック
  }
}
```

## ファクトリーパターン

### ゲーム要素の生成

```plantuml
@startuml "ファクトリーパターン"
class GameFactory {
  +createNewGame(): Game
  +createGameFromSave(data: GameData): Game
}

class PuyoPairFactory {
  +createRandomPuyoPair(): PuyoPair
  +createPuyoPair(color1: PuyoColor, color2: PuyoColor): PuyoPair
  +createTestPuyoPair(): PuyoPair
}

class FieldFactory {
  +createEmptyField(): Field
  +createFieldWithPuyos(puyos: Puyo[]): Field
  +createTestField(pattern: TestPattern): Field
}

class ChainProcessorFactory {
  +createChainProcessor(config: ChainConfig): ChainProcessor
}

GameFactory --> FieldFactory
GameFactory --> PuyoPairFactory
GameFactory --> ChainProcessorFactory
@enduml
```

## リポジトリパターン

### ドメインオブジェクトの永続化

```plantuml
@startuml "リポジトリパターン"
interface GameRepository {
  +save(game: Game): Promise<void>
  +findById(id: GameId): Promise<Game>
  +findLatest(): Promise<Game>
  +delete(id: GameId): Promise<void>
}

interface ScoreRepository {
  +saveHighScore(score: number): Promise<void>
  +getHighScore(): Promise<number>
  +getScoreHistory(): Promise<Score[]>
}

class InMemoryGameRepository {
  -games: Map<GameId, Game>
  +save(game: Game): Promise<void>
  +findById(id: GameId): Promise<Game>
}

class LocalStorageGameRepository {
  -storage: Storage
  -serializer: GameSerializer
  +save(game: Game): Promise<void>
  +findById(id: GameId): Promise<Game>
}

GameRepository <|.. InMemoryGameRepository
GameRepository <|.. LocalStorageGameRepository
@enduml
```

## ドメインルールの実装

### 不変条件 (Invariants)

```typescript
class Game {
  private constructor(
    private readonly id: GameId,
    private field: Field,
    private currentPuyo: PuyoPair,
    private nextPuyo: PuyoPair,
    private score: Score,
    private state: GameState
  ) {
    this.ensureInvariants();
  }
  
  private ensureInvariants(): void {
    if (!this.field) {
      throw new DomainError('Game must have a field');
    }
    
    if (this.state === GameState.PLAYING && !this.currentPuyo) {
      throw new DomainError('Playing game must have current puyo');
    }
    
    if (this.score.current < 0) {
      throw new DomainError('Score cannot be negative');
    }
  }
  
  handleInput(command: InputCommand): DomainEvent[] {
    this.ensureGameIsPlaying();
    
    const events: DomainEvent[] = [];
    
    switch (command.type) {
      case InputType.MOVE_LEFT:
        if (this.canMoveLeft()) {
          this.currentPuyo = this.currentPuyo.move(Direction.LEFT);
          events.push(new PuyoMovedEvent(this.id, this.currentPuyo));
        }
        break;
        
      case InputType.ROTATE:
        if (this.canRotate()) {
          this.currentPuyo = this.currentPuyo.rotate(RotationDirection.CLOCKWISE);
          events.push(new PuyoRotatedEvent(this.id, this.currentPuyo));
        }
        break;
        
      case InputType.DROP:
        events.push(...this.dropCurrentPuyo());
        break;
    }
    
    this.ensureInvariants();
    return events;
  }
}
```

### ビジネスロジックの実装

```typescript
class ChainProcessor {
  processChain(field: Field): ChainResult {
    const erasedGroups: PuyoGroup[] = [];
    let chainCount = 0;
    let totalScore = 0;
    
    while (true) {
      // 消去対象のグループを検索
      const currentErasableGroups = this.chainDetectionService
        .findErasableGroups(field);
        
      if (currentErasableGroups.length === 0) {
        break; // 連鎖終了
      }
      
      chainCount++;
      
      // ぷよを消去
      for (const group of currentErasableGroups) {
        this.eraseGroup(field, group);
        erasedGroups.push(group);
      }
      
      // スコア計算
      const chainScore = this.scoreCalculationService
        .calculateChainScore(currentErasableGroups, chainCount);
      totalScore += chainScore;
      
      // 重力適用
      const gravityResult = this.gravityService.applyGravity(field);
      if (!gravityResult.hasMovement) {
        break; // これ以上の落下なし
      }
    }
    
    const isAllClear = field.isEmpty();
    if (isAllClear) {
      totalScore += this.scoreCalculationService.calculateAllClearBonus();
    }
    
    return new ChainResult(erasedGroups, totalScore, chainCount, isAllClear);
  }
}
```

## エラーハンドリング

### ドメイン例外

```plantuml
@startuml "ドメイン例外"
abstract class DomainError {
  +message: string
  +code: ErrorCode
}

class InvalidGameStateError {
  +currentState: GameState
  +attemptedAction: string
}

class InvalidPuyoPlacementError {
  +position: Position
  +reason: string
}

class GameOverError {
  +cause: string
}

class InvariantViolationError {
  +violatedRule: string
  +objectState: any
}

DomainError <|-- InvalidGameStateError
DomainError <|-- InvalidPuyoPlacementError
DomainError <|-- GameOverError
DomainError <|-- InvariantViolationError
@enduml
```

## テスト戦略

### ドメインモデルのテスト

```plantuml
@startuml "テスト戦略"
package "単体テスト" {
  [Game Tests]
  [Field Tests]
  [PuyoPair Tests]
  [ChainProcessor Tests]
}

package "統合テスト" {
  [ゲームフロー Tests]
  [連鎖システム Tests]
  [スコア計算 Tests]
}

package "仕様テスト" {
  [ビジネスルール Tests]
  [不変条件 Tests]
  [エラーハンドリング Tests]
}

[Game Tests] --> [Field Tests]
[ChainProcessor Tests] --> [ゲームフロー Tests]
[ビジネスルール Tests] --> [不変条件 Tests]
@enduml
```

### テストデータビルダー

```typescript
class GameTestDataBuilder {
  private game: Game;
  
  constructor() {
    this.game = GameFactory.createNewGame();
  }
  
  withField(field: Field): GameTestDataBuilder {
    this.game = new Game(
      this.game.id,
      field,
      this.game.currentPuyo,
      this.game.nextPuyo,
      this.game.score,
      this.game.state
    );
    return this;
  }
  
  withScore(score: number): GameTestDataBuilder {
    this.game = new Game(
      this.game.id,
      this.game.field,
      this.game.currentPuyo,
      this.game.nextPuyo,
      new Score(score, this.game.score.high),
      this.game.state
    );
    return this;
  }
  
  build(): Game {
    return this.game;
  }
}
```

## まとめ

このドメインモデル設計により以下を実現：

1. **表現力:** ビジネスロジックが自然な言語で表現
2. **整合性:** 不変条件によるデータ整合性保証
3. **拡張性:** 新しいゲームルールの追加が容易
4. **テスタビリティ:** ドメインロジックの独立したテスト
5. **保守性:** 複雑なビジネスルールの明確な構造化
6. **再利用性:** ドメインサービスによる共通ロジックの抽出