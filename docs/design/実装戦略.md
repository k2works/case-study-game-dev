# å®Ÿè£…æˆ¦ç•¥

## æ¦‚è¦

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€ã·ã‚ˆã·ã‚ˆã‚²ãƒ¼ãƒ é–‹ç™ºã«ãŠã‘ã‚‹å…·ä½“çš„ãªå®Ÿè£…æˆ¦ç•¥ã‚’å®šç¾©ã—ã¾ã™ã€‚CLAUDE.local.mdã§æŒ‡å®šã•ã‚ŒãŸTDDé–‹ç™ºãƒ•ãƒ­ãƒ¼ã¨ã€è¨­è¨ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«åŸºã¥ã„ãŸæ®µéšçš„å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æ¡ç”¨ã—ã¾ã™ã€‚

## å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

### 1. ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆ vs ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³

```plantuml
@startuml "å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒé¸æŠãƒ•ãƒ­ãƒ¼"
start
:ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆãƒ¼ãƒªãƒ¼;
if (CRUDå®Ÿè£…æ¸ˆã¿?) then (ã¯ã„)
  :ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«;
  :ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³;
  :ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤;
  :ã‚µãƒ¼ãƒ“ã‚¹å±¤;
  :ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤;
  :ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤;
  :ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹;
else (ã„ã„ãˆ)
  :è²§è¡€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«;
  :ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆ;
  :ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹;
  :ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤;
  :ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤;
  :ã‚µãƒ¼ãƒ“ã‚¹å±¤;
  :ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤;
endif
if (APIå®Ÿè£…æ¸ˆã¿?) then (ã¯ã„)
  :ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆ;
else (ã„ã„ãˆ)
  :ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³;
endif
stop
@enduml
```

### 2. é¸æŠåŸºæº–

**ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆæ¨å¥¨ï¼‰:**
- **å¯¾è±¡:** ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ï¼ˆPuyo, Field, Game, Chainï¼‰
- **ç†ç”±:** 
  - æ–°è¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§CRUDæœªå®Ÿè£…
  - è¤‡é›‘ãªã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸­å¿ƒã§æ§‹ç¯‰
  - ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãªé–‹ç™ºãŒå¯èƒ½

**ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆéƒ¨åˆ†æ¡ç”¨ï¼‰:**
- **å¯¾è±¡:** UI ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã€ã‚¿ãƒƒãƒæ“ä½œï¼‰
- **ç†ç”±:**
  - ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’æ—©æœŸã«ç¢ºèª
  - ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã‚’çŸ­ç¸®

## TDDå®Ÿè£…ã‚µã‚¤ã‚¯ãƒ«

### Red-Green-Refactorã‚µã‚¤ã‚¯ãƒ«

```plantuml
@startuml "TDDå®Ÿè£…ã‚µã‚¤ã‚¯ãƒ«è©³ç´°"
start
:TODOãƒªã‚¹ãƒˆç¢ºèª;

partition "Red Phase" {
  :å¤±æ•—ãƒ†ã‚¹ãƒˆä½œæˆ;
  :æœŸå¾…ã™ã‚‹å‹•ä½œã‚’å®šç¾©;
  :æœ€å°é™ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹;
  :ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ â†’ å¤±æ•—ç¢ºèª;
}

partition "Green Phase" {
  :æœ€å°å®Ÿè£…;
  :ãƒ†ã‚¹ãƒˆãŒé€šã‚‹æœ€å°ã‚³ãƒ¼ãƒ‰;
  :é€Ÿåº¦å„ªå…ˆã€å“è³ªã¯äºŒã®æ¬¡;
  :ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ â†’ æˆåŠŸç¢ºèª;
}

partition "Refactor Phase" {
  :ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°;
  :é‡è¤‡ã‚³ãƒ¼ãƒ‰é™¤å»;
  :è¨­è¨ˆã®æ”¹å–„;
  :ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–;
  :ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ â†’ æˆåŠŸç¶­æŒ;
}

partition "å“è³ªãƒã‚§ãƒƒã‚¯" {
  :ã‚³ãƒ¼ãƒ‰ã®æ•´å½¢ (npm run format);
  :ãƒªãƒ³ãƒˆ (npm run lint);
  :ãƒ“ãƒ«ãƒ‰ (npm run build);
  :ãƒ†ã‚¹ãƒˆ (npm run test);
  if (ã‚¨ãƒ©ãƒ¼ã‚ã‚Š?) then (yes)
    :ä¿®æ­£;
    :ä¿®æ­£; --> :ã‚³ãƒ¼ãƒ‰ã®æ•´å½¢ (npm run format);
  else (no)
    :ã‚³ãƒŸãƒƒãƒˆ;
  endif
}

if (TODOå®Œäº†?) then (no)
  :æ¬¡ã®TODOé¸æŠ;
  :æ¬¡ã®TODOé¸æŠ; --> :å¤±æ•—ãƒ†ã‚¹ãƒˆä½œæˆ;
else (yes)
  stop
endif
@enduml
```

## å®Ÿè£…é †åº

### Phase 3: é–‹ç™ºãƒ•ã‚§ãƒ¼ã‚º

#### Iteration 1: ã‚²ãƒ¼ãƒ åŸºç›¤ï¼ˆMVPï¼‰

```plantuml
@startuml "Iteration 1 å®Ÿè£…é †åº"
!define DOMAIN_COLOR #FFE6CC
!define APP_COLOR #E6F3FF  
!define INFRA_COLOR #E6FFE6

skinparam shadowing false

package "Week 1: ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«å®Ÿè£…" DOMAIN_COLOR {
  [1. Puyo ã‚¯ãƒ©ã‚¹] --> [2. Field ã‚¯ãƒ©ã‚¹] 
  [2. Field ã‚¯ãƒ©ã‚¹] --> [3. Game ã‚¯ãƒ©ã‚¹]
  [3. Game ã‚¯ãƒ©ã‚¹] --> [4. åŸºæœ¬ãƒ­ã‚¸ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ]
}

package "Week 2: åŸºæœ¬UIãƒ»çµ±åˆ" APP_COLOR {
  [5. GameBoard ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ] --> [6. çŠ¶æ…‹ç®¡ç† (Zustand)]
  [6. çŠ¶æ…‹ç®¡ç† (Zustand)] --> [7. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›]
  [7. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›] --> [8. çµ±åˆãƒ†ã‚¹ãƒˆ]
}

[4. åŸºæœ¬ãƒ­ã‚¸ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ] --> [5. GameBoard ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ]

@enduml
```

#### Iteration 2: æ¶ˆå»ãƒ»é€£é–ã‚·ã‚¹ãƒ†ãƒ 

```plantuml
@startuml "Iteration 2 å®Ÿè£…é †åº"
!define WEEK1_COLOR #FFE6CC
!define WEEK2_COLOR #E6F3FF

skinparam shadowing false

package "Week 1: é€£é–æ¤œå‡º" WEEK1_COLOR {
  [1. é€£çµã·ã‚ˆæ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ] --> [2. æ¶ˆå»åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯]
  [2. æ¶ˆå»åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯] --> [3. é‡åŠ›é©ç”¨ã‚·ã‚¹ãƒ†ãƒ ]
  [3. é‡åŠ›é©ç”¨ã‚·ã‚¹ãƒ†ãƒ ] --> [4. ãƒã‚§ãƒ¼ãƒ³ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹]
}

package "Week 2: ã‚¹ã‚³ã‚¢ãƒ»ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼" WEEK2_COLOR {
  [5. ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯] --> [6. é€£é–ãƒœãƒ¼ãƒŠã‚¹]
  [6. é€£é–ãƒœãƒ¼ãƒŠã‚¹] --> [7. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š]
  [7. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š] --> [8. UIçµ±åˆãƒ»çµæœè¡¨ç¤º]
}

[4. ãƒã‚§ãƒ¼ãƒ³ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹] --> [5. ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯]

@enduml
```

## ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤å®Ÿè£…æˆ¦ç•¥

### 1. å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆValue Objectsï¼‰

#### Puyoå®Ÿè£…ä¾‹

```typescript
// Red: å¤±æ•—ãƒ†ã‚¹ãƒˆ
describe('Puyo', () => {
  test('åŒã˜è‰²ã¨ä½ç½®ã®Puyoã¯ç­‰ä¾¡ã§ã‚ã‚‹', () => {
    // Given
    const puyo1 = new Puyo(PuyoColor.RED, new Position(1, 2));
    const puyo2 = new Puyo(PuyoColor.RED, new Position(1, 2));
    
    // When & Then
    expect(puyo1.equals(puyo2)).toBe(true);
  });
  
  test('ç•°ãªã‚‹è‰²ã®Puyoã¯ç­‰ä¾¡ã§ãªã„', () => {
    // Given
    const puyo1 = new Puyo(PuyoColor.RED, new Position(1, 2));
    const puyo2 = new Puyo(PuyoColor.BLUE, new Position(1, 2));
    
    // When & Then
    expect(puyo1.equals(puyo2)).toBe(false);
  });
});

// Green: æœ€å°å®Ÿè£…
export class Puyo {
  constructor(
    private readonly color: PuyoColor,
    private readonly position: Position
  ) {}
  
  equals(other: Puyo): boolean {
    return this.color === other.color && 
           this.position.equals(other.position);
  }
  
  getColor(): PuyoColor { return this.color; }
  getPosition(): Position { return this.position; }
}

// Refactor: è¨­è¨ˆæ”¹å–„
export class Puyo {
  private constructor(
    private readonly color: PuyoColor,
    private readonly position: Position
  ) {
    this.validateColor(color);
    this.validatePosition(position);
  }
  
  static create(color: PuyoColor, position: Position): Puyo {
    return new Puyo(color, position);
  }
  
  equals(other: Puyo): boolean {
    return this.color === other.color && 
           this.position.equals(other.position);
  }
  
  moveTo(newPosition: Position): Puyo {
    return new Puyo(this.color, newPosition);
  }
  
  private validateColor(color: PuyoColor): void {
    if (!Object.values(PuyoColor).includes(color)) {
      throw new Error(`Invalid puyo color: ${color}`);
    }
  }
  
  private validatePosition(position: Position): void {
    if (!position.isValid()) {
      throw new Error(`Invalid position: ${position}`);
    }
  }
}
```

### 2. ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆEntitiesï¼‰

#### Fieldå®Ÿè£…ä¾‹

```typescript
// Red: å¤±æ•—ãƒ†ã‚¹ãƒˆ
describe('Field', () => {
  test('ç©ºã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½œæˆã§ãã‚‹', () => {
    // Given & When
    const field = Field.createEmpty();
    
    // Then
    expect(field.isEmpty()).toBe(true);
    expect(field.getWidth()).toBe(6);
    expect(field.getHeight()).toBe(12);
  });
  
  test('æŒ‡å®šä½ç½®ã«Puyoã‚’é…ç½®ã§ãã‚‹', () => {
    // Given
    const field = Field.createEmpty();
    const puyo = Puyo.create(PuyoColor.RED, new Position(0, 0));
    
    // When
    const newField = field.placePuyo(puyo);
    
    // Then
    expect(newField.getPuyoAt(new Position(0, 0))).toEqual(puyo);
  });
});

// Green: æœ€å°å®Ÿè£…
export class Field {
  private constructor(
    private readonly grid: (Puyo | null)[][],
    private readonly width: number = 6,
    private readonly height: number = 12
  ) {}
  
  static createEmpty(): Field {
    const grid = Array(12).fill(null)
      .map(() => Array(6).fill(null));
    return new Field(grid);
  }
  
  isEmpty(): boolean {
    return this.grid.every(row => 
      row.every(cell => cell === null)
    );
  }
  
  placePuyo(puyo: Puyo): Field {
    const newGrid = this.copyGrid();
    const pos = puyo.getPosition();
    newGrid[pos.getY()][pos.getX()] = puyo;
    return new Field(newGrid);
  }
  
  getPuyoAt(position: Position): Puyo | null {
    return this.grid[position.getY()][position.getX()];
  }
}
```

### 3. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆDomain Servicesï¼‰

#### ChainDetectionServiceå®Ÿè£…ä¾‹

```typescript
// Red: å¤±æ•—ãƒ†ã‚¹ãƒˆ
describe('ChainDetectionService', () => {
  test('4ã¤ä»¥ä¸Šã®åŒè‰²ã·ã‚ˆãŒéš£æ¥ã—ã¦ã„ã‚‹å ´åˆã€æ¶ˆå»å¯¾è±¡ã¨ã—ã¦æ¤œå‡ºã•ã‚Œã‚‹', () => {
    // Given
    const field = createFieldWithPattern([
      ['R', 'R', '.', '.', '.', '.'],
      ['R', 'R', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.'],
    ]);
    const service = new ChainDetectionService();
    
    // When
    const result = service.detectErasableGroups(field);
    
    // Then
    expect(result).toHaveLength(1);
    expect(result[0].size).toBe(4);
    expect(result[0].color).toBe(PuyoColor.RED);
  });
});

// Green: æœ€å°å®Ÿè£…
export class ChainDetectionService {
  detectErasableGroups(field: Field): PuyoGroup[] {
    const visited = new Set<string>();
    const erasableGroups: PuyoGroup[] = [];
    
    for (let y = 0; y < field.getHeight(); y++) {
      for (let x = 0; x < field.getWidth(); x++) {
        const position = new Position(x, y);
        const puyo = field.getPuyoAt(position);
        
        if (puyo && !visited.has(position.toString())) {
          const group = this.findConnectedGroup(
            field, position, puyo.getColor(), visited
          );
          
          if (group.size >= 4) {
            erasableGroups.push(group);
          }
        }
      }
    }
    
    return erasableGroups;
  }
  
  private findConnectedGroup(
    field: Field, 
    startPos: Position, 
    color: PuyoColor, 
    visited: Set<string>
  ): PuyoGroup {
    // æ·±åº¦å„ªå…ˆæ¢ç´¢ã«ã‚ˆã‚‹é€£çµã·ã‚ˆæ¤œç´¢
    const group = new PuyoGroup(color);
    const stack = [startPos];
    
    while (stack.length > 0) {
      const currentPos = stack.pop()!;
      
      if (visited.has(currentPos.toString())) continue;
      
      const puyo = field.getPuyoAt(currentPos);
      if (!puyo || puyo.getColor() !== color) continue;
      
      visited.add(currentPos.toString());
      group.addPuyo(puyo);
      
      // éš£æ¥ä½ç½®ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ 
      const neighbors = currentPos.getNeighbors();
      stack.push(...neighbors.filter(pos => 
        field.isValidPosition(pos) && 
        !visited.has(pos.toString())
      ));
    }
    
    return group;
  }
}
```

## ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤å®Ÿè£…æˆ¦ç•¥

### 1. ã‚²ãƒ¼ãƒ ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆGame Serviceï¼‰

```typescript
// Red: å¤±æ•—ãƒ†ã‚¹ãƒˆ
describe('GameService', () => {
  test('ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«åˆæœŸçŠ¶æ…‹ãŒæ­£ã—ãè¨­å®šã•ã‚Œã‚‹', () => {
    // Given
    const gameRepository = createMockGameRepository();
    const service = new GameService(gameRepository);
    
    // When
    const gameId = service.startNewGame();
    
    // Then
    const game = service.getGame(gameId);
    expect(game.getState()).toBe(GameState.READY);
    expect(game.getScore().getCurrent()).toBe(0);
    expect(game.getField().isEmpty()).toBe(true);
  });
  
  test('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¥åŠ›ã‚’å‡¦ç†ã—ã¦ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°ã§ãã‚‹', () => {
    // Given
    const service = new GameService(createMockGameRepository());
    const gameId = service.startNewGame();
    const command = new MovePuyoCommand(Direction.LEFT);
    
    // When
    const result = service.handlePlayerInput(gameId, command);
    
    // Then
    expect(result.isSuccess()).toBe(true);
    expect(result.getEvents()).toContainEqual(
      expect.objectContaining({ type: 'PuyoMovedEvent' })
    );
  });
});

// Green: æœ€å°å®Ÿè£…
export class GameService {
  constructor(
    private gameRepository: GameRepository,
    private chainDetectionService: ChainDetectionService = new ChainDetectionService()
  ) {}
  
  startNewGame(): GameId {
    const gameId = GameId.generate();
    const game = Game.startNew(gameId);
    
    this.gameRepository.save(game);
    return gameId;
  }
  
  handlePlayerInput(gameId: GameId, command: InputCommand): GameResult {
    const game = this.gameRepository.findById(gameId);
    if (!game) {
      return GameResult.failure('Game not found');
    }
    
    const events = game.handleInput(command);
    this.gameRepository.save(game);
    
    return GameResult.success(events);
  }
  
  getGame(gameId: GameId): Game {
    return this.gameRepository.findById(gameId);
  }
}
```

## ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤å®Ÿè£…æˆ¦ç•¥

### 1. Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

```typescript
// React Testing Library ã‚’ä½¿ç”¨ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ†ã‚¹ãƒˆ
describe('GameBoardComponent', () => {
  test('ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’æ­£ã—ãè¡¨ç¤ºã™ã‚‹', () => {
    // Given
    const field = createFieldWithPattern([
      ['R', 'G', '.', '.', '.', '.'],
      ['B', 'Y', '.', '.', '.', '.'],
    ]);
    
    // When
    render(<GameBoard field={field} />);
    
    // Then
    expect(screen.getByTestId('puyo-0-0')).toHaveClass('puyo-red');
    expect(screen.getByTestId('puyo-1-0')).toHaveClass('puyo-green');
    expect(screen.getByTestId('puyo-0-1')).toHaveClass('puyo-blue');
    expect(screen.getByTestId('puyo-1-1')).toHaveClass('puyo-yellow');
  });
  
  test('ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã‚’é©åˆ‡ã«å‡¦ç†ã™ã‚‹', () => {
    // Given
    const mockHandleInput = jest.fn();
    render(<GameBoard onInput={mockHandleInput} />);
    
    // When
    fireEvent.keyDown(document, { key: 'ArrowLeft' });
    
    // Then
    expect(mockHandleInput).toHaveBeenCalledWith(
      expect.objectContaining({ type: 'MOVE_LEFT' })
    );
  });
});

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå®Ÿè£…
interface GameBoardProps {
  field: Field;
  currentPuyo?: PuyoPair;
  onInput?: (command: InputCommand) => void;
}

export const GameBoard: React.FC<GameBoardProps> = ({ 
  field, 
  currentPuyo, 
  onInput 
}) => {
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const command = mapKeyToCommand(event.key);
      if (command && onInput) {
        onInput(command);
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [onInput]);
  
  return (
    <div className="game-board" data-testid="game-board">
      {Array.from({ length: field.getHeight() }, (_, y) => 
        Array.from({ length: field.getWidth() }, (_, x) => {
          const position = new Position(x, y);
          const puyo = field.getPuyoAt(position);
          
          return (
            <div 
              key={`${x}-${y}`}
              data-testid={`puyo-${x}-${y}`}
              className={`cell ${puyo ? `puyo-${puyo.getColor().toLowerCase()}` : 'empty'}`}
            />
          );
        })
      )}
    </div>
  );
};
```

### 2. çŠ¶æ…‹ç®¡ç†ï¼ˆZustandï¼‰

```typescript
// ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†ã‚¹ãƒˆã‚¢
interface GameState {
  // çŠ¶æ…‹
  currentGame: Game | null;
  gameStatus: GameStatus;
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  startNewGame: () => void;
  handleInput: (command: InputCommand) => void;
  resetGame: () => void;
}

export const useGameStore = create<GameState>((set, get) => ({
  currentGame: null,
  gameStatus: GameStatus.NOT_STARTED,
  
  startNewGame: () => {
    const gameService = new GameService(new InMemoryGameRepository());
    const gameId = gameService.startNewGame();
    const game = gameService.getGame(gameId);
    
    set({
      currentGame: game,
      gameStatus: GameStatus.PLAYING,
    });
  },
  
  handleInput: (command: InputCommand) => {
    const { currentGame } = get();
    if (!currentGame) return;
    
    const events = currentGame.handleInput(command);
    
    set({ 
      currentGame: currentGame // ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã§æ–°ã—ã„å‚ç…§
    });
  },
  
  resetGame: () => {
    set({
      currentGame: null,
      gameStatus: GameStatus.NOT_STARTED,
    });
  },
}));

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã®ä½¿ç”¨
export const GameContainer: React.FC = () => {
  const { currentGame, gameStatus, startNewGame, handleInput } = useGameStore();
  
  if (gameStatus === GameStatus.NOT_STARTED) {
    return (
      <div>
        <button onClick={startNewGame}>ã‚²ãƒ¼ãƒ é–‹å§‹</button>
      </div>
    );
  }
  
  return (
    <div>
      <GameBoard 
        field={currentGame.getField()}
        currentPuyo={currentGame.getCurrentPuyo()}
        onInput={handleInput}
      />
      <ScoreDisplay score={currentGame.getScore()} />
    </div>
  );
};
```

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥å®Ÿè£…

### 1. ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ“ãƒ«ãƒ€ãƒ¼

```typescript
export class GameTestDataBuilder {
  private game: Game;
  
  constructor() {
    this.game = Game.startNew(GameId.generate());
  }
  
  withField(pattern: string[][]): GameTestDataBuilder {
    const field = FieldFactory.createFromPattern(pattern);
    this.game = this.game.withField(field);
    return this;
  }
  
  withScore(score: number): GameTestDataBuilder {
    this.game = this.game.withScore(new Score(score, 0));
    return this;
  }
  
  withState(state: GameState): GameTestDataBuilder {
    this.game = this.game.withState(state);
    return this;
  }
  
  build(): Game {
    return this.game;
  }
}

// ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ˜ãƒ«ãƒ‘ãƒ¼
export class FieldFactory {
  static createFromPattern(pattern: string[][]): Field {
    const field = Field.createEmpty();
    
    return pattern.reduce((acc, row, y) => {
      return row.reduce((fieldAcc, cell, x) => {
        if (cell !== '.') {
          const color = this.mapCharToColor(cell);
          const puyo = Puyo.create(color, new Position(x, y));
          return fieldAcc.placePuyo(puyo);
        }
        return fieldAcc;
      }, acc);
    }, field);
  }
  
  private static mapCharToColor(char: string): PuyoColor {
    const colorMap = {
      'R': PuyoColor.RED,
      'G': PuyoColor.GREEN,
      'B': PuyoColor.BLUE,
      'Y': PuyoColor.YELLOW,
      'P': PuyoColor.PURPLE
    };
    
    return colorMap[char] || PuyoColor.RED;
  }
}
```

### 2. çµ±åˆãƒ†ã‚¹ãƒˆ

```typescript
describe('ã‚²ãƒ¼ãƒ çµ±åˆãƒ†ã‚¹ãƒˆ', () => {
  test('å®Œå…¨ãªã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ãŒæ­£ã—ãå‹•ä½œã™ã‚‹', async () => {
    // Given: ã‚²ãƒ¼ãƒ é–‹å§‹
    const gameService = new GameService(new InMemoryGameRepository());
    const gameId = gameService.startNewGame();
    
    // When: ä¸€é€£ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œã‚’å®Ÿè¡Œ
    await gameService.handlePlayerInput(gameId, new MovePuyoCommand(Direction.LEFT));
    await gameService.handlePlayerInput(gameId, new RotatePuyoCommand());
    await gameService.handlePlayerInput(gameId, new QuickDropCommand());
    
    // Then: ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãŒæœŸå¾…é€šã‚Šã«æ›´æ–°ã•ã‚Œã‚‹
    const game = gameService.getGame(gameId);
    expect(game.getState()).toBe(GameState.PLACING_NEXT_PUYO);
    expect(game.getField().isEmpty()).toBe(false);
  });
  
  test('é€£é–ãŒæ­£ã—ãç™ºç”Ÿã—ã¦ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã‚‹', async () => {
    // Given: é€£é–ãŒç™ºç”Ÿã—ã‚„ã™ã„åˆæœŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    const field = FieldFactory.createFromPattern([
      ['.', '.', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.'],
      ['R', 'R', 'R', '.', '.', '.'],
      ['G', 'G', 'B', '.', '.', '.'],
      ['G', 'B', 'B', '.', '.', '.']
    ]);
    
    const game = new GameTestDataBuilder()
      .withField(field)
      .withScore(0)
      .build();
    
    const gameService = new GameService(new InMemoryGameRepository());
    gameService.saveGame(game);
    
    // When: é€£é–ã‚’ç™ºç”Ÿã•ã›ã‚‹æ“ä½œ
    const redPuyo = Puyo.create(PuyoColor.RED, new Position(3, 2));
    const placePuyoCommand = new PlacePuyoCommand(redPuyo);
    const result = await gameService.handlePlayerInput(game.getId(), placePuyoCommand);
    
    // Then: é€£é–ãŒç™ºç”Ÿã—ã¦ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã‚‹
    const updatedGame = gameService.getGame(game.getId());
    expect(updatedGame.getScore().getCurrent()).toBeGreaterThan(0);
    expect(result.getEvents()).toContainEqual(
      expect.objectContaining({ type: 'ChainOccurredEvent' })
    );
  });
});
```

## ã‚³ãƒŸãƒƒãƒˆæˆ¦ç•¥

### TODOãƒ™ãƒ¼ã‚¹ã®ã‚³ãƒŸãƒƒãƒˆ

```plantuml
@startuml "ã‚³ãƒŸãƒƒãƒˆæˆ¦ç•¥"
start
:TODOé¸æŠ;
:Red-Green-Refactor ã‚µã‚¤ã‚¯ãƒ«å®Ÿè¡Œ;
:å“è³ªãƒã‚§ãƒƒã‚¯;
if (å“è³ªOK?) then (yes)
  :TODOå˜ä½ã§ã‚³ãƒŸãƒƒãƒˆ;
  :Angularã‚¹ã‚¿ã‚¤ãƒ«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä½œæˆ;
  note right
    feat: ã·ã‚ˆå›è»¢æ©Ÿèƒ½ã‚’å®Ÿè£…
    
    - Puyo ã‚¯ãƒ©ã‚¹ã«å›è»¢ãƒ­ã‚¸ãƒƒã‚¯è¿½åŠ 
    - è¡çªåˆ¤å®šã‚’è€ƒæ…®ã—ãŸå›è»¢å‡¦ç†
    - å˜ä½“ãƒ†ã‚¹ãƒˆè¿½åŠ ï¼ˆã‚«ãƒãƒ¬ãƒƒã‚¸95%ï¼‰
    
    ğŸ¤– Generated with [Claude Code](https://claude.ai/code)
    Co-Authored-By: Claude <noreply@anthropic.com>
  end note
else (no)
  :ä¿®æ­£;
  :ä¿®æ­£; --> :å“è³ªãƒã‚§ãƒƒã‚¯;
endif
if (æ¬¡ã®TODO?) then (yes)
  :æ¬¡ã®TODO; --> :TODOé¸æŠ;
else (no)
  stop
endif
@enduml
```

### ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¦ç´„

```markdown
<type>(<scope>): <subject>

<body>

<footer>
```

**Type:**
- `feat`: æ–°æ©Ÿèƒ½è¿½åŠ 
- `fix`: ãƒã‚°ä¿®æ­£  
- `refactor`: ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
- `test`: ãƒ†ã‚¹ãƒˆè¿½åŠ ãƒ»ä¿®æ­£
- `docs`: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°
- `style`: ã‚³ãƒ¼ãƒ‰æ•´å½¢
- `chore`: ãƒ“ãƒ«ãƒ‰ãƒ»è¨­å®šå¤‰æ›´

**Scope:**
- `domain`: ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤
- `app`: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
- `ui`: ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤
- `infra`: ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

### 1. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼

```typescript
// ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ã®å®šç¾©
export abstract class DomainError extends Error {
  abstract readonly code: string;
  abstract readonly severity: 'warning' | 'error' | 'critical';
}

export class InvalidPuyoPlacementError extends DomainError {
  readonly code = 'INVALID_PUYO_PLACEMENT';
  readonly severity = 'warning';
  
  constructor(position: Position, reason: string) {
    super(`Cannot place puyo at ${position}: ${reason}`);
  }
}

export class GameOverError extends DomainError {
  readonly code = 'GAME_OVER';
  readonly severity = 'error';
  
  constructor(finalScore: number) {
    super(`Game over with final score: ${finalScore}`);
  }
}

// ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã§ã®ä½¿ç”¨
export class Game {
  handleInput(command: InputCommand): DomainEvent[] {
    try {
      switch (command.type) {
        case 'MOVE_PUYO':
          return this.handleMovePuyo(command as MovePuyoCommand);
        case 'PLACE_PUYO':
          return this.handlePlacePuyo(command as PlacePuyoCommand);
        default:
          throw new InvalidCommandError(command.type);
      }
    } catch (error) {
      if (error instanceof DomainError) {
        return [new GameErrorEvent(this.id, error)];
      }
      throw error; // äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã¯å†ã‚¹ãƒ­ãƒ¼
    }
  }
  
  private handlePlacePuyo(command: PlacePuyoCommand): DomainEvent[] {
    const position = command.puyo.getPosition();
    
    if (!this.field.canPlacePuyoAt(position)) {
      throw new InvalidPuyoPlacementError(
        position, 
        'Position is already occupied'
      );
    }
    
    // æ­£å¸¸å‡¦ç†...
    return [new PuyoPlacedEvent(this.id, command.puyo)];
  }
}
```

### 2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤ã‚¨ãƒ©ãƒ¼å‡¦ç†

```typescript
export class GameService {
  async handlePlayerInput(
    gameId: GameId, 
    command: InputCommand
  ): Promise<GameResult> {
    try {
      const game = await this.gameRepository.findById(gameId);
      if (!game) {
        return GameResult.failure('Game not found', 'GAME_NOT_FOUND');
      }
      
      const events = game.handleInput(command);
      await this.gameRepository.save(game);
      
      // ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã«å¤‰æ›
      await this.eventBus.publishAll(events);
      
      return GameResult.success(events);
      
    } catch (error) {
      if (error instanceof DomainError) {
        return GameResult.failure(error.message, error.code);
      }
      
      // äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã¯ãƒ­ã‚°ã«è¨˜éŒ²ã—ã¦æ±ç”¨ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
      this.logger.error('Unexpected error in GameService', error);
      return GameResult.failure('Internal server error', 'INTERNAL_ERROR');
    }
  }
}

export class GameResult {
  private constructor(
    private readonly success: boolean,
    private readonly events: DomainEvent[] = [],
    private readonly errorMessage?: string,
    private readonly errorCode?: string
  ) {}
  
  static success(events: DomainEvent[]): GameResult {
    return new GameResult(true, events);
  }
  
  static failure(message: string, code: string): GameResult {
    return new GameResult(false, [], message, code);
  }
  
  isSuccess(): boolean { return this.success; }
  getEvents(): DomainEvent[] { return [...this.events]; }
  getErrorMessage(): string | undefined { return this.errorMessage; }
  getErrorCode(): string | undefined { return this.errorCode; }
}
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æˆ¦ç•¥

### 1. ãƒ¡ãƒ¢åŒ–ã¨Reactã®æœ€é©åŒ–

```typescript
// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ€é©åŒ–
export const GameBoard = React.memo<GameBoardProps>(({ 
  field, 
  currentPuyo, 
  onInput 
}) => {
  // é‡ã„è¨ˆç®—ã®ãƒ¡ãƒ¢åŒ–
  const fieldCells = useMemo(() => {
    return field.getCells().map((row, y) => 
      row.map((puyo, x) => ({
        key: `${x}-${y}`,
        puyo,
        position: new Position(x, y)
      }))
    );
  }, [field]);
  
  // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã®ãƒ¡ãƒ¢åŒ–
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    const command = mapKeyToCommand(event.key);
    if (command && onInput) {
      onInput(command);
    }
  }, [onInput]);
  
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
  
  return (
    <div className="game-board">
      {fieldCells.map(row => 
        row.map(({ key, puyo, position }) => (
          <PuyoCell key={key} puyo={puyo} position={position} />
        ))
      )}
    </div>
  );
});

// æ¯”è¼ƒé–¢æ•°ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
GameBoard.displayName = 'GameBoard';
```

### 2. ãƒãƒ³ãƒ‰ãƒ«æœ€é©åŒ–

```typescript
// å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã‚ˆã‚‹é…å»¶ãƒ­ãƒ¼ãƒ‰
const GameSettingsModal = lazy(() => import('./GameSettingsModal'));
const GameHistoryModal = lazy(() => import('./GameHistoryModal'));

export const GameContainer: React.FC = () => {
  const [showSettings, setShowSettings] = useState(false);
  
  return (
    <div>
      <GameBoard />
      
      <Suspense fallback={<div>Loading...</div>}>
        {showSettings && (
          <GameSettingsModal onClose={() => setShowSettings(false)} />
        )}
      </Suspense>
    </div>
  );
};
```

## ã¾ã¨ã‚

ã“ã®å®Ÿè£…æˆ¦ç•¥ã«ã‚ˆã‚Šä»¥ä¸‹ã‚’å®Ÿç¾ï¼š

1. **æ®µéšçš„é–‹ç™º**: ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸­å¿ƒé–‹ç™º
2. **å“è³ªä¿è¨¼**: TDDã‚µã‚¤ã‚¯ãƒ«ã¨åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆæˆ¦ç•¥
3. **ä¿å®ˆæ€§**: æ˜ç¢ºãªè²¬ä»»åˆ†é›¢ã¨ç–çµåˆè¨­è¨ˆ
4. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: Reactæœ€é©åŒ–ã¨ãƒãƒ³ãƒ‰ãƒ«åˆ†å‰²
5. **ã‚¨ãƒ©ãƒ¼å‡¦ç†**: å …ç‰¢ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ©Ÿæ§‹
6. **é–‹ç™ºåŠ¹ç‡**: TODOãƒ™ãƒ¼ã‚¹ã®é–‹ç™ºã¨ã‚³ãƒŸãƒƒãƒˆæˆ¦ç•¥

æ¬¡ã®Phase 3ï¼ˆé–‹ç™ºï¼‰ã§ã¯ã€ã“ã®æˆ¦ç•¥ã«åŸºã¥ã„ã¦å…·ä½“çš„ãªå®Ÿè£…ã‚’é€²ã‚ã¦ã„ãã¾ã™ã€‚