# アーキテクチャ設計

## 概要

ぷよぷよゲームシステムのアーキテクチャ設計について説明します。CLAUDE.local.mdの指針に基づき、ヘキサゴナルアーキテクチャ（ポートとアダプター）パターンを採用し、**中核の業務領域**として位置づけ、**ドメインモデル**を使用します。

## アーキテクチャ選定理由

```plantuml
@startuml
title アーキテクチャ選定フロー

start

if (業務領域のカテゴリー) then (中核の業務領域)
  if (金額を扱う/分析/監査記録が必要か?) then (いいえ)
    note right: ぷよぷよゲームは金額を扱わないが\n複雑なゲームロジックがある
    :ドメインモデル;
    :ピラミッド形のテスト;
    if (永続化モデルは複数か?) then (いいえ)
      note right: ローカルストレージのみ使用
      :ポートとアダプター;
      note right: **選択されたアーキテクチャ**
    else (はい)
      :CQRS;
    endif
  else (はい)
    :イベント履歴式ドメインモデル;
    :ピラミッド形のテスト;
    :CQRS;
  endif
else (補完、一般との連携)
  if (データ構造が複雑か?) then (いいえ)
    :トランザクションスクリプト;
    :逆ピラミッド形のテスト;
    if (永続化モデルは複数か?) then (いいえ)
      :レイヤードアーキテクチャ 3層;
    else (はい)
      :レイヤードアーキテクチャ 4層;
    endif
  else (はい)
    :アクティブレコード;
    :ダイヤモンド形のテスト;
    if (永続化モデルは複数か?) then (いいえ)
      :レイヤードアーキテクチャ 3層;
    else (はい)
      :レイヤードアーキテクチャ 4層;
    endif
  endif
endif

stop
@enduml
```

**選定理由:**

- ぷよぷよゲームは複雑なゲームロジック（連鎖、消去判定）を持つため**中核の業務領域**
- 金額を扱わないため**ドメインモデル**パターンが適切
- ローカルストレージのみの永続化のため**ポートとアダプター（ヘキサゴナルアーキテクチャ）**を採用

## アーキテクチャ全体図

```plantuml
@startuml "ヘキサゴナルアーキテクチャ"
!define DOMAIN_COLOR #FFE6E6
!define APP_COLOR #E6F3FF  
!define INFRA_COLOR #F0FFF0
!define UI_COLOR #FFF0F5

skinparam roundcorner 10

hexagon "ドメイン層" DOMAIN_COLOR {
  rectangle "Game" as Game
  rectangle "Field" as Field  
  rectangle "Puyo" as Puyo
  rectangle "Chain" as Chain
  rectangle "Score" as Score
}

rectangle "アプリケーション層" APP_COLOR {
  rectangle "GameService" as GameService
  rectangle "ScoreService" as ScoreService
  rectangle "InputService" as InputService
}

rectangle "プレゼンテーション層（左側アダプター）" UI_COLOR {
  rectangle "GameComponent" as GameComponent
  rectangle "GameBoardComponent" as GameBoardComponent
  rectangle "ScoreComponent" as ScoreComponent
  rectangle "InputHandler" as InputHandler
}

rectangle "インフラストラクチャ層（右側アダプター）" INFRA_COLOR {
  rectangle "LocalStorageAdapter" as Storage
  rectangle "AnimationService" as Animation
  rectangle "SoundService" as Sound
  rectangle "TimerService" as Timer
}

' ポートの定義
interface "GamePort" as GamePort
interface "ScorePort" as ScorePort
interface "StoragePort" as StoragePort
interface "AnimationPort" as AnimationPort
interface "SoundPort" as SoundPort
interface "TimerPort" as TimerPort

' 接続関係
GameComponent --> GameService
GameBoardComponent --> GameService
ScoreComponent --> ScoreService
InputHandler --> InputService

GameService --> GamePort
ScoreService --> ScorePort
GameService --> StoragePort
GameService --> AnimationPort
GameService --> SoundPort
GameService --> TimerPort

GamePort <-- Game
ScorePort <-- Score

StoragePort <-- Storage
AnimationPort <-- Animation
SoundPort <-- Sound  
TimerPort <-- Timer

Game --> Field
Game --> Puyo
Game --> Chain
Game --> Score

@enduml
```

## レイヤー詳細

### ドメイン層 (Domain Layer)

**責務:**

- ゲームの核となるビジネスロジックを実装
- ドメイン固有のルールと制約を管理
- 外部の技術的詳細から独立

**主要コンポーネント:**

```plantuml
@startuml "ドメインモデル"
class Game {
  -field: Field
  -currentPuyo: PuyoPair
  -nextPuyo: PuyoPair  
  -score: Score
  -state: GameState
  +start(): void
  +moveLeft(): boolean
  +moveRight(): boolean
  +rotate(): boolean
  +drop(): void
  +update(): void
  +isGameOver(): boolean
}

class Field {
  -grid: Puyo[][]
  -width: number = 6
  -height: number = 12
  +placePuyo(puyo: Puyo, x: number, y: number): boolean
  +removePuyo(x: number, y: number): Puyo | null
  +findConnectedPuyos(x: number, y: number): Puyo[]
  +applyGravity(): void
  +isEmpty(): boolean
}

class Puyo {
  -color: PuyoColor
  -x: number
  -y: number
  +getColor(): PuyoColor
  +getPosition(): Position
  +moveTo(x: number, y: number): void
}

class PuyoPair {
  -puyo1: Puyo
  -puyo2: Puyo
  -rotation: number
  +rotate(): void
  +getPuyos(): Puyo[]
  +getPositions(): Position[]
}

class Chain {
  -chainCount: number
  -erasedPuyos: Puyo[]
  +detectChains(field: Field): Chain[]
  +calculateScore(): number
  +getChainCount(): number
}

class Score {
  -current: number
  -highScore: number
  +add(points: number): void
  +getCurrentScore(): number
  +getHighScore(): number
  +isNewHighScore(): boolean
}

enum PuyoColor {
  RED
  GREEN
  BLUE
  YELLOW
  PURPLE
}

enum GameState {
  READY
  PLAYING
  PAUSED
  GAME_OVER
}

Game *-- Field
Game *-- PuyoPair
Game *-- Score
Field *-- Puyo
PuyoPair *-- Puyo
Chain *-- Puyo
@enduml
```

### アプリケーション層 (Application Layer)

**責務:**

- ユースケースの実行を調整
- ドメインオブジェクト間の連携を管理
- 外部システムとの統合を仲介

**主要サービス:**

```plantuml
@startuml "アプリケーション層"
interface GamePort {
  +startNewGame(): Game
  +updateGame(game: Game): Game
  +saveGame(game: Game): void
}

interface ScorePort {
  +saveScore(score: Score): void
  +loadHighScore(): number
}

interface StoragePort {
  +save(key: string, data: any): void
  +load(key: string): any
  +remove(key: string): void
}

class GameService {
  -gamePort: GamePort
  -storagePort: StoragePort
  -animationPort: AnimationPort
  -soundPort: SoundPort
  +startGame(): Game
  +handleInput(input: InputType, game: Game): Game
  +updateGameState(game: Game): Game
  +endGame(game: Game): void
}

class ScoreService {
  -scorePort: ScorePort
  -storagePort: StoragePort
  +updateScore(points: number): Score
  +getHighScore(): number
  +saveHighScore(score: number): void
}

class InputService {
  +processKeyboardInput(key: string): InputType
  +processTouchInput(touch: TouchEvent): InputType
  +validateInput(input: InputType, game: Game): boolean
}

GameService --> GamePort
GameService --> StoragePort
GameService --> AnimationPort
GameService --> SoundPort
ScoreService --> ScorePort
ScoreService --> StoragePort
@enduml
```

### プレゼンテーション層 (Presentation Layer)

**責務:**

- ユーザーインターフェースの描画
- ユーザー入力の受付と変換
- ゲーム状態の表示

**主要コンポーネント:**

```plantuml
@startuml "プレゼンテーション層"
class GameComponent {
  -gameService: GameService
  -game: Game
  +render(): void
  +handleKeyPress(event: KeyboardEvent): void
  +startGame(): void
  +pauseGame(): void
  +restartGame(): void
}

class GameBoardComponent {
  -canvas: HTMLCanvasElement
  -context: CanvasRenderingContext2D
  +renderField(field: Field): void
  +renderPuyo(puyo: Puyo): void
  +renderPuyoPair(puyoPair: PuyoPair): void
  +renderAnimation(animation: Animation): void
}

class ScoreComponent {
  -scoreService: ScoreService
  +renderScore(score: Score): void
  +renderHighScore(highScore: number): void
  +showScoreUpdate(points: number): void
}

class InputHandler {
  -inputService: InputService
  -gameComponent: GameComponent
  +bindKeyboardEvents(): void
  +bindTouchEvents(): void
  +handleInput(input: InputType): void
}

GameComponent --> GameService
GameBoardComponent --> GameBoardComponent
ScoreComponent --> ScoreService
InputHandler --> InputService
@enduml
```

### インフラストラクチャ層 (Infrastructure Layer)

**責務:**

- 技術的な詳細の実装
- 外部システムとの具体的な通信
- フレームワーク・ライブラリとの統合

**主要アダプター:**

```plantuml
@startuml "インフラストラクチャ層"
class LocalStorageAdapter {
  +save(key: string, data: any): void
  +load(key: string): any
  +remove(key: string): void
}

class AnimationService {
  -requestAnimationFrame: number
  +startAnimation(callback: Function): void
  +stopAnimation(): void
  +createPuyoFallAnimation(puyo: Puyo): Animation
  +createPuyoEraseAnimation(puyos: Puyo[]): Animation
  +createChainAnimation(chain: Chain): Animation
}

class SoundService {
  -audioContext: AudioContext
  -soundEffects: Map<string, AudioBuffer>
  +loadSounds(): Promise<void>
  +playPuyoDropSound(): void
  +playEraseSound(): void
  +playChainSound(chainCount: number): void
  +playBackgroundMusic(): void
  +setVolume(volume: number): void
}

class TimerService {
  -intervalId: number
  +startGameTimer(callback: Function, interval: number): void
  +stopGameTimer(): void
  +getCurrentTime(): number
}

LocalStorageAdapter .|> StoragePort
AnimationService .|> AnimationPort
SoundService .|> SoundPort
TimerService .|> TimerPort
@enduml
```

## 依存性の流れ

```plantuml
@startuml "依存性フロー"
left to right direction

package "プレゼンテーション層" {
  [UI Components]
}

package "アプリケーション層" {
  [Application Services]
  [Ports (Interfaces)]
}

package "ドメイン層" {
  [Domain Models]
  [Domain Services]
}

package "インフラストラクチャ層" {
  [Adapters]
  [External Libraries]
}

[UI Components] --> [Application Services]
[Application Services] --> [Ports (Interfaces)]
[Application Services] --> [Domain Models]
[Ports (Interfaces)] <|-- [Adapters]
[Domain Models] --> [Domain Services]

note right of [Domain Models] : 他の層に依存しない
note right of [Ports (Interfaces)] : 依存性逆転の原則
@enduml
```

**依存性のルール:**

1. **内側の層は外側の層に依存しない**
2. **外側の層は内側の層に依存する**
3. **ポート（インターフェース）により依存性を逆転**
4. **ドメイン層は完全に独立**

## テスト戦略とアーキテクチャ

ピラミッド形のテスト戦略を採用します：

```plantuml
@startuml "テストピラミッド"
!define UNIT_COLOR #90EE90
!define INTEGRATION_COLOR #FFD700
!define E2E_COLOR #FF6347

triangle "E2E Tests" E2E_COLOR
triangle "Integration Tests" INTEGRATION_COLOR  
triangle "Unit Tests" UNIT_COLOR

note right of "Unit Tests" : ドメインモデルを中心とした高速なテスト\n- Game, Field, Puyo, Chain, Score クラス\n- ビジネスロジックの詳細な検証
note right of "Integration Tests" : 層間の統合テスト\n- Service層とAdapter間の統合\n- ポートとアダプターの契約テスト
note right of "E2E Tests" : ユーザーシナリオテスト\n- ブラウザテストによる操作フロー確認\n- 主要ユースケースの検証

@enduml
```

## パフォーマンス考慮事項

### レンダリング最適化

```plantuml
@startuml "レンダリング最適化"
participant "InputHandler" as Input
participant "GameService" as Service
participant "GameBoardComponent" as Board
participant "AnimationService" as Animation

Input -> Service: handleInput()
Service -> Service: updateGameState()
Service -> Board: shouldUpdate()

alt 状態変更あり
  Board -> Board: renderDirtyRegions()
  Board -> Animation: queueAnimation()
else 状態変更なし
  Board -> Board: skipRender()
end

Animation -> Board: renderFrame()
@enduml
```

### メモリ管理

- **オブジェクトプール:**
  - ぷよオブジェクトの再利用
  - アニメーション効果の再利用

- **イベント処理の最適化:**
  - RAF (RequestAnimationFrame) の適切な利用
  - 不要なイベントリスナーのクリーンアップ

## 拡張可能性

### 新機能追加時の影響範囲

```plantuml
@startuml "機能拡張パターン"
package "既存機能" {
  [基本ゲームロジック]
}

package "新機能例: マルチプレイ" {
  [MultiplayerService] --> [GameService] : 拡張
  [NetworkAdapter] ..|> [NetworkPort] : 実装
  [MultiplayerComponent] --> [GameComponent] : 拡張
}

package "新機能例: AI対戦" {
  [AIService] --> [InputService] : 拡張
  [AIAdapter] ..|> [AIPort] : 実装
}

note right : 既存のドメインモデルは\n変更なしで新機能を追加可能
@enduml
```

## 技術的制約と前提

### ブラウザ環境での制約

- **Canvas API:** ゲーム描画のメイン手段
- **Web Audio API:** 音響効果の実装
- **LocalStorage:** データ永続化
- **RequestAnimationFrame:** アニメーション制御

### パフォーマンス目標

- **60FPS:** スムーズなゲーム体験
- **初回ロード時間:** 5秒以内
- **メモリ使用量:** 100MB以下
- **入力遅延:** 16ms以内

## セキュリティ考慮事項

### データ保護

- **ハイスコア改ざん防止:** クライアントサイド検証
- **不正入力防止:** 入力値のサニタイジング
- **XSS対策:** HTMLエスケープ処理

### プライバシー保護

- **個人情報なし:** ローカルストレージのみ使用
- **トラッキングなし:** 外部送信データなし

## まとめ

このアーキテクチャ設計により以下を実現：

1. **保守性:** 各層の責務が明確で変更に強い
2. **テスタビリティ:** ドメインロジックが独立してテスト可能
3. **拡張性:** ポートとアダプターで新機能追加が容易
4. **パフォーマンス:** 必要に応じた最適化が可能