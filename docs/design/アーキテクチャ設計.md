# アーキテクチャ設計

## 概要

ぷよぷよゲームアプリケーションは、レイヤードアーキテクチャを採用し、明確な責任分離と保守性の高い設計を実現します。テスト駆動開発（TDD）を採用し、各層が独立してテスト可能な構造とします。

## アーキテクチャ概要図

```plantuml
@startuml "アーキテクチャ概要"

skinparam linetype ortho
skinparam packageStyle rectangle

package "Presentation Layer" {
  [UI Components] as ui
  [Input Handlers] as input
  [Renderer] as render
}

package "Application Layer" {
  [Game Controller] as controller
  [Game Loop] as loop
  [State Manager] as state
}

package "Domain Layer" {
  [Game Logic] as game
  [Game Rules] as rules
  [Domain Services] as services
}

package "Infrastructure Layer" {
  [Canvas API] as canvas
  [Event System] as events
  [Timer/Animation] as timer
}

ui --> controller : "user actions"
input --> controller : "input events"
controller --> game : "game commands"
controller --> state : "state updates"
game --> rules : "rule validation"
game --> services : "domain operations"
render --> canvas : "drawing commands"
loop --> timer : "frame timing"
events --> input : "browser events"

@enduml
```

## レイヤー詳細

### 1. Presentation Layer（プレゼンテーション層）

ユーザーインターフェースと入力処理を担当

```plantuml
@startuml "プレゼンテーション層"

package "Presentation Layer" {
  
  class InputManager {
    -keyState: Map<string, boolean>
    -touchState: TouchState
    +onKeyDown(event: KeyboardEvent): void
    +onKeyUp(event: KeyboardEvent): void
    +onTouchStart(event: TouchEvent): void
    +onTouchMove(event: TouchEvent): void
    +onTouchEnd(event: TouchEvent): void
    +getInputCommand(): InputCommand | null
  }
  
  class Renderer {
    -canvas: HTMLCanvasElement
    -context: CanvasRenderingContext2D
    -theme: RenderTheme
    +render(gameState: GameState): void
    +renderField(field: Field): void
    +renderPuyo(puyo: Puyo, position: Position): void
    +renderUI(score: number, chainCount: number): void
    +renderGameOver(finalScore: number): void
  }
  
  class UIManager {
    -startButton: HTMLButtonElement
    -resetButton: HTMLButtonElement
    -scoreDisplay: HTMLElement
    +initialize(): void
    +updateScore(score: number): void
    +showGameOver(score: number): void
    +hideGameOver(): void
  }
  
  enum InputCommand {
    MOVE_LEFT
    MOVE_RIGHT
    MOVE_DOWN
    ROTATE_CW
    ROTATE_CCW
    SOFT_DROP
    HARD_DROP
    RESET
  }
}

@enduml
```

**責任**:
- ユーザー入力の収集と変換
- ゲーム状態の視覚的表現
- UI要素の管理

### 2. Application Layer（アプリケーション層）

ゲームフローとユースケースの制御を担当

```plantuml
@startuml "アプリケーション層"

package "Application Layer" {
  
  class GameController {
    -game: Game
    -inputManager: InputManager
    -renderer: Renderer
    -gameLoop: GameLoop
    +initialize(): void
    +startNewGame(): void
    +processInput(): void
    +update(deltaTime: number): void
    +render(): void
    +handleGameOver(): void
  }
  
  class GameLoop {
    -isRunning: boolean
    -lastFrameTime: number
    -targetFPS: number = 60
    +start(): void
    +stop(): void
    +update(callback: (deltaTime: number) => void): void
  }
  
  class StateManager {
    -currentState: GameState
    -stateHistory: GameState[]
    +setState(newState: GameState): void
    +getState(): GameState
    +canTransition(toState: GameState): boolean
  }
  
  enum GameState {
    MENU
    PLAYING
    PAUSED
    CHAIN_ANIMATION
    GAME_OVER
  }
}

@enduml
```

**責任**:
- ゲームフローの制御
- 入力とドメインロジックの仲介
- 状態遷移の管理
- フレームレートの制御

### 3. Domain Layer（ドメイン層）

ゲームのビジネスロジックとルールを担当

```plantuml
@startuml "ドメイン層"

package "Domain Layer" {
  
  class Game {
    -field: Field
    -currentPuyo: PuyoPair | null
    -nextPuyo: PuyoPair
    -score: Score
    -chainProcessor: ChainProcessor
    +startNewGame(): void
    +movePuyo(direction: Direction): boolean
    +rotatePuyo(rotation: RotationDirection): boolean
    +dropPuyo(): void
    +update(deltaTime: number): void
    +isGameOver(): boolean
  }
  
  class Field {
    -cells: (Puyo | null)[][]
    -width: number = 6
    -height: number = 13
    +getPuyo(x: number, y: number): Puyo | null
    +setPuyo(x: number, y: number, puyo: Puyo | null): void
    +isValidPosition(x: number, y: number): boolean
    +findConnectedPuyos(x: number, y: number, color: PuyoColor): Position[]
    +applyGravity(): boolean
    +clear(): void
  }
  
  class PuyoPair {
    -mainPuyo: Puyo
    -subPuyo: Puyo
    -position: Position
    -rotation: Rotation
    +move(direction: Direction, field: Field): boolean
    +rotate(direction: RotationDirection, field: Field): boolean
    +drop(field: Field): boolean
    +getPositions(): [Position, Position]
  }
  
  class ChainProcessor {
    +processChains(field: Field): ChainResult
    +findErasableGroups(field: Field): PuyoGroup[]
    +eraseGroups(field: Field, groups: PuyoGroup[]): number
    +calculateChainBonus(chainCount: number): number
  }
  
  class GameRules {
    +FIELD_WIDTH: number = 6
    +FIELD_HEIGHT: number = 13
    +MIN_ERASE_COUNT: number = 4
    +ZENKESHI_BONUS: number = 2000
    +validateMove(puyo: PuyoPair, direction: Direction, field: Field): boolean
    +validateRotation(puyo: PuyoPair, rotation: RotationDirection, field: Field): boolean
    +calculateScore(erasedCount: number, chainCount: number): number
  }
}

@enduml
```

**責任**:
- ゲームルールの実装
- ドメインオブジェクトの管理
- ビジネスロジックの実行
- 連鎖処理とスコア計算

### 4. Infrastructure Layer（インフラストラクチャ層）

外部システムとの連携と技術的詳細を担当

```plantuml
@startuml "インフラストラクチャ層"

package "Infrastructure Layer" {
  
  class CanvasRenderer {
    -canvas: HTMLCanvasElement
    -context: CanvasRenderingContext2D
    +drawRect(x: number, y: number, width: number, height: number, color: string): void
    +drawCircle(x: number, y: number, radius: number, color: string): void
    +drawText(text: string, x: number, y: number, font: string): void
    +clear(): void
  }
  
  class EventManager {
    -eventListeners: Map<string, Function[]>
    +addEventListener(eventType: string, callback: Function): void
    +removeEventListener(eventType: string, callback: Function): void
    +dispatchEvent(eventType: string, data: any): void
  }
  
  class AnimationEngine {
    -animations: Animation[]
    +addAnimation(animation: Animation): void
    +removeAnimation(animation: Animation): void
    +update(deltaTime: number): void
  }
  
  class AudioManager {
    -audioContext: AudioContext
    -sounds: Map<string, AudioBuffer>
    +loadSound(name: string, url: string): Promise<void>
    +playSound(name: string): void
    +setVolume(volume: number): void
  }
}

@enduml
```

**責任**:
- Canvas APIの抽象化
- イベントシステムの管理
- アニメーション処理
- 音声管理（オプション）

## データフロー

```plantuml
@startuml "データフロー図"

skinparam linetype ortho

actor User
participant "InputManager" as input
participant "GameController" as controller
participant "Game" as game
participant "Field" as field
participant "ChainProcessor" as chain
participant "Renderer" as render

User -> input : キー入力/タッチ
input -> controller : InputCommand
controller -> game : move/rotate/drop
game -> field : 位置検証/更新
field -> game : 結果返却
game -> chain : 連鎖処理
chain -> field : ぷよ消去/落下
chain -> game : 連鎖結果
game -> controller : ゲーム状態更新
controller -> render : 描画要求
render -> User : 画面更新

@enduml
```

## コンポーネント間の依存関係

```plantuml
@startuml "依存関係図"

skinparam linetype ortho

package "Presentation" {
  [InputManager]
  [Renderer]
  [UIManager]
}

package "Application" {
  [GameController]
  [GameLoop]
  [StateManager]
}

package "Domain" {
  [Game]
  [Field]
  [PuyoPair]
  [ChainProcessor]
  [GameRules]
}

package "Infrastructure" {
  [CanvasRenderer]
  [EventManager]
  [AnimationEngine]
}

[GameController] --> [Game]
[GameController] --> [InputManager]  
[GameController] --> [Renderer]
[GameController] --> [StateManager]
[GameController] --> [GameLoop]

[Game] --> [Field]
[Game] --> [PuyoPair]
[Game] --> [ChainProcessor]
[Game] --> [GameRules]

[Renderer] --> [CanvasRenderer]
[GameController] --> [EventManager]
[Renderer] --> [AnimationEngine]

@enduml
```

## 設計原則

### 1. 関心の分離（Separation of Concerns）
- 各層は明確な責任を持つ
- プレゼンテーション、アプリケーション、ドメイン、インフラを分離
- テスト可能性を重視

### 2. 依存関係逆転の原則（Dependency Inversion Principle）
- 上位レイヤーは下位レイヤーに依存しない
- インターフェースを通じた疎結合
- 外部システムへの依存を最小化

### 3. 単一責任の原則（Single Responsibility Principle）
- 各クラスは一つの責任のみを持つ
- 変更理由は一つのみ
- 高い凝集度を保つ

### 4. テスト駆動設計
- テスタブルな設計
- モックとスタブの活用
- 包括的なテストカバレッジ

## パフォーマンス考慮事項

### レンダリング最適化
- 差分レンダリング（変更された部分のみ描画）
- レイヤー分離による効率的な描画
- フレームレート制御（60FPS）

### メモリ管理
- オブジェクトプールの活用
- 不要なオブジェクトの適切な解放
- ガベージコレクション負荷の軽減

### 計算最適化
- 連鎖処理の効率化
- 衝突判定の最適化
- キャッシュの活用

## セキュリティ考慮事項

### 入力検証
- ユーザー入力の適切な検証
- 不正な値の除外
- 型安全性の確保

### データ保護
- スコアデータの整合性
- 改ざん防止
- ローカルストレージの適切な使用

## 拡張性

### 新機能追加
- プラグイン機構の検討
- 設定システムの実装
- マルチプレイヤー対応の余地

### プラットフォーム対応
- レスポンシブデザイン
- モバイル最適化
- PWA対応の検討