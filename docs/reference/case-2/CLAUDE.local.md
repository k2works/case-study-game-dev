# CLAUDE.local.md

```plantuml
@startmindmap

* ソフトウェア
** 要件
*** Phase 1
** 開発
*** Phase 3
** 運用
*** 構築
**** Phase 2
**** Phase 4
*** 配置
**** Phase 2
**** Phase 4


@endmindmap
```

## ソフトウェアライフサイクル

```plantuml
@startuml
[*] --> 要件
要件 --> 開発
要件 -right-> 運用
運用 -left-> 要件
開発 -left-> 要件
開発 --> 運用
運用 --> 開発
運用 --> 配置
運用 -up-> 構築
構築 --> 配置
運用 ---> [*]

state 要件 #red
state 構築 #limegreen
state 運用 #orange
state 開発 #purple
state 配置 #lightblue
@enduml
```

## 開発サイクル

```plantuml
@startuml

[*] --> リリース

state リリース {
  満足条件1: （ユーザーストーリー、予算、スケジュール)
  満足条件1 -->リリースプランニング
  リリースプランニング --> 満足条件1 
}

state イテレーション {
  リリースプランニング --> 満足条件2
  満足条件2: （ユーザーストーリー、予算、スケジュール)
  満足条件2 --> イテレーションプランニング
  イテレーションプランニング --> 満足条件2
  イテレーションプランニング --> 開発
  開発 --> フィーチャが追加された状態
  フィーチャが追加された状態 --> 満足条件2 : フィードバック
  フィーチャが追加された状態 --> 満足条件1 : フィードバック
}

リリース --> [*]

@enduml
```

## 開発フロー

```plantuml
@startuml

[*] --> イテレーション計画
イテレーション計画 --> ユーザーストーリー作成
ユーザーストーリー作成 --> ユースケース作成
ユースケース作成 --> データモデル設計
アーキテクチャ設計 --> コーディングとテスト
コーディングとテスト --> アーキテクチャ設計
データモデル設計 --> コーディングとテスト
コーディングとテスト --> データモデル設計
ドメインモデル設計 --> コーディングとテスト
コーディングとテスト --> ドメインモデル設計
コーディングとテスト --> ユーザーインターフェース設計
ユーザーインターフェース設計 --> コーディングとテスト
コーディングとテスト --> ユースケース作成
コーディングとテスト --> イテレーションレビュー
イテレーションレビュー --> イテレーション計画
イテレーションレビュー --> [*]

@enduml
```

## Phase 1 要件

CLAUDE.mdをセットアップする
@docs/requirements/要件.md を参照して、アプリケーションの要件を確認します。
要件に合わせたアーキテクチャや技術スタックを選定し、開発の進め方を計画します。
要件定義は以下の内容を含みます：
- ユーザーストーリー
- ユースケース
- データモデル
- アーキテクチャ設計
- ドメインモデル設計
- ユーザーインターフェース設計
- テスト戦略
- セキュリティ要件
- パフォーマンス要件
- アクセシビリティ要件
- メンテナンス性要件
- 拡張性要件
- ドキュメント要件
- 運用要件
- リリース計画
- イテレーション計画
- フィードバックループ
- リリースプランニング
要件定義は @docs/requirements/ディレクトリに記録します。
アーキテクチャや技術スタックの選定にあたっての決定事項は @docs/adr/ディレクトリに記録します。
 mkdocs.yml の navigation を更新して、ドキュメントを生成できるようにします。
ここでは計画に集中します。

```plantuml
@startuml "Phase 1 要件フェーズ"
start

:CLAUDE.mdをセットアップ;

:@docs/requirements/要件.md を参照;

:アプリケーションの要件を確認;

partition "要件定義作業" {
  :ユーザーストーリー作成;
  :ユースケース定義;
  :データモデル設計;
  :アーキテクチャ設計;
  :ドメインモデル設計;
  :ユーザーインターフェース設計;
  :テスト戦略策定;
  :セキュリティ要件定義;
  :パフォーマンス要件定義;
  :アクセシビリティ要件定義;
  :メンテナンス性要件定義;
  :拡張性要件定義;
  :ドキュメント要件定義;
  :運用要件定義;
  :リリース計画策定;
  :イテレーション計画策定;
  :フィードバックループ設計;
  :リリースプランニング;
}

:要件定義を@docs/requirements/ディレクトリに記録;

:技術スタック選定;

:アーキテクチャ決定事項を@docs/adr/ディレクトリに記録;

:mkdocs.yml の navigation を更新;

:ドキュメント生成確認;

stop

note 
  このフェーズでは
  計画に集中する
end note

note
  全ての要件定義を
  構造化して記録
end note

note 
  技術選定の理由と
  決定プロセスを記録
end note

@enduml
```

## Phase 2 構築・配置

@docs/reference/テスト駆動開発から始めるTypeScript入門2.md を参考に、アプリケーションの構築を行います。
アプリケーションはapp/ディレクトリ直下に作成します。
GitHub Actionsを使用して、アプリケーションのビルドとテストを自動化します。
最後にプロジェクトのREADMEを更新し、アプリケーションのセットアップ方法や使用方法を明確にします。
GitHub Actionsの動作確認は `act` を使用してローカルで行います。
アプリケーションは `vercel` にデプロイします。
appディレクトリにREADMEを作成し、アプリケーションの概要と使い方をまとめます。@docs/template/README.md を参考にします。
勝手に次のイテレーションに着手しないこと。 イテレーションの着手はPhase 3で行います。
ダイアグラムはplantumlを使用して作成します。
docsの各index.mdを更新して、アプリケーションの構築と配置に関する情報をまとめます。
mkdocs.yml の navigation を更新して、ドキュメントを生成できるようにします。

```plantuml
@startuml "Phase 2 構築・配置フェーズ"
start

:@docs/reference/テスト駆動開発から始めるTypeScript入門2.md を参考;

:app/ディレクトリ直下にアプリケーション作成;

partition "構築作業" {
  :プロジェクトセットアップ;
  :TypeScript環境構築;
  :テスト環境構築;
  :ビルド環境構築;
}

partition "CI/CD構築" {
  :GitHub Actions設定;
  :ビルド自動化;
  :テスト自動化;
  :`act`でローカル動作確認;
}

partition "デプロイ設定" {
  :Vercelデプロイ設定;
  :デプロイ動作確認;
}

partition "ドキュメント作成" {
  :app/README.md作成;
  :@docs/template/README.md を参考;
  :プロジェクトREADME更新;
  :セットアップ方法記載;
  :使用方法記載;
}

partition "ドキュメント整理" {
  :PlantUMLダイアグラム作成;
  :docs/各index.md更新;
  :構築・配置情報まとめ;
  :mkdocs.yml navigation更新;
}

:ドキュメント生成確認;

stop

note
  Phase 3で開発を開始
  勝手に次イテレーションに
  着手しない
end note

note 
  アプリケーションの
  基盤構築に集中
end note

note
  本番環境への
  配置準備
end note
@enduml
```

## Phase 3 開発

**CLAUDE.mdのコーディングとテストのフローに厳密に従うこと**
**次のイテレーションに進む前に必ず前回のイテレーションのふりかえりを行うこと**
**勝手に次のイテレーションに着手しないこと**
**ユーザーによる受け入れを確認するまで勝手にコミットしない**
**コミットの前に必ず実施すること**
- コードの整形（`npm run format:check`）
- リント（`npm run lint`）
- ビルド（`npm run build`）
- テスト（`npm run test`）
- エラーが出た場合は修正して再度実行
- READMEの更新（必要に応じて）
Phase 1で立てた計画に従い、@docs/requirements のイテレーションごとのTODOを基にアプリケーションを開発します。
@CLAUDE.md のコーディングとテストフローに従い、TODO単位でコミットします。
テスト駆動開発の手法に従い、アプリケーションの機能を段階的に実装します。
具体的な実装は以下を参考にします：
- @docs/reference/テスト駆動開発から始めるTypeScript入門1.md

次のイテレーションの機能を実装する前に、前回のイテレーションのふりかえりを行い、@docs/requirements.md の内容を更新します。
各イテレーションの作業は以下の手順で進めます：
- イテレーションのTODOを確認
- 必要なテストケースを作成
- テストを実行し、失敗することを確認
- 実装を行い、テストを通過させる
- コードの整形とリントとビルドを行い、問題がないことを確認
- 必要に応じてREADMEを更新
- コミットメッセージを作成し、コミットする

次のイテレーションの作業を開始する前に以下の手順を実施します：
- @docs/requirements.md を確認し、次のイテレーションのTODOを把握
- 受け入れ基準を確認し、次のイテレーションの目標を明確にする

作業を再開する場合は以下の手順で行います：
- @docs/requirements.md を確認し、前回のイテレーションの内容を把握
- 前回のイテレーションのコミットを確認し、変更点を把握
- 必要に応じて前回のイテレーションのコードを修正
- 次のイテレーションのTODOを確認し、作業を開始

イテレーション完了後に受け入れを行います。


受け入れは以下の手順で行います：
- イテレーションの成果物を確認
- テストケースを実行し、全てのテストが通過すること
- @docs/requirements/要件定義.md の対象イテレーションの受け入れ基準を確認
- コードのレビューを行い、以下の点を確認
- コードが要件を満たしていること
- コードが読みやすく、理解しやすいこと
- コードが適切にコメントされていること
- コードが適切にテストされていること
- コードが適切にドキュメント化されていること
- コードが適切に整形されていること
- コードが適切にリントされていること
- コードが適切にビルドされていること
- コードが適切にデプロイされていること
- コードが適切にバージョン管理されていること
- コードが適切にセキュリティ対策がされていること
- コードが適切にパフォーマンス対策がされていること
- コードが適切にアクセシビリティ対策がされていること
- コードの整形、リント、ビルドが問題ないことを確認
- READMEが最新の状態であることを確認
- 問題がなければ受け入れを行い、ふりかえりを実施する


テストの記述には以下の手順を参考にします：
- @docs/reference/テスト駆動開発から始めるTypeScript入門1.md
- 3A(Act - Arrange - Assert)の手法に従い、テストケースを記述します
- まずハッピーパスのテストケースを記述し、実装を行います
- 次にエッジケースや異常系のテストケースを記述し、実装を行います
- テストケースは日本語で記述し、可読性を重視します
- テストケースの命名は、テストの内容を明確に表現するようにします
- テストケースのコメントは、テストの意図や目的を明確にするために記述します

ドキュメントを更新する際は、以下の手順で行います：
- @docs/requirements.md を確認し、必要なドキュメントを更新
- npm run journal を実行し、ドキュメントの更新内容を確認
- README.md を更新し、アプリケーションの使用方法やセットアップ方法を明確にする
- 必要に応じて、@docs/reference/ディレクトリ内のドキュメントを更新
- ドキュメントの更新は、アプリケーションの機能追加や変更に伴い、随時行います
- ドキュメントの更新は、アプリケーションのバージョンアップに伴い、随時行います
- ドキュメントの更新は、アプリケーションのリリースに伴い、随時行います
- ドキュメントの更新は、アプリケーションのメンテナンスに伴い、随時行います

コミットは以下のルールに従います：
- 日本語で
- 各TODO単位でコミットする
    - @docs/reference/テスト駆動開発から始めるTypeScript入門1.md のコミット粒度を参考にする
    - コミットの前に `npm run test` を実行してテストがすべて通ることを確認する
    - コミットの前に `npm run lint` を実行してコードが整形されていることを確認する
    - コミットの前に `npm run format` を実行してコードが整形されていることを確認する
    - コミットの前に `npm run build` を実行してビルドが成功することを確認する
    - コミットメッセージはAngularのコミットメッセージの書き方を参考にする
        - feat: 新機能の追加
        - fix: バグ修正
        - docs: ドキュメントの変更
        - style: フォーマットやセミコロンの追加など、コードの動作に影響しない変更
        - refactor: リファクタリング（バグ修正や機能追加ではない）
        - test: テストコードの追加や修正
        - chore: ビルドプロセスや補助ツールの変更

```plantuml
@startuml "Phase 3 開発フェーズ"
start

:Phase 1で立てた計画を確認;
:@docs/requirements のイテレーションごとのTODOを確認;

partition "イテレーション開始" {
  :前回のイテレーションのふりかえり実施;
  :@docs/requirements.md の内容を更新;
  :次のイテレーションのTODOを把握;
  :受け入れ基準を確認;
  :次のイテレーションの目標を明確化;
}

partition "TDD実装サイクル" {
  :TODOリスト確認;
  :失敗テスト作成 (Red);
  :最小実装 (Green);
  :リファクタリング (Refactor);
  
  partition "品質チェック" {
    :コードの整形 (npm run format:check);
    :リント (npm run lint);
    :ビルド (npm run build);
    :テスト (npm run test);
    if (エラーあり?) then (yes)
      :修正;
      :修正; --> :コードの整形 (npm run format:check);
    else (no)
    endif
  }
  
  :必要に応じてREADME更新;
  :Angularスタイルのコミットメッセージ作成;
  :TODO単位でコミット;
}

if (イテレーション完了?) then (yes)
  partition "受け入れ処理" {
    :イテレーションの成果物を確認;
    :全テストの実行と確認;
    :要件定義の受け入れ基準確認;
    
    partition "コードレビュー" {
      :要件満足度確認;
      :コードの可読性確認;
      :適切なコメント確認;
      :テスト網羅性確認;
      :ドキュメント化確認;
      :セキュリティ対策確認;
      :パフォーマンス対策確認;
      :アクセシビリティ対策確認;
    }
    
    :README最新状態確認;
    if (受け入れOK?) then (yes)
      :ふりかえり実施;
      :次のイテレーションへ;
    else (no)
      :修正対応;
      :修正対応; --> :イテレーションの成果物を確認;
    endif
  }
else (no)
  :次のTODO;
endif

:次のTODO; --> :TODOリスト確認;

stop

note 
  CLAUDE.mdのコーディングと
  テストフローに厳密に従う
end note

note
  勝手に次のイテレーションに
  着手しない
end note

note 
  ユーザーによる受け入れを
  確認するまで勝手に
  コミットしない
end note

note 
  3A手法に従い
  日本語でテスト記述
end note
@enduml
```


## Phase 4 運用

### 包括的ドキュメントを作成する

`npm run journal` を実行して、journalを生成する
@docs/journal からアプリケーションをどのように作ったか学習する
@docs/journal に index.md を作成する
ダイアグラムにはplantumlを使用する
- @docs/development/アーキテクチャ.md を作成してアプリケーションのアーキテクチャをまとめる
- @docs/development/設計.md を作成してアプリケーションの設計をまとめる
- @docs/development/実装.md を作成してアプリケーションの実装をまとめる
- mkdocs.yml を更新してドキュメントを生成できるようにする
- docs/index.md も構成に合わせて更新する
- app/README.md を更新してアプリケーションの概要と使い方をまとめる
- README.md のフォーマットは @docs/template/README.md を参考にする


最後に次回同様の手順を再現できるようにしたいため replay.md を作成する

### アプリケーション評価レポートの作成

@docs/journal と @app の内容を基に、アプリケーションの評価レポートを作成します。
評価レポートには以下の内容を含めます：
- アプリケーション開発リードタイム
- アプリケーションの品質評価
  - テストカバレッジ
  - コードの複雑度(Cyclomatic Complexity ESLintの complexityルールを使用)
- アプリケーションのパフォーマンス評価
- アプリケーションのセキュリティ評価
- アプリケーションのアクセシビリティ評価
- アプリケーションのユーザビリティ評価
- アプリケーションのメンテナンス性評価
- アプリケーションの拡張性評価
- アプリケーションのドキュメント評価
- mermaid.jsのパイチャートを使用して、各評価項目の結果を可視化します

結果はdocs/report/ディレクトリに保存します。

```plantuml
@startuml "Phase 4 運用フェーズ"
start

partition "包括的ドキュメント作成" {
  :`npm run journal` を実行;
  :journalを生成;
  :@docs/journal からアプリケーション作成方法を学習;
  :@docs/journal/index.md 作成;
  
  partition "開発ドキュメント作成" {
    :@docs/development/アーキテクチャ.md 作成;
    :@docs/development/設計.md 作成;
    :@docs/development/実装.md 作成;
    :PlantUMLダイアグラム追加;
  }
  
  partition "ドキュメント構成更新" {
    :mkdocs.yml navigation更新;
    :docs/index.md を構成に合わせて更新;
    :app/README.md を更新;
    :@docs/template/README.md を参考;
  }
  
  :replay.md 作成;
}

partition "アプリケーション評価レポート作成" {
  :@docs/journal と @app の内容を分析;
  
  partition "評価項目測定" {
    :アプリケーション開発リードタイム測定;
    :テストカバレッジ測定;
    :コードの複雑度測定 (ESLint complexity);
    :パフォーマンス評価;
    :セキュリティ評価;
    :アクセシビリティ評価;
    :ユーザビリティ評価;
    :メンテナンス性評価;
    :拡張性評価;
    :ドキュメント評価;
  }
  
  :mermaid.jsパイチャートで可視化;
  :docs/report/ディレクトリに保存;
}

stop

note 
  運用フェーズでは
  ドキュメント化と
  評価に集中
end note

note
  次回同様の手順を
  再現できるように
  記録する
end note

note 
  各評価項目の結果を
  視覚的に表現
end note
@enduml
```