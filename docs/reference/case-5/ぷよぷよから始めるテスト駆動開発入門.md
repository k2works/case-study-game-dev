# ぷよぷよから始めるテスト駆動開発入門

## はじめに

みなさん、こんにちは！今日は私と一緒にテスト駆動開発（TDD）を使って、ぷよぷよゲームを作っていきましょう。さて、プログラミングの旅に出る前に、皆さんは「テスト駆動開発」について聞いたことがありますか？もしかしたら「テストって、コードを書いた後にするものじゃないの？」と思われるかもしれませんね。

> テストを書きながら開発することによって、設計が良い方向に変わり、コードが改善され続け、それによって自分自身が開発に前向きになること、それがテスト駆動開発の目指すゴールです。
> 
> — Kent Beck 『テスト駆動開発』 付録C　訳者解説：テスト駆動開発の現在

この記事では、私たちが一緒にぷよぷよゲームを実装しながら、テスト駆動開発の基本的な流れと考え方を学んでいきます。まるでモブプログラミングのセッションのように、あなたと私が一緒に考え、コードを書き、改善していく過程を体験しましょう。「でも、ぷよぷよって結構複雑なゲームじゃないの？」と思われるかもしれませんが、心配いりません。各章では、ユーザーストーリーに基づいた機能を、テスト、実装、解説の順に少しずつ進めていきますよ。一歩一歩、着実に進んでいきましょう！

### テスト駆動開発のサイクル

さて、テスト駆動開発では、どのように進めていけばいいのでしょうか？「テストを書いてから実装する」というのは分かりましたが、具体的にはどんな手順で進めるのでしょうか？

私がいつも実践しているのは、以下の3つのステップを繰り返すサイクルです。皆さんも一緒にやってみましょう：

1. **Red（赤）**: まず失敗するテストを書きます。「え？わざと失敗するテストを？」と思われるかもしれませんが、これには重要な意味があるんです。これから実装する機能が何をすべきかを明確にするためなんですよ。
2. **Green（緑）**: 次に、テストが通るように、最小限のコードを実装します。この段階では、きれいなコードよりも「とにかく動くこと」を優先します。「最小限」というのがポイントです。必要以上のことはしないようにしましょう。
3. **Refactor（リファクタリング）**: 最後に、コードの品質を改善します。テストが通ることを確認しながら、重複を取り除いたり、わかりやすい名前をつけたりします。「動くけど汚いコード」から「動いてきれいなコード」へと進化させるんです。

> レッド・グリーン・リファクタリング。それがTDDのマントラだ。
> 
> — Kent Beck 『テスト駆動開発』

このサイクルを「Red-Green-Refactor」サイクルと呼びます。「赤・緑・リファクタリング」のリズムを刻むように、このサイクルを繰り返していくんです。これによって、少しずつ機能を追加し、コードの品質を高めていきましょう。皆さんも一緒にこのリズムを体感してみてください！

```plantuml
@startuml
[*] --> コーディングとテスト
コーディングとテスト --> TODO : TODOリストを作成
TODO --> Red : テストを書く
Red --> Green : 最小限の実装
Green --> Refactor : リファクタリング
Refactor --> Red : 次のテストを書く
Red : テストに失敗
Green : テストに通る最小限の実装
Refactor : コードの重複を除去してリファクタリング
Refactor --> TODO : リファクタリングが完了したらTODOリストに戻る
TODO --> コーディングとテスト : TODOリストが空になるまで繰り返す
コーディングとテスト --> イテレーションレビュー
@enduml
```

### 開発環境

さて、実際にコードを書く前に、私たちが使用する開発環境について少しお話ししておきましょう。皆さんは「道具選びは仕事の半分」という言葉を聞いたことがありますか？プログラミングでも同じことが言えるんです。

> 道具はあなたの能力を増幅します。道具のできが優れており、簡単に使いこなせるようになっていれば、より生産的になれるのです。
> 
> — 達人プログラマー 熟達に向けたあなたの旅（第2版）

「どんなツールを使えばいいの？」と思われるかもしれませんね。今回のプロジェクトでは、以下のツールを使用していきます：

- **言語**: TypeScript — 「JavaScriptだけじゃダメなの？」と思われるかもしれませんが、TypeScriptは型を追加することで、大規模な開発でもバグを減らしやすくなるんです。
- **ビルドツール**: Vite — 開発中のコード変更をリアルタイムで反映してくれる高速な開発サーバーです。「待ち時間が少ないと開発が楽しくなりますよね！」
- **テストフレームワーク**: Vitest — Viteと統合された高速なテストランナーです。テスト駆動開発には欠かせないツールですね。
- **タスクランナー**: Gulp — 「同じ作業の繰り返しって退屈じゃないですか？」そんな反復的なタスクを自動化してくれます。
- **バージョン管理**: Git — コードの変更履歴を追跡し、「あれ？昨日までちゃんと動いてたのに...」というときに過去の状態に戻れる魔法のツールです。

これらのツールを使って、テスト駆動開発の流れに沿ってぷよぷよゲームを実装していきましょう。「環境構築って難しそう...」と心配される方もいるかもしれませんが手順に従って進めればそんなに難しいことではありません。詳細はイテレーション0: 環境の構築で解説します。

## 要件

### ユーザーストーリー

さて、実際にコードを書き始める前に、少し立ち止まって考えてみましょう。「何を作るのか？」という基本的な問いかけです。私たちが作るぷよぷよゲームは、どのような機能を持つべきでしょうか？

アジャイル開発では、この「何を作るのか？」という問いに対して、「ユーザーストーリー」という形で答えを出します。皆さんは「ユーザーストーリー」という言葉を聞いたことがありますか？

> ユーザーストーリーは、ソフトウェア要求を表現するための軽量な手法である。ユーザーストーリーは、システムについてユーザーまたは顧客の視点からフィーチャの概要を記述したものだ。
> ユーザーストーリーには形式が定められておらず、標準的な記法もない。とはいえ、次のような形式でストーリーを考えてみると便利である。「＜ユーザーの種類＞として、＜機能や性能＞がほしい。それは＜ビジネス価値＞のためだ」という形のテンプレートに従うと、
> たとえば次のようなストーリーを書ける。「本の購入者として、ＩＳＢＮで本を検索したい。それは探している本をすばやく見つけるためだ」 
> 
> — Mike Cohn 『アジャイルな見積と計画づくり』

つまり、「プレイヤーとして、〇〇ができる（〇〇したいから）」という形式で機能を表現するんです。これによって、「誰のため」の「どんな機能」を「なぜ」作るのかが明確になります。素晴らしいですよね！

では、私たちのぷよぷよゲームでは、どんなユーザーストーリーが考えられるでしょうか？一緒に考えてみましょう：

- プレイヤーとして、新しいゲームを開始できる（ゲームの基本機能として必要ですよね！）
- プレイヤーとして、落ちてくるぷよを左右に移動できる（ぷよを適切な位置に配置したいですよね）
- プレイヤーとして、落ちてくるぷよを回転できる（戦略的にぷよを配置するために必要です）
- プレイヤーとして、ぷよを素早く落下させることができる（「早く次のぷよを落としたい！」というときのために）
- プレイヤーとして、同じ色のぷよを4つ以上つなげると消去できる（これがぷよぷよの醍醐味ですよね！）
- プレイヤーとして、連鎖反応を起こしてより高いスコアを獲得できる（「れ〜んさ〜ん！」と叫びたくなりますよね）
- プレイヤーとして、全消し（ぜんけし）ボーナスを獲得できる（「やった！全部消えた！」という達成感を味わいたいですよね）
- プレイヤーとして、ゲームオーバーになるとゲーム終了の演出を見ることができる（終わりが明確でないとモヤモヤしますよね）
- プレイヤーとして、現在のスコアを確認できる（「今どれくらい点数取れてるかな？」と気になりますよね）
- プレイヤーとして、キーボードでぷよを操作できる（PCでプレイするなら必須ですよね）
- プレイヤーとして、タッチ操作でぷよを操作できる（スマホでもプレイしたいですよね）

「うわ、結構たくさんあるな...」と思われるかもしれませんが、心配いりません！これらのユーザーストーリーを一つずつ実装していくことで、徐々にゲームを完成させていきましょう。テスト駆動開発の素晴らしいところは、各ストーリーを小さなタスクに分解し、テスト→実装→リファクタリングのサイクルで少しずつ進められることなんです。一歩一歩、着実に進んでいきましょう！

### ユースケース図

ユーザーストーリーを整理したところで、「これらの機能がどのように関連しているのか、全体像が見えるといいな」と思いませんか？そんなときに役立つのが「ユースケース図」です。
「ユースケース図って何？」と思われるかもしれませんね。ユースケース図は、システムと外部アクター（ここではプレイヤーとシステム自体）の相互作用を視覚的に表現するための図です。「絵に描いて整理すると分かりやすい」というやつですね。

> ユースケースは、システムの振る舞いに関する利害関係者の契約を表現するものです。
> 
> — アリスター・コーバーン 『ユースケース実践ガイド』

「百聞は一見にしかず」というように、実際に見てみるのが一番分かりやすいですよね。では、私たちのぷよぷよゲームのユースケース図を見てみましょう：

```plantuml
@startuml "ぷよぷよゲームシステムのユースケース図"
left to right direction
skinparam packageStyle rectangle
skinparam linetype ortho

' アクターの定義
actor "プレイヤー" as Player
actor "システム" as System

rectangle "ぷよぷよゲームシステム" {
  together {
    ' ゲーム管理関連のユースケース
    usecase "新しいゲームを開始" as StartNewGame
    usecase "ゲームをリスタート" as RestartGame
  }

  together {
    ' ぷよ操作関連のユースケース
    usecase "ぷよを左右に移動" as MovePuyo
    usecase "ぷよを回転" as RotatePuyo
    usecase "ぷよを素早く落下" as QuickDropPuyo
  }

  together {
    ' ゲームプレイ関連のユースケース
    usecase "ぷよを自由落下" as FallPuyo
    usecase "ぷよを消去" as ErasePuyo
    usecase "連鎖反応を発生" as ChainReaction
    usecase "全消しボーナスを獲得" as ZenkeshiBonus
    usecase "スコアを表示" as DisplayScore
  }

  together {
    ' 入力関連のユースケース
    usecase "キーボードで操作" as KeyboardControl
    usecase "タッチ操作" as TouchControl
  }

  together {
    ' システム関連のユースケース
    usecase "ゲームオーバー判定" as GameOverCheck
    usecase "ゲームオーバー演出" as GameOverAnimation
  }
}

' プレイヤーの関連
Player --> StartNewGame
Player --> RestartGame
Player --> MovePuyo
Player --> RotatePuyo
Player --> QuickDropPuyo
Player --> KeyboardControl
Player --> TouchControl

' システムの関連
ErasePuyo <-- System
FallPuyo <-- System
ChainReaction <-- System
ZenkeshiBonus <-- System
DisplayScore <-- System
GameOverCheck <-- System
GameOverAnimation <-- System

' 包含関係
MovePuyo ..> KeyboardControl : <<extend>>
MovePuyo ..> TouchControl : <<extend>>
RotatePuyo ..> KeyboardControl : <<extend>>
RotatePuyo ..> TouchControl : <<extend>>
QuickDropPuyo ..> KeyboardControl : <<extend>>
QuickDropPuyo ..> TouchControl : <<extend>>

' その他の関係
ErasePuyo ..> ChainReaction : <<include>>
ChainReaction ..> DisplayScore : <<include>>
ZenkeshiBonus ..> DisplayScore : <<include>>
GameOverCheck ..> GameOverAnimation : <<include>>

@enduml
```

この図を見ると、プレイヤーとシステムの役割分担がよくわかりますね。プレイヤーはゲームの開始や操作を担当し、システムはぷよの消去判定やスコア計算などの内部処理を担当しています。また、キーボード操作とタッチ操作は「拡張（extend）」関係にあり、ぷよの移動や回転などの基本操作を異なる入力方法で実現していることがわかります。

このようにユースケース図を作成することで、システムの全体像を把握し、実装すべき機能の関連性を明確にすることができます。それでは、実際のコード実装に進んでいきましょう！

誤解しないでもらいたいのですが本来ユースケースとはテキストで記述するものでありユースケース図は概要を把握するための手段に過ぎないということです。

> 楕円、矢印、人型おアイコンから構成されているUMLのユースケース図は、ユースケースを把握するための表記法ではありません。
> 楕円や矢印は、ユースケースをのパッケージや分解を表すもので、内容を表すものではありません。 
> 
> — アリスター・コーバーン 『ユースケース実践ガイド』

## リリース計画

要件もわかった、プログラミング開始だ！ちょっと待ってください、何事も計画を立てる事は大事なことです。ユースケース図を見てください、結構いろんなことがありますよね。何から取り組みますか？
「スコアの表示」ですか？「ゲームオーバー判定」ですか？でもまずは「新しいゲームを開始」しないとつながりとして難しいですよね。もちろん実際にプログラミングしながら順番を考えてもいいですけど間違った順番で進めると直すのが大変ですよね。
それにこれからどんなものを作るのかは事前にある程度イメージを固めておきたいものです（いきなり「ゲームオーバー」になるゲームはやりたくないですよね）。

> 計画づくりとは「なにをいつまでに作ればいいのか？」という質問に答える作業だと私は考えている
>
> — Mike Cohn 『アジャイルな見積と計画づくり』

今回の目的はぷよぷよゲームを遊べるための最小限の機能の実装です。目的を実現するためにやるべきことをイテレーションという単位でまとめましょう。「全部やること洗い出すの？そんな先のことはわからないよ！」と思いますよね。安心してください今決めることは大まかな作業の流れと前後関係の整理だけです。
細かい部分は各イテレーションでおいおい明確になってきます。その手助けをしてくれるのがテスト駆動開発なのです。

> 正しい設計を、正しいタイミングで行う。動かしてから、正しくする。
>
> — Kent Beck 『テスト駆動開発』

今回はユーザーストーリーとユースケース図から以下のイテレーション計画に従ってぷよぷよゲームをリリースします。

- イテレーション1: ゲーム開始の実装
- イテレーション2: ぷよの移動の実装
- イテレーション3: ぷよの回転の実装
- イテレーション4: ぷよの自由落下の実装
- イテレーション5: ぷよの高速落下の実装
- イテレーション6: ぷよの消去の実装
- イテレーション7: 連鎖反応の実装
- イテレーション8: 全消しボーナスの実装
- イテレーション9: ゲームオーバーの実装

では、ぷよぷよゲーム開発スタートです！

## イテレーション0: 環境の構築

...と言いたいところですがまずは環境の構築をしなければなりません。「プログラミングなんてどの言語でやるか決めるぐらいでしょ？」と思うかもしれませんが家を建てるときにしっかりとした基礎工事が必要なように開発環境もしっかりとした準備が必要です。
家を建てた後に基礎がダメだと困ったことになりますからね。


### ソフトウェア開発の三種の神器

良いコードを書き続けるためには何が必要になるでしょうか？それは[ソフトウェア開発の三種の神器](https://t-wada.hatenablog.jp/entry/clean-code-that-works)と呼ばれるものです。

> 今日のソフトウェア開発の世界において絶対になければならない3つの技術的な柱があります。
> 三本柱と言ったり、三種の神器と言ったりしていますが、それらは
>
>   - バージョン管理
>   - テスティング
>   - 自動化
>
> の3つです。
>
> —  https://t-wada.hatenablog.jp/entry/clean-code-that-works

本章では開発環境のセットアップとして、これら三種の神器を準備していきます。環境構築は退屈に感じるかもしれませんが、これらのツールがあることで、安心してコードを書くことができるようになります。一緒に進めていきましょう！

### バージョン管理: Gitとコミットメッセージ

バージョン管理システムとして Git を使います。Git については既に使用していると仮定しますが、コミットメッセージについて1つだけ重要なルールを確認しておきましょう。

#### コミットメッセージの書き方

私たちのプロジェクトでは、[Conventional Commits](https://www.conventionalcommits.org/ja/)の書式に従ってコミットメッセージを書きます。具体的には、それぞれのコミットメッセージはヘッダ、ボディ、フッタで構成されます。

```
<タイプ>(<スコープ>): <タイトル>
<空行>
<ボディ>
<空行>
<フッタ>
```

ヘッダは必須で、スコープは任意です。コミットメッセージのタイトルは50文字までにしましょう（GitHub上で読みやすくなります）。

コミットのタイプは次を用います：

- **feat**: 新しい機能
- **fix**: バグ修正
- **docs**: ドキュメント変更のみ
- **style**: コードに影響を与えない変更（空白、フォーマットなど）
- **refactor**: 機能追加でもバグ修正でもないコード変更
- **perf**: パフォーマンスを改善するコード変更
- **test**: テストの追加や修正
- **chore**: ビルドプロセスや補助ツールの変更

例えば：

```bash
git commit -m 'feat: ゲーム初期化機能を追加'
git commit -m 'refactor: メソッドの抽出'
git commit -m 'test: ぷよ消去のテストケースを追加'
```

### テスティング: パッケージマネージャとテスト環境

良いコードを書くためには、コードが正しく動作することを確認するテストが欠かせません。そのためのツールをセットアップしていきましょう。

#### パッケージマネージャ: npm

外部ライブラリやツールを管理するために **npm**（Node Package Manager）を使います。

> npmとは、Node.jsで記述されたサードパーティ製のライブラリを管理するためのツールで、npmで扱うライブラリをパッケージと呼びます。
>
> —  Node.js公式ドキュメント

まず、`package.json` を作成してプロジェクトの依存関係を管理できるようにします：

```bash
npm init -y
```

これで `package.json` が作成されます。このファイルの `"scripts"` セクションを以下のように設定します：

```json
{
  "name": "puyo-puyo-game",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "gulp": "gulp",
    "watch": "gulp watch",
    "guard": "gulp guard",
    "check": "gulp checkAndFix",
    "commit": "git add . && git commit",
    "setup": "npm install && npm run check"
  }
}
```

設定を追加したら、必要なパッケージをインストールします：

```bash
npm install
```

これで、テストフレームワークやその他の開発ツールがインストールされます。

### 自動化: コード品質の自動管理

良いコードを書き続けるためには、コードの品質を自動的にチェックし、維持していく仕組みが必要です。ここでは、静的コード解析、コードフォーマット、コードカバレッジ、そしてタスクランナーを設定します。

#### 静的コード解析: ESLint

静的コード解析ツールとして **ESLint** を使います。ESLintは、コードを実行せずに潜在的な問題を検出するツールです。

```bash
npm run lint
```

このコマンドを実行すると、コードスタイルやベストプラクティスに違反している箇所が指摘されます。自動修正可能な問題は `--fix` オプションで修正できます：

```bash
npm run lint:fix
```

プロジェクトでは、循環的複雑度を7以下に保つ設定も追加しています。これにより、メソッドが複雑になりすぎることを防ぎます。

> 循環的複雑度(サイクロマティック複雑度)とは、ソフトウェア測定法の一つであり、コードがどれぐらい複雑であるかをメソッド単位で数値にして表す指標。

#### コードフォーマッタ: Prettier

コードのフォーマットを統一するために **Prettier** を使います。

> 優れたソースコードは「目に優しい」ものでなければいけない。
>
> —  リーダブルコード

フォーマットのチェックと自動修正は以下のコマンドで実行できます：

```bash
npm run format:check  # チェックのみ
npm run format        # 自動修正
```

#### コードカバレッジ: Vitest Coverage

テストがコードのどれだけをカバーしているかを確認するために、**Vitest** のカバレッジ機能を使います。

> コード網羅率（コードもうらりつ、英: Code coverage）は、ソフトウェアテストで用いられる尺度の1つである。プログラムのソースコードがテストされた割合を意味する。

必要なパッケージをインストールします：

```bash
npm install --save-dev vitest @vitest/coverage-v8
```

カバレッジレポートを生成するには：

```bash
npm run test:coverage
```

実行後、`coverage` フォルダ内の `index.html` を開くと、視覚的にカバレッジ状況を確認できます。

#### タスクランナー: Gulp

複数のコマンドを覚えるのは大変です。タスクランナーの **Gulp** を使って、よく使うコマンドをタスクとして登録し、簡単に実行できるようにします。

> GulpはJavaScript/TypeScriptにおけるタスクランナーです。gulpコマンドと起点となるgulpfile.jsというタスクを記述するファイルを用意することで、タスクの実行や登録されたタスクの一覧表示を行えます。

`gulpfile.js` を作成し、以下のように設定します：

```javascript
import { watch, series } from 'gulp'
import shell from 'gulp-shell'

// テストタスク
export const test = shell.task(['npm run test'])

// テストカバレッジタスク
export const coverage = shell.task(['npm run test:coverage'])

// 静的コード解析タスク
export const lint = shell.task(['npm run lint'])

// 自動修正付き静的コード解析タスク
export const lintFix = shell.task(['npm run lint:fix'])

// フォーマットタスク
export const format = shell.task(['npm run format'])

// フォーマットチェックタスク
export const formatCheck = shell.task(['npm run format:check'])

// ビルドタスク
export const build = shell.task(['npm run build'])

// 開発サーバータスク
export const dev = shell.task(['npm run dev'])

// 全体チェックタスク（自動修正付き）
export const checkAndFix = series(lintFix, format, test)

// ファイル監視タスク（自動テスト実行）
export function guard() {
  console.log('🔍 Guard is watching for file changes...')
  console.log('Files will be automatically linted, formatted, and tested on change.')
  watch('src/**/*.ts', series(lintFix, format, test))
  watch('**/*.test.ts', series(test))
}

// ファイル監視タスク
export function watchFiles() {
  watch('src/**/*.ts', series(formatCheck, lint, test))
  watch('**/*.test.ts', series(test))
}

// デフォルトタスク
export default series(checkAndFix, guard)

// ウォッチタスクのエイリアス
export { watchFiles as watch }
```

登録されたタスクを確認するには：

```bash
npx gulp --tasks
```

特定のタスクを実行するには：

```bash
npx gulp test      # テスト実行
npx gulp lint      # 静的解析
npx gulp format    # フォーマット
npx gulp check     # 全体チェック（自動修正付き）
```

#### タスクの自動実行: Guard

ファイルを編集するたびに手動でコマンドを実行するのは面倒です。**Guard** 機能を使って、ファイルの変更を検知して自動的にテストやフォーマットを実行できるようにします。

```bash
npm run guard
```

このコマンドを実行すると、ファイルを保存するたびに自動的に以下が実行されます：

1. ESLintによる静的解析（自動修正付き）
2. Prettierによるフォーマット
3. テストの実行

これにより、常にコードの品質を保ちながら開発を進めることができます。開発を始める際は、まず `npm run guard` を実行して、後はコードを書くことに集中しましょう！

### 環境構築の完了

お疲れさまでした！これで開発環境のセットアップが完了しました。以下のツールが使えるようになりました：

- **バージョン管理**: Git（Conventional Commits形式）
- **テスティング**: Vitest（カバレッジレポート付き）
- **静的コード解析**: ESLint（循環的複雑度チェック付き）
- **コードフォーマット**: Prettier
- **タスクランナー**: Gulp
- **自動化**: Guard（ファイル監視と自動実行）

これらのツールにより、[ソフトウェア開発の三種の神器](https://t-wada.hatenablog.jp/entry/clean-code-that-works)が揃いました。これから安心してテスト駆動開発に取り組むことができます！

### 環境構成

実際に構築した開発環境の構成は以下の通りです：

#### プロジェクト構造

```
app/typescript-3/
├── src/                    # ソースコード
│   └── main.ts            # エントリーポイント
├── tests/                 # テストコード
│   └── example.test.ts    # テストサンプル
├── package.json           # 依存関係管理
├── tsconfig.json          # TypeScript設定
├── tsconfig.node.json     # Node.js用TypeScript設定
├── vite.config.ts         # Vite設定
├── vitest.config.ts       # Vitest設定
├── gulpfile.js            # Gulpタスク定義
├── .eslintrc.cjs          # ESLint設定
├── .prettierrc            # Prettier設定
├── .gitignore             # Git除外設定
└── index.html             # HTMLエントリーポイント
```

#### package.json の主要な設定

```json
{
  "name": "puyo-puyo-game",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "gulp": "gulp",
    "watch": "gulp watch",
    "guard": "gulp guard",
    "check": "gulp checkAndFix",
    "commit": "git add . && git commit",
    "setup": "npm install && npm run check"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@vitest/coverage-v8": "^1.3.1",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-complexity": "^1.0.2",
    "gulp": "^5.0.0",
    "gulp-shell": "^0.8.0",
    "jsdom": "^27.0.0",
    "prettier": "^3.2.5",
    "typescript": "^5.3.3",
    "vite": "^5.1.0",
    "vitest": "^1.3.1"
  }
}
```

#### TypeScript設定（tsconfig.json）

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["vitest/globals"]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

#### ESLint設定（.eslintrc.cjs）

```javascript
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'prettier',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['complexity'],
  rules: {
    complexity: ['error', 7],
    '@typescript-eslint/no-explicit-any': 'warn',
  },
}
```

#### Prettier設定（.prettierrc）

```json
{
  "semi": false,
  "singleQuote": true,
  "trailingComma": "es5",
  "printWidth": 80,
  "tabWidth": 2
}
```

#### Vitest設定（vitest.config.ts）

```typescript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.test.ts',
        '**/*.spec.ts',
        'gulpfile.js',
        'vite.config.ts',
        'vitest.config.ts',
      ],
    },
  },
})
```

#### 環境構築の確認

環境構築が正しく完了したことを確認するには、以下のコマンドを実行します：

```bash
cd app/typescript-3
npm run check
```

このコマンドは以下の処理を順次実行します：

1. ESLint による静的解析（自動修正付き）
2. Prettier によるコードフォーマット
3. Vitest によるテスト実行

すべてのチェックが成功すれば、環境構築は完了です。

では、実際のゲーム開発に進みましょう！

## イテレーション1: ゲーム開始の実装

さあ、いよいよコードを書き始めましょう！テスト駆動開発では、小さなイテレーション（反復）で機能を少しずつ追加していきます。最初のイテレーションでは、最も基本的な機能である「ゲームの開始」を実装します。

> システム構築はどこから始めるべきだろうか。システム構築が終わったらこうなる、というストーリーを語るところからだ。
>
> — Kent Beck 『テスト駆動開発』

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、新しいゲームを開始できる

このシンプルなストーリーから始めることで、ゲームの基本的な構造を作り、後続の機能追加の土台を築くことができます。では、テスト駆動開発のサイクルに従って、まずはテストから書いていきましょう！

### TODOリスト

さて、ユーザーストーリーを実装するために、まずはTODOリストを作成しましょう。TODOリストは、大きな機能を小さなタスクに分解するのに役立ちます。

> 何をテストすべきだろうか - 着手する前に、必要になりそうなテストをリストに書き出しておこう。
> 
> — Kent Beck 『テスト駆動開発』

私たちの「新しいゲームを開始できる」というユーザーストーリーを実現するためには、どのようなタスクが必要でしょうか？考えてみましょう：

- ゲームの初期化処理を実装する（ゲームの状態や必要なコンポーネントを設定する）
- ゲーム画面を表示する（プレイヤーが視覚的にゲームを認識できるようにする）
- 新しいぷよを生成する（ゲーム開始時に最初のぷよを作成する）
- ゲームループを開始する（ゲームの継続的な更新と描画を行う）

これらのタスクを一つずつ実装していきましょう。テスト駆動開発では、各タスクに対してテスト→実装→リファクタリングのサイクルを回します。まずは「ゲームの初期化処理」から始めましょう！

### テスト: ゲームの初期化

さて、TODOリストの最初のタスク「ゲームの初期化処理を実装する」に取り掛かりましょう。テスト駆動開発では、まずテストを書くことから始めます。

> テストファースト
> 
> いつテストを書くべきだろうか——それはテスト対象のコードを書く前だ。
> 
> — Kent Beck 『テスト駆動開発』

では、ゲームの初期化処理をテストするコードを書いてみましょう。何をテストすべきでしょうか？ゲームが初期化されたとき、必要なコンポーネントが正しく作成され、ゲームの状態が適切に設定されていることを確認する必要がありますね。

```typescript
// src/tests/game.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { Game } from '../game';
import { Config } from '../config';
import { Stage } from '../stage';
import { PuyoImage } from '../puyoimage';
import { Player } from '../player';
import { Score } from '../score';

describe('ゲーム', () => {
    let game: Game;

    beforeEach(() => {
        // DOMの準備
        document.body.innerHTML = `
            <div id="stage"></div>
            <div id="score"></div>
            <div id="next"></div>
            <div id="next2"></div>
        `;
        game = new Game();
    });

    describe('ゲームの初期化', () => {
        it('ゲームを初期化すると、必要なコンポーネントが作成される', () => {
            game.initialize();

            expect(game['config']).toBeInstanceOf(Config);
            expect(game['puyoImage']).toBeInstanceOf(PuyoImage);
            expect(game['stage']).toBeInstanceOf(Stage);
            expect(game['player']).toBeInstanceOf(Player);
            expect(game['score']).toBeInstanceOf(Score);
        });

        it('ゲームを初期化すると、ゲームモードがstartになる', () => {
            game.initialize();

            expect(game['mode']).toEqual('start');
        });
    });
});
```

このテストでは、`Game`クラスの`initialize`メソッドが正しく動作することを確認しています。具体的には、必要なコンポーネント（Config, PuyoImage, Stage, Player, Score）が作成され、ゲームモードが'start'に設定されることを検証しています。

### 実装: ゲームの初期化

テストを書いたら、次に実行してみましょう。どうなるでしょうか？

```
Error: Cannot find module '../game'
```

おっと！まだ`Game`クラスを実装していないので、当然エラーになりますね。これがテスト駆動開発の「Red（赤）」の状態です。テストが失敗することを確認できました。

> アサートファースト
> 
> ではテストはどこから書き始めるべきだろうか。それはテストの終わりにパスすべきアサーションを書くところからだ。
> 
> — Kent Beck 『テスト駆動開発』

では、テストが通るように最小限のコードを実装していきましょう。「最小限」というのがポイントです。この段階では、テストが通ることだけを目指して、必要最低限のコードを書きます。

```typescript
// src/game.ts
import { Config } from './config';
import { PuyoImage } from './puyoimage';
import { Stage } from './stage';
import { Player } from './player';
import { Score } from './score';

export type GameMode = 'start' | 'checkFall' | 'fall' | 'checkErase' | 'erasing' | 'newPuyo' | 'playing' | 'gameOver';

export class Game {
    private mode: GameMode = 'start';
    private frame: number = 0;
    private combinationCount: number = 0;
    private config: Config;
    private puyoImage: PuyoImage;
    private stage: Stage;
    private player: Player;
    private score: Score;

    constructor() {
        // コンストラクタでは何もしない
    }

    initialize(): void {
        // 各コンポーネントの初期化
        this.config = new Config();
        this.puyoImage = new PuyoImage(this.config);
        this.stage = new Stage(this.config, this.puyoImage);
        this.player = new Player(this.config, this.stage, this.puyoImage);
        this.score = new Score();

        // ゲームモードを設定
        this.mode = 'start';
    }
}
```

### 解説: ゲームの初期化

テストが通りましたね！おめでとうございます。これがテスト駆動開発の「Green（緑）」の状態です。

実装したゲームの初期化処理について、少し解説しておきましょう。この処理では、主に以下のことを行っています：

1. 各コンポーネント（Config, PuyoImage, Stage, Player, Score）のインスタンスを作成
2. ゲームモードを'start'に設定

これにより、ゲームを開始するための準備が整います。各コンポーネントの役割を理解しておくと、今後の実装がスムーズになりますよ：

- **Config**: ゲームの設定値を管理します（画面サイズ、ぷよの大きさなど）
- **PuyoImage**: ぷよの画像を管理します（各色のぷよの画像を読み込み、描画する）
- **Stage**: ゲームのステージ（盤面）を管理します（ぷよの配置状態、消去判定など）
- **Player**: プレイヤーの入力と操作を管理します（キーボード入力の処理、ぷよの移動など）
- **Score**: スコアの計算と表示を管理します（連鎖数に応じたスコア計算など）

このように、責任を明確に分けることで、コードの保守性が高まります。これはオブジェクト指向設計の基本原則の一つ、「単一責任の原則」に従っています。

> 単一責任の原則（SRP）：クラスを変更する理由は1つだけであるべき。
> 
> — Robert C. Martin 『Clean Architecture』

### テスト: ゲームループの開始

次に、ゲームループを開始するテストを書きます。

```typescript
// src/tests/game.test.ts（続き）
describe('ゲームループ', () => {
    it('ゲームループを開始すると、requestAnimationFrameが呼ばれる', () => {
        // requestAnimationFrameのモック
        const originalRequestAnimationFrame = window.requestAnimationFrame;
        const mockRequestAnimationFrame = vi.fn();
        window.requestAnimationFrame = mockRequestAnimationFrame;

        try {
            game.loop();

            expect(mockRequestAnimationFrame).toHaveBeenCalledTimes(1);
            expect(mockRequestAnimationFrame).toHaveBeenCalledWith(expect.any(Function));
        } finally {
            // モックを元に戻す
            window.requestAnimationFrame = originalRequestAnimationFrame;
        }
    });
});
```

このテストでは、`Game`クラスの`loop`メソッドが`requestAnimationFrame`を呼び出すことを確認しています。

### 実装: ゲームループの開始

テストが失敗することを確認したら、テストが通るように最小限のコードを実装します。

```typescript
// src/game.ts（続き）
loop(): void {
    // ゲームループの処理
    requestAnimationFrame(this.loop.bind(this));
}
```

### 解説: ゲームループの開始

さて、今回実装した「ゲームループ」について少し詳しく解説しましょう。「ゲームループって何？」と思われるかもしれませんね。

ゲームループは、その名の通り、ゲームの状態を更新し、画面を描画するための繰り返し処理なんです。心臓がずっと鼓動を続けるように、このループが継続的に実行されることで、ゲームが生き生きと動き続けるんですよ。

ここで使っている`requestAnimationFrame`というメソッド、これがとても賢いんです！「どう賢いの？」というと、ブラウザの描画タイミングに合わせて処理を実行してくれるんです。これによって、スムーズなアニメーションが可能になるんですよ。

コードを見てみると、`loop`メソッド内で`requestAnimationFrame`を呼び出し、自分自身（`this.loop`）をコールバックとして渡していますね。「これってどういうこと？」というと、「次の描画タイミングでも、また私を呼んでね」とブラウザにお願いしているようなものなんです。これによって、ループ処理が実現されるんですよ。

また、`bind(this)`という少し難しそうな記述がありますね。これは「コールバック内でも`this`が正しく機能するように」という指示なんです。JavaScriptの`this`は少し扱いが難しいんですが、この`bind(this)`によって、コールバック内でも正しく`this`が機能するようになるんです。

このゲームループが基盤となって、これから様々な機能を追加していきますよ！

### main.ts の実装

最後に、ゲームを起動するエントリーポイント `main.ts` を実装します。

```typescript
// src/main.ts
import { Game } from './game'

// ゲームのインスタンスを作成
const game = new Game()

// ゲームを初期化
game.initialize()

// ゲームループを開始
game.loop()

console.log('Puyo Puyo Game Started!')
```

このコードでは、以下の 3 つのステップでゲームを開始します：

1. `Game` クラスのインスタンスを作成
2. `initialize()` メソッドで各コンポーネントを初期化
3. `loop()` メソッドでゲームループを開始

### 依存クラスの実装

必要な依存クラス（Config, PuyoImage, Stage, Player, Score）も最小限の実装を作成します。

```typescript
// src/config.ts
export class Config {
  // 最小限の実装
}

// src/puyoimage.ts
import { Config } from './config'

export class PuyoImage {
  constructor(_config: Config) {
    // 最小限の実装
  }
}

// src/stage.ts
import { Config } from './config'
import { PuyoImage } from './puyoimage'

export class Stage {
  constructor(_config: Config, _puyoImage: PuyoImage) {
    // 最小限の実装
  }
}

// src/player.ts
import { Config } from './config'
import { Stage } from './stage'
import { PuyoImage } from './puyoimage'

export class Player {
  constructor(_config: Config, _stage: Stage, _puyoImage: PuyoImage) {
    // 最小限の実装
  }
}

// src/score.ts
export class Score {
  // 最小限の実装
}
```

これらのクラスは現時点では空の実装ですが、後続のイテレーションで徐々に機能を追加していきます。

### ESLint 設定の調整

未使用の引数に関する ESLint エラーを回避するため、`.eslintrc.cjs` に以下の設定を追加します：

```javascript
rules: {
  complexity: ['error', 7],
  '@typescript-eslint/no-explicit-any': 'warn',
  '@typescript-eslint/no-unused-vars': [
    'error',
    {
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_',
    },
  ],
},
```

この設定により、`_` で始まる引数名は未使用でもエラーにならなくなります。

### テストの確認

すべての実装が完了したら、テストを実行して確認しましょう：

```bash
npm run check
```

以下の結果が表示されれば成功です：

```
✓ tests/game.test.ts (3 tests) 9ms

Test Files  1 passed (1)
     Tests  3 passed (3)
```

### 画面の確認

ではここで以下のコマンドを実行して実際に動作する画面を確認しましょう。

```bash
npm run dev
```

ブラウザで `http://localhost:3000` を開くと、ぷよぷよゲームの画面が表示されます。コンソールには「Puyo Puyo Game Started!」というメッセージが表示されているはずです。

おめでとうございます！リリースに向けて最初の第一歩を踏み出すことができました。これから機能を追加するごとにどんどん実際のゲームの完成に近づく事が確認できます、楽しみですね。

「機能は別々に作りこんで最後に画面と統合するんじゃないの？」と思うもしれません。そういうアプローチもありますが画面イメージが最後まで確認できないともし間違っていたら手戻りが大変です。それに動作するプログラムがどんどん成長するのを見るのは楽しいですからね。

> トップダウンでもボトムアップでもなく、エンドツーエンドで構築していく
>
>    エンドツーエンドで小さな機能を構築し、そこから作業を進めながら問題について学習していく。
>
> — 達人プログラマー 熟達に向けたあなたの旅（第2版）

### イテレーション 1 のまとめ

このイテレーションで実装した内容：

1. **Game クラスの初期化**
   - 必要なコンポーネント（Config, PuyoImage, Stage, Player, Score）の作成
   - ゲームモードの設定

2. **ゲームループの実装**
   - `requestAnimationFrame` を使用した継続的なループ処理
   - `bind(this)` による `this` コンテキストの保持

3. **エントリーポイントの実装**
   - `main.ts` でゲームの初期化とループ開始
   - ブラウザでの動作確認が可能に

4. **テストの作成**
   - ゲーム初期化のテスト（2 テスト）
   - ゲームループのテスト（1 テスト）
   - すべてのテストが成功

次のイテレーションでは、ぷよの移動機能を実装していきます。

## イテレーション2: ぷよの移動の実装

さて、前回のイテレーションでゲームの基本的な構造ができましたね。「ゲームが始まったけど、ぷよが動かないと面白くないよね？」と思いませんか？そこで次は、ぷよを左右に移動できるようにしていきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、落ちてくるぷよを左右に移動できる

「ぷよぷよって、落ちてくるぷよを左右に動かして、うまく積み上げるゲームですよね？」そうです！今回はその基本操作である「左右の移動」を実装していきます。

### TODOリスト

さて、このユーザーストーリーを実現するために、どんなタスクが必要でしょうか？一緒に考えてみましょう。
「ぷよを左右に移動する」という機能を実現するためには、以下のようなタスクが必要そうですね：

- プレイヤーの入力を検出する（キーボードの左右キーが押されたことを検知する）
- ぷよを左右に移動する処理を実装する（実際にぷよの位置を変更する）
- 移動可能かどうかのチェックを実装する（画面の端や他のぷよにぶつかる場合は移動できないようにする）
- 移動後の表示を更新する（画面上でぷよの位置が変わったことを表示する）

「なるほど、順番に実装していけばいいんですね！」そうです、一つずつ進めていきましょう。テスト駆動開発の流れに沿って、まずはテストから書いていきますよ。

### テスト: プレイヤーの入力検出

「最初に何をテストすればいいんでしょうか？」まずは、プレイヤーの入力を検出する部分からテストしていきましょう。キーボードの左右キーが押されたときに、それを正しく検知できるかどうかをテストします。

> テストファースト
> 
> いつテストを書くべきだろうか——それはテスト対象のコードを書く前だ。
> 
> — Kent Beck 『テスト駆動開発』

```typescript
// src/tests/player.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { Player } from '../player';
import { Config } from '../config';
import { Stage } from '../stage';
import { PuyoImage } from '../puyoimage';

describe('プレイヤー', () => {
    let config: Config;
    let puyoImage: PuyoImage;
    let stage: Stage;
    let player: Player;

    beforeEach(() => {
        // DOMの準備
        document.body.innerHTML = `
            <div id="stage"></div>
        `;
        config = new Config();
        puyoImage = new PuyoImage(config);
        stage = new Stage(config, puyoImage);
        player = new Player(config, stage, puyoImage);
    });

    describe('キー入力', () => {
        it('左キーが押されると、左向きの移動フラグが立つ', () => {
            // キーダウンイベントをシミュレート（左キー）
            const event = new KeyboardEvent('keydown', { key: 'ArrowLeft' });
            document.dispatchEvent(event);

            expect(player['inputKeyLeft']).toBe(true);
        });

        it('右キーが押されると、右向きの移動フラグが立つ', () => {
            // キーダウンイベントをシミュレート（右キー）
            const event = new KeyboardEvent('keydown', { key: 'ArrowRight' });
            document.dispatchEvent(event);

            expect(player['inputKeyRight']).toBe(true);
        });

        it('キーが離されると、対応する移動フラグが下がる', () => {
            // まず左キーを押す
            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowLeft' }));
            expect(player['inputKeyLeft']).toBe(true);

            // 次に左キーを離す
            document.dispatchEvent(new KeyboardEvent('keyup', { key: 'ArrowLeft' }));
            expect(player['inputKeyLeft']).toBe(false);
        });
    });
});
```

「このテストは何をしているんですか？」このテストでは、キーボードの左右キーが押されたときと離されたときに、`Player`クラスの中の対応するフラグが正しく設定されるかどうかを確認しています。例えば、左キーが押されたら`inputKeyLeft`というフラグが`true`になり、離されたら`false`になることを期待していますね。

「テストを実行するとどうなるんでしょう？」まだ実装していないので、当然テストは失敗するはずです。これがテスト駆動開発の「Red（赤）」の状態です。では、テストが通るように実装していきましょう！

### 実装: プレイヤーの入力検出

「失敗するテストができたので、次は実装ですね！」そうです！テストが通るように、最小限のコードを実装していきましょう。

> 仮実装を経て本実装へ
> 
> 失敗するテストを書いてから、最初に行う実装はどのようなものだろうか - ベタ書きの値を返そう。
> それでテストが通るようになったら、ベタ書きの値をだんだん本物の式や変数に置き換えていく。
> 
> — Kent Beck 『テスト駆動開発』

```typescript
// src/player.ts
import { Config } from './config';
import { Stage } from './stage';
import { PuyoImage } from './puyoimage';

export class Player {
    private inputKeyLeft: boolean = false;
    private inputKeyRight: boolean = false;
    private inputKeyUp: boolean = false;
    private inputKeyDown: boolean = false;

    constructor(
        private config: Config,
        private stage: Stage,
        private puyoImage: PuyoImage
    ) {
        // キーボードイベントの登録
        document.addEventListener('keydown', this.onKeyDown.bind(this));
        document.addEventListener('keyup', this.onKeyUp.bind(this));
    }

    private onKeyDown(e: KeyboardEvent): void {
        switch (e.key) {
            case 'ArrowLeft':
                this.inputKeyLeft = true;
                break;
            case 'ArrowRight':
                this.inputKeyRight = true;
                break;
            case 'ArrowUp':
                this.inputKeyUp = true;
                break;
            case 'ArrowDown':
                this.inputKeyDown = true;
                break;
        }
    }

    private onKeyUp(e: KeyboardEvent): void {
        switch (e.key) {
            case 'ArrowLeft':
                this.inputKeyLeft = false;
                break;
            case 'ArrowRight':
                this.inputKeyRight = false;
                break;
            case 'ArrowUp':
                this.inputKeyUp = false;
                break;
            case 'ArrowDown':
                this.inputKeyDown = false;
                break;
        }
    }
}
```

「なるほど！キーが押されたり離されたりしたときのイベントを検知して、フラグを設定しているんですね。」そうです！ここでは、`document.addEventListener`を使って、キーボードのイベントをリッスンしています。キーが押されたら`onKeyDown`メソッドが呼ばれ、離されたら`onKeyUp`メソッドが呼ばれます。

「`bind(this)`って何ですか？」良い質問ですね！JavaScriptでは、イベントハンドラの中の`this`は、イベントが発生した要素（ここでは`document`）を指してしまいます。でも、私たちは`Player`クラスのメソッドの中で`this`が`Player`インスタンスを指すようにしたいんです。そこで`bind(this)`を使って、`this`の参照先を固定しているんですよ。

> bind() は Function インスタンスのメソッドで、新しい関数を生成し、呼び出し時に、 this キーワードを指定された値に設定し、指定された引数の並びを、新しい関数が呼び出された際に指定されたものより前にして呼び出します。
> 
> — Mozilla Developer Network 『Function.prototype.bind()』

「テストは通りましたか？」はい、これでテストは通るはずです！これがテスト駆動開発の「Green（緑）」の状態です。次は、ぷよを実際に移動させる機能をテストしていきましょう。

### テスト: ぷよの移動

「次は何をテストしますか？」次は、ぷよを左右に移動する機能をテストしましょう。ぷよが左右に移動できるか、そして画面の端に到達したときに移動が制限されるかをテストします。

```typescript
// src/tests/player.test.ts（続き）
describe('ぷよの移動', () => {
    beforeEach(() => {
        // 新しいぷよを作成
        player.createNewPuyo();
    });

    it('左に移動できる場合、左に移動する', () => {
        // 初期位置を記録
        const initialX = player['puyoX'];

        // 左に移動
        player.moveLeft();

        // 位置が1つ左に移動していることを確認
        expect(player['puyoX']).toBe(initialX - 1);
    });

    it('右に移動できる場合、右に移動する', () => {
        // 初期位置を記録
        const initialX = player['puyoX'];

        // 右に移動
        player.moveRight();

        // 位置が1つ右に移動していることを確認
        expect(player['puyoX']).toBe(initialX + 1);
    });

    it('左端にいる場合、左に移動できない', () => {
        // 左端に移動
        player['puyoX'] = 0;

        // 左に移動を試みる
        player.moveLeft();

        // 位置が変わっていないことを確認
        expect(player['puyoX']).toBe(0);
    });

    it('右端にいる場合、右に移動できない', () => {
        // 右端に移動（ステージの幅 - 1）
        player['puyoX'] = config.stageCols - 1;

        // 右に移動を試みる
        player.moveRight();

        // 位置が変わっていないことを確認
        expect(player['puyoX']).toBe(config.stageCols - 1);
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、以下の4つのケースを確認しています：

1. 通常の状態で左に移動できるか
2. 通常の状態で右に移動できるか
3. 左端にいるときに左に移動しようとしても位置が変わらないか
4. 右端にいるときに右に移動しようとしても位置が変わらないか

「なるほど、画面の端を超えて移動できないようにするんですね！」そうです！ゲームの画面外にぷよが出てしまうと困りますからね。では、このテストが通るように実装していきましょう。

### 実装: ぷよの移動

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、ぷよを移動させる機能を実装していきましょう。

```typescript
// src/player.ts（続き）
private puyoX: number = 2; // ぷよのX座標（中央に配置）
private puyoY: number = 0; // ぷよのY座標（一番上）
private puyoType: number = 0; // 現在のぷよの種類
private nextPuyoType: number = 0; // 次のぷよの種類
private rotation: number = 0; // 現在の回転状態

createNewPuyo(): void {
    // 新しいぷよを作成（ここでは簡略化）
    this.puyoX = 2;
    this.puyoY = 0;
    this.puyoType = Math.floor(Math.random() * 4) + 1; // 1～4のランダムな値
    this.nextPuyoType = Math.floor(Math.random() * 4) + 1;
    this.rotation = 0;
}

moveLeft(): void {
    // 左端でなければ左に移動
    if (this.puyoX > 0) {
        this.puyoX--;
    }
}

moveRight(): void {
    // 右端でなければ右に移動
    if (this.puyoX < this.config.stageCols - 1) {
        this.puyoX++;
    }
}
```

「ぷよの位置や種類を管理するプロパティがたくさんありますね！」そうですね。ぷよの状態を管理するために、いくつかのプロパティを定義しています：

- `puyoX`と`puyoY`：ぷよの位置（X座標とY座標）
- `puyoType`と`nextPuyoType`：現在のぷよと次のぷよの種類
- `rotation`：ぷよの回転状態

「移動の処理はシンプルですね！」そうですね。`moveLeft`メソッドでは左端（X座標が0）でなければX座標を1減らし、`moveRight`メソッドでは右端（X座標がステージの幅-1）でなければX座標を1増やしています。これで、ぷよが画面の端を超えて移動することはなくなりました。

「これでテストは通りましたか？」はい、これでテストは通るはずです！これでぷよを左右に移動させる基本的な機能が実装できました。プレイヤーがキーボードの左右キーを押すと、ぷよが対応する方向に移動し、画面の端に到達すると移動が制限されます。

「でも、まだ実際にキー入力に応じて移動する処理が実装されていませんよね？」鋭い指摘ですね！確かに、キーが押されたことを検知するフラグと、ぷよを移動させるメソッドはできましたが、それらを連携させる部分はまだ実装していません。これは次のイテレーションで、ゲームループの中で処理していきますね。

「なるほど、少しずつ機能を追加していくんですね！」そうです！テスト駆動開発では、小さな機能を一つずつ確実に実装していくことで、複雑なシステムを構築していきます。今回は「ぷよを左右に移動させる」という基本機能を実装しました。次のイテレーションでは、「ぷよを回転させる」機能を実装していきましょう！

### 実装:ぷよの画面表示

「テストは通ったけど、実際にぷよが動いているところを見たいですね！」そうですね！それでは、ぷよを画面に表示して、実際にキーボードで操作できるようにしましょう。

#### Config クラスの拡張

まず、画面表示に必要な設定を Config クラスに追加します：

```typescript
// src/config.ts
export class Config {
  stageCols: number = 6 // ステージの列数
  stageRows: number = 12 // ステージの行数
  puyoSize: number = 32 // ぷよのサイズ（ピクセル）
  stageBackgroundColor: string = '#2a2a2a' // ステージの背景色
  stageBorderColor: string = '#444' // ステージの枠線色
}
```

#### PuyoImage クラスの実装

次に、ぷよを描画するための PuyoImage クラスを実装します：

```typescript
// src/puyoimage.ts
import { Config } from './config'

export class PuyoImage {
  private readonly colors: string[] = [
    '#888', // 0: 空
    '#ff0000', // 1: 赤
    '#00ff00', // 2: 緑
    '#0000ff', // 3: 青
    '#ffff00', // 4: 黄色
  ]

  constructor(private config: Config) {}

  draw(
    ctx: CanvasRenderingContext2D,
    type: number,
    x: number,
    y: number
  ): void {
    const size = this.config.puyoSize
    const color = this.colors[type] || this.colors[0]

    // 円の中心座標と半径を計算
    const centerX = x * size + size / 2
    const centerY = y * size + size / 2
    const radius = size / 2 - 2 // 少し小さめにして余白を作る

    // ぷよを円形で描画
    ctx.fillStyle = color
    ctx.beginPath()
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2)
    ctx.fill()

    // 枠線を描画
    ctx.strokeStyle = '#000'
    ctx.lineWidth = 2
    ctx.beginPath()
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2)
    ctx.stroke()
  }
}
```

「ぷよを円形で描画しているんですね！」そうです！`ctx.arc()` メソッドを使って、ぷよを円形で描画しています。

#### Stage クラスの実装

続いて、ゲームのステージを管理する Stage クラスを実装します：

```typescript
// src/stage.ts
import { Config } from './config'
import { PuyoImage } from './puyoimage'

export class Stage {
  private canvas!: HTMLCanvasElement
  private ctx!: CanvasRenderingContext2D
  private field: number[][] = []

  constructor(
    private config: Config,
    private puyoImage: PuyoImage
  ) {
    this.initializeCanvas()
    this.initializeField()
  }

  private initializeCanvas(): void {
    // canvas要素を作成
    this.canvas = document.createElement('canvas')
    this.canvas.width = this.config.stageCols * this.config.puyoSize
    this.canvas.height = this.config.stageRows * this.config.puyoSize
    this.canvas.style.border = `2px solid ${this.config.stageBorderColor}`
    this.canvas.style.backgroundColor = this.config.stageBackgroundColor

    // ステージ要素に追加
    const stageElement = document.getElementById('stage')
    if (stageElement) {
      stageElement.appendChild(this.canvas)
    }

    // 描画コンテキストを取得（テスト環境では取得できない可能性がある）
    const ctx = this.canvas.getContext('2d')
    if (ctx) {
      this.ctx = ctx
    }
  }

  private initializeField(): void {
    // フィールドを初期化（全て0=空）
    this.field = []
    for (let y = 0; y < this.config.stageRows; y++) {
      this.field[y] = []
      for (let x = 0; x < this.config.stageCols; x++) {
        this.field[y][x] = 0
      }
    }
  }

  draw(): void {
    if (!this.ctx) return // テスト環境対応

    // キャンバスをクリア
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)

    // フィールドのぷよを描画
    for (let y = 0; y < this.config.stageRows; y++) {
      for (let x = 0; x < this.config.stageCols; x++) {
        const puyoType = this.field[y][x]
        if (puyoType > 0) {
          this.puyoImage.draw(this.ctx, puyoType, x, y)
        }
      }
    }
  }

  drawPuyo(x: number, y: number, type: number): void {
    if (!this.ctx) return // テスト環境対応

    // 指定位置にぷよを描画
    this.puyoImage.draw(this.ctx, type, x, y)
  }

  setPuyo(x: number, y: number, type: number): void {
    // フィールドにぷよを配置
    if (
      y >= 0 &&
      y < this.config.stageRows &&
      x >= 0 &&
      x < this.config.stageCols
    ) {
      this.field[y][x] = type
    }
  }

  getPuyo(x: number, y: number): number {
    // フィールドからぷよの種類を取得
    if (
      y < 0 ||
      y >= this.config.stageRows ||
      x < 0 ||
      x >= this.config.stageCols
    ) {
      return -1 // 範囲外
    }
    return this.field[y][x]
  }
}
```

「Canvas を使って描画しているんですね！」そうです。HTML5 の Canvas API を使って、ゲーム画面を描画しています。

#### Player クラスの拡張

Player クラスに描画と更新のメソッドを追加します：

```typescript
// src/player.ts（追加部分）
draw(): void {
  // 現在のぷよを描画
  this.stage.drawPuyo(this.puyoX, this.puyoY, this.puyoType)
}

update(): void {
  // キー入力に応じて移動
  if (this.inputKeyLeft) {
    this.moveLeft()
    this.inputKeyLeft = false // 移動後フラグをクリア
  }
  if (this.inputKeyRight) {
    this.moveRight()
    this.inputKeyRight = false // 移動後フラグをクリア
  }
}
```

#### Game クラスの更新

最後に、Game クラスのゲームループで描画と更新を行うようにします：

```typescript
// src/game.ts
initialize(): void {
  // 各コンポーネントの初期化
  this.config = new Config()
  this.puyoImage = new PuyoImage(this.config)
  this.stage = new Stage(this.config, this.puyoImage)
  this.player = new Player(this.config, this.stage, this.puyoImage)
  this.score = new Score()

  // ゲームモードを設定
  this.mode = 'newPuyo'
}

loop(): void {
  // ゲームループの処理
  this.update()
  this.draw()
  requestAnimationFrame(this.loop.bind(this))
}

private update(): void {
  this.frame++

  // モードに応じた処理
  switch (this.mode) {
    case 'newPuyo':
      // 新しいぷよを作成
      this.player.createNewPuyo()
      this.mode = 'playing'
      break

    case 'playing':
      // プレイ中の処理（キー入力に応じた移動）
      this.player.update()
      break
  }
}

private draw(): void {
  // ステージを描画
  this.stage.draw()

  // プレイヤーのぷよを描画
  if (this.mode === 'playing') {
    this.player.draw()
  }
}
```

#### 動作確認

「これで実際に動かせますね！」はい！開発サーバーを起動して、ブラウザで確認してみましょう：

```bash
npm run dev
```

ブラウザで `http://localhost:3000/` にアクセスすると、ステージが表示され、円形のぷよが表示されます。左右の矢印キーを押すと、ぷよが左右に移動します！

「動きました！」素晴らしい！これで、テストだけでなく実際の動作も確認できるようになりましたね。

#### テスト環境への対応

「でも、Canvas を使うとテストが動かなくなりませんか？」良い質問ですね。jsdom 環境では Canvas の `getContext()` がサポートされていないので、以下のように対応しました：

1. Stage クラスの `initializeCanvas()` で、`ctx` が取得できない場合でもエラーにしない
2. `draw()` や `drawPuyo()` メソッドで、`ctx` が存在しない場合は早期リターン

これにより、テスト環境でも問題なくテストが実行できます。

### イテレーション2のまとめ

このイテレーションで実装した内容：

1. **Player クラスのキー入力検出機能**
   - 4方向のキー入力フラグ（inputKeyLeft, inputKeyRight, inputKeyUp, inputKeyDown）の実装
   - keydown/keyup イベントリスナーの登録
   - setKeyState メソッドによるキー状態の一元管理（リファクタリング）

2. **Player クラスのぷよ移動機能**
   - ぷよの状態管理（puyoX, puyoY, puyoType, nextPuyoType, rotation）
   - createNewPuyo メソッド：新しいぷよを生成
   - moveLeft/moveRight メソッド：ぷよを左右に移動（境界チェック付き）
   - getRandomPuyoType メソッド：ランダムなぷよの種類を生成（リファクタリング）
   - マジックナンバーの定数化（INITIAL_PUYO_X, INITIAL_PUYO_Y, MIN_PUYO_TYPE, MAX_PUYO_TYPE）

3. **Config クラスの拡張**
   - stageCols: ステージの列数（6）
   - stageRows: ステージの行数（12）
   - puyoSize: ぷよのサイズ（32ピクセル）
   - stageBackgroundColor: ステージの背景色
   - stageBorderColor: ステージの枠線色

4. **PuyoImage クラスの実装**
   - colors 配列：ぷよの種類ごとの色定義（赤、緑、青、黄色）
   - draw メソッド：Canvas API を使用した円形ぷよの描画
   - ctx.arc() による円の描画、枠線の追加

5. **Stage クラスの実装**
   - Canvas 要素の生成と DOM への追加
   - field 配列：ステージ上のぷよ配置情報を管理
   - initializeCanvas/initializeField：初期化処理
   - draw/drawPuyo：ステージとぷよの描画
   - setPuyo/getPuyo：フィールドへのぷよの配置と取得
   - テスト環境対応：ctx が null の場合の早期リターン

6. **Player クラスの拡張**
   - draw メソッド：プレイヤーが操作中のぷよを描画
   - update メソッド：キー入力に応じてぷよを移動

7. **Game クラスの拡張**
   - update メソッド：ゲーム状態の更新（newPuyo → playing の状態遷移）
   - draw メソッド：ステージとプレイヤーのぷよを描画
   - loop メソッド：update と draw を呼び出すゲームループ

8. **テストの作成**
   - キー入力検出のテスト（3 テスト）
     - 左キー押下時のフラグ設定
     - 右キー押下時のフラグ設定
     - キー解放時のフラグクリア
   - ぷよの移動テスト（4 テスト）
     - 左に移動できる場合の移動
     - 右に移動できる場合の移動
     - 左端での移動制限
     - 右端での移動制限
   - 合計10テストすべて成功

9. **TDD サイクルの実践**
   - Red: 失敗するテストを先に作成
   - Green: テストを通す最小限の実装
   - Refactor: マジックナンバーの定数化、ランダム生成ロジックの抽出

10. **学んだ重要な概念**
    - `bind(this)` によるイベントハンドラのコンテキスト固定
    - TypeScript の private フィールドアクセス（テストでの `player['inputKeyLeft']` 記法）
    - jsdom 環境での KeyboardEvent のシミュレーション
    - 境界チェックによる移動制限の実装
    - static readonly 定数による設定値の管理
    - Canvas API による 2D グラフィックス描画（arc, fillRect, clearRect）
    - requestAnimationFrame によるゲームループの実装
    - テスト環境と実行環境の違いへの対応（Canvas の getContext の存在チェック）

次のイテレーションでは、ぷよの回転機能を実装していきます。

## イテレーション3: ぷよの回転の実装

「左右に移動できるようになったけど、ぷよぷよって回転もできますよね？」そうですね！ぷよぷよの醍醐味の一つは、ぷよを回転させて思い通りの場所に配置することです。今回は、ぷよを回転させる機能を実装していきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、落ちてくるぷよを回転できる

「回転って具体的にどういう動きですか？」良い質問ですね！ぷよぷよでは、2つのぷよが連なった状態で落ちてきます。回転とは、この2つのぷよの相対的な位置関係を変えることです。例えば、縦に並んでいるぷよを横に並ぶように変えたりできるんですよ。

### TODOリスト

「どんな作業が必要になりますか？」このユーザーストーリーを実現するために、TODOリストを作成してみましょう。

「ぷよを回転させる」という機能を実現するためには、以下のようなタスクが必要そうですね：

- ぷよの回転処理を実装する（時計回り・反時計回りの回転）
- 回転可能かどうかのチェックを実装する（他のぷよや壁にぶつかる場合は回転できないようにする）
- 壁キック処理を実装する（壁際での回転を可能にする特殊処理）
- 回転後の表示を更新する（画面上でぷよの位置が変わったことを表示する）

「壁キックって何ですか？」壁キックとは、ぷよが壁際にあるときに回転すると壁にめり込んでしまうので、自動的に少し位置をずらして回転を可能にする処理のことです。プレイヤーの操作性を向上させるための工夫なんですよ。

### テスト: ぷよの回転

「まずは何からテストしますか？」テスト駆動開発の流れに沿って、まずは基本的な回転機能のテストから書いていきましょう。

```typescript
// src/tests/player.test.ts（続き）
describe('ぷよの回転', () => {
    beforeEach(() => {
        // 新しいぷよを作成
        player.createNewPuyo();
    });

    it('時計回りに回転すると、回転状態が1増える', () => {
        // 初期回転状態を記録
        const initialRotation = player['rotation'];

        // 時計回りに回転
        player.rotateRight();

        // 回転状態が1増えていることを確認
        expect(player['rotation']).toBe((initialRotation + 1) % 4);
    });

    it('反時計回りに回転すると、回転状態が1減る', () => {
        // 初期回転状態を記録
        const initialRotation = player['rotation'];

        // 反時計回りに回転
        player.rotateLeft();

        // 回転状態が1減っていることを確認（負の値にならないように調整）
        expect(player['rotation']).toBe((initialRotation + 3) % 4);
    });

    it('回転状態が4になると0に戻る', () => {
        // 回転状態を3に設定
        player['rotation'] = 3;

        // 時計回りに回転
        player.rotateRight();

        // 回転状態が0になっていることを確認
        expect(player['rotation']).toBe(0);
    });
});
```

「このテストは何を確認しているんですか？」このテストでは、以下の3つのケースを確認しています：

1. 時計回りに回転すると、回転状態が1増えるか
2. 反時計回りに回転すると、回転状態が1減るか（ただし、負の値にならないように調整）
3. 回転状態が最大値（3）から時計回りに回転すると、0に戻るか（循環するか）

「回転状態って何ですか？」回転状態は、ぷよの向きを表す値です。0から3までの値を取り、それぞれ以下の状態を表します：
- 0: 2つ目のぷよが上にある状態
- 1: 2つ目のぷよが右にある状態
- 2: 2つ目のぷよが下にある状態
- 3: 2つ目のぷよが左にある状態

「なるほど、4方向の回転を表現するんですね！」そうです！では、このテストが通るように実装していきましょう。

### 実装: ぷよの回転

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、ぷよを回転させる機能を実装していきましょう。

```typescript
// src/player.ts（続き）
rotateRight(): void {
    // 時計回りに回転（0→1→2→3→0）
    this.rotation = (this.rotation + 1) % 4;
}

rotateLeft(): void {
    // 反時計回りに回転（0→3→2→1→0）
    this.rotation = (this.rotation + 3) % 4;
}
```

「シンプルですね！」そうですね。回転処理自体はとてもシンプルです。`rotateRight`メソッドでは回転状態を1増やし、`rotateLeft`メソッドでは回転状態を1減らしています（ただし、負の値にならないように3を足して4で割った余りを取っています）。

「なぜ反時計回りの場合は単純に1減らすのではなく、3を足して4で割るんですか？」鋭い質問ですね！JavaScriptでは、負の数の剰余演算（%演算子）の結果が他の言語と異なる場合があります。例えば、-1 % 4は-1になることがあります。しかし、私たちは常に0から3の範囲の値が欲しいので、3を足して（これは1を引くのと同じ効果があります）から4で割ることで、確実に正の値の範囲内に収めているんです。

> 剰余演算子 (%) は、1 つ目のオペランドが 2 つ目のオペランドで除算されたときの余りである剰余を返します。これは常に被除数の符号を取ります。
> 
> — Mozilla Developer Network 『剰余演算子』

「テストは通りましたか？」はい、これでテストは通るはずです！これで基本的な回転機能が実装できました。しかし、まだ壁際での回転（壁キック）処理が実装されていませんね。次はそれをテストしていきましょう。

### テスト: 壁キック処理

「壁キック処理のテストはどうやって書くんですか？」壁キック処理は、ぷよが壁際にあるときに回転すると自動的に位置を調整する機能です。これをテストするには、ぷよを壁際に配置し、回転させたときに適切に位置が調整されるかを確認します。

```typescript
// src/tests/player.test.ts（続き）
describe('壁キック処理', () => {
    beforeEach(() => {
        // 新しいぷよを作成
        player.createNewPuyo();
    });

    it('右端で右回転すると、左に移動して回転する（壁キック）', () => {
        // 右端に移動
        player['puyoX'] = config.stageCols - 1;
        player['rotation'] = 0; // 上向き

        // 右回転（2つ目のぷよが右にくる）
        player.rotateRight();

        // 壁キックにより左に移動していることを確認
        expect(player['puyoX']).toBe(config.stageCols - 2);
        expect(player['rotation']).toBe(1);
    });

    it('左端で左回転すると、右に移動して回転する（壁キック）', () => {
        // 左端に移動
        player['puyoX'] = 0;
        player['rotation'] = 0; // 上向き

        // 左回転（2つ目のぷよが左にくる）
        player.rotateLeft();

        // 壁キックにより右に移動していることを確認
        expect(player['puyoX']).toBe(1);
        expect(player['rotation']).toBe(3);
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、以下の2つのケースを確認しています：

1. 右端にいるときに時計回りに回転すると、左に1マス移動して回転するか
2. 左端にいるときに反時計回りに回転すると、右に1マス移動して回転するか

「なるほど、壁にめり込まないように自動的に位置を調整するんですね！」そうです！これがいわゆる「壁キック」と呼ばれる処理です。プレイヤーの操作性を向上させるための工夫なんですよ。では、このテストが通るように実装していきましょう。

### 実装: 壁キック処理

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、壁キック処理を実装していきましょう。

```typescript
// src/player.ts（続き）
rotateRight(): void {
    // 回転前の状態を保存
    const oldRotation = this.rotation;

    // 時計回りに回転
    this.rotation = (this.rotation + 1) % 4;

    // 右端で右回転した場合（2つ目のぷよが右にくる場合）
    if (this.rotation === 1 && this.puyoX === this.config.stageCols - 1) {
        // 左に移動（壁キック）
        this.puyoX--;
    }

    // 左端で左回転した場合（2つ目のぷよが左にくる場合）
    if (this.rotation === 3 && this.puyoX === 0) {
        // 右に移動（壁キック）
        this.puyoX++;
    }
}

rotateLeft(): void {
    // 回転前の状態を保存
    const oldRotation = this.rotation;

    // 反時計回りに回転
    this.rotation = (this.rotation + 3) % 4;

    // 右端で右回転した場合（2つ目のぷよが右にくる場合）
    if (this.rotation === 1 && this.puyoX === this.config.stageCols - 1) {
        // 左に移動（壁キック）
        this.puyoX--;
    }

    // 左端で左回転した場合（2つ目のぷよが左にくる場合）
    if (this.rotation === 3 && this.puyoX === 0) {
        // 右に移動（壁キック）
        this.puyoX++;
    }
}
```

「なるほど、回転後に壁にめり込む場合は位置を調整するんですね！」そうです！この実装では、以下のことを行っています：

1. まず通常の回転処理を行う
2. 回転後、ぷよが壁にめり込む状況になっていないかチェックする
3. めり込む場合は、ぷよの位置を調整する（壁キック）

「でも、`rotateRight`と`rotateLeft`で同じ壁キック処理が重複していますね？」鋭い指摘です！確かに重複していますね。これはリファクタリングの良い候補です。共通の壁キック処理を抽出して、コードの重複を減らすことができるでしょう。しかし、今回はテストが通ることを優先して、リファクタリングは次のステップで行うことにしましょう。

「テストは通りましたか？」はい、これでテストは通るはずです！これでぷよを回転させる機能と、壁際での特殊処理（壁キック）が実装できました。プレイヤーがキーボードの上キーを押すと、ぷよが回転し、壁際でも適切に位置が調整されるようになりました。

### イテレーション3のまとめ

このイテレーションでは、ぷよの回転機能と壁際での特殊処理を実装しました。以下がイテレーション3で実施した内容のまとめです：

1. **回転状態の管理**
   - rotation プロパティ：0(上)、1(右)、2(下)、3(左) の 4 状態で管理
   - 回転状態に応じた 2 つ目のぷよの位置計算（offsetX, offsetY 配列使用）

2. **回転メソッドの実装**
   - rotateRight メソッド：時計回りに回転（rotation を +1）
   - rotateLeft メソッド：反時計回りに回転（rotation を +3、つまり -1 と同等）
   - performRotation メソッド：回転処理と壁キック処理を統合

3. **壁キック処理**
   - 回転後に 2 つ目のぷよが壁外に出る場合、軸ぷよの位置を自動調整
   - 左壁キック：nextX < 0 のとき puyoX を +1
   - 右壁キック：nextX >= stageCols のとき puyoX を -1

4. **2 つ目のぷよを考慮した移動制限**
   - moveLeft/moveRight の改善：回転状態に応じて 2 つ目のぷよの位置も計算
   - 軸ぷよと 2 つ目のぷよの両方が範囲内にある場合のみ移動可能

5. **描画の更新**
   - draw メソッドで回転状態に応じた 2 つ目のぷよの描画
   - 軸ぷよと 2 つ目のぷよを両方描画

6. **キー入力の統合**
   - update メソッドで上キー(inputKeyUp)による回転処理
   - 回転後フラグをクリア

7. **テストの作成**
   - 回転機能のテスト（3 テスト）
     - 時計回りに回転すると回転状態が 1 増える
     - 反時計回りに回転すると回転状態が 1 減る
     - 回転状態が 4 になると 0 に戻る
   - 壁キック処理のテスト（3 テスト）
     - 左壁際で回転すると右にキックする
     - 右壁際で右向き回転時に左にキックする
     - 左壁際で左向き状態から回転すると右にキックする
   - 横向き移動制限のテスト（2 テスト）
     - 横向き（右）の状態で右端にいる場合、右に移動できない
     - 横向き（左）の状態で左端にいる場合、左に移動できない
   - 合計 18 テストすべて成功

8. **TDD サイクルの実践**
   - Red: 回転・壁キック・移動制限のテストを先に作成し失敗を確認
   - Green: 各機能を実装してテストを通過
   - Refactor: performRotation メソッドへの共通処理抽出

9. **学んだ重要な概念**
   - 4 方向状態管理：配列インデックスによる効率的な座標オフセット計算
   - 壁キック：ユーザビリティ向上のための位置自動調整
   - 複合的な衝突判定：軸ぷよと 2 つ目のぷよ両方の位置チェック
   - DRY 原則：重複コードの共通メソッド化（performRotation）

このイテレーションにより、ぷよを自由に回転させながら左右に移動できるようになり、ぷよぷよの基本的な操作性が実現できました。

## イテレーション4: ぷよの自由落下の実装

「回転ができるようになったけど、ぷよぷよって自動で落ちていくよね？」そうですね！ぷよぷよでは、ぷよが一定間隔で自動的に下に落ちていきます。今回は、その「自由落下」機能を実装していきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> システムとしてぷよを自由落下させることができる

「ぷよが自動的に落ちていく」という機能は、ぷよぷよの基本中の基本ですね。プレイヤーが何も操作しなくても、時間とともにぷよが下に落ちていく仕組みを作りましょう。

### TODOリスト

「どんな作業が必要になりますか？」このユーザーストーリーを実現するために、TODO リストを作成してみましょう。

「ぷよを自由落下させる」という機能を実現するためには、以下のようなタスクが必要そうですね：

- 落下タイマーの実装（一定時間ごとに落下処理を実行する仕組み）
- 自動落下処理の実装（タイマーが発火したときにぷよを1マス下に移動する）
- 落下可能判定の実装（下に移動できるかどうかをチェックする）
- 着地処理の実装（ぷよが着地したときの処理）
- ゲームループとの統合（ゲームの更新処理に自由落下を組み込む）

「なるほど、順番に実装していけばいいんですね！」そうです、一つずつ進めていきましょう。テスト駆動開発の流れに沿って、まずはテストから書いていきますよ。

### テスト: 落下タイマー

「最初に何をテストすればいいんでしょうか？」まずは、一定時間ごとに落下処理が実行される仕組みをテストしましょう。

```typescript
// src/tests/player.test.ts（続き）
describe('自由落下', () => {
    beforeEach(() => {
        // 新しいぷよを作成
        player.createNewPuyo()
    })

    it('指定時間が経過すると、ぷよが1マス下に落ちる', () => {
        // 初期位置を記録
        const initialY = player['puyoY']

        // 落下間隔を取得（例: 1000ms = 1秒）
        const dropInterval = 1000

        // ゲームの更新処理を実行（落下間隔分）
        player.update(dropInterval)

        // 位置が1つ下に移動していることを確認
        expect(player['puyoY']).toBe(initialY + 1)
    })

    it('指定時間未満では、ぷよは落ちない', () => {
        // 初期位置を記録
        const initialY = player['puyoY']

        // 落下間隔を取得
        const dropInterval = 1000

        // タイマーを半分だけ進める
        player.update(dropInterval / 2)

        // 位置が変わっていないことを確認
        expect(player['puyoY']).toBe(initialY)
    })

    it('下端に達した場合、それ以上落ちない', () => {
        // 下端の1つ上に配置
        player['puyoY'] = config.stageRows - 1

        // 落下処理を実行
        player.update(1000)

        // 位置が変わっていないことを確認（下端を超えない）
        expect(player['puyoY']).toBe(config.stageRows - 1)
    })
})
```

「テストを書いたら、次は実装ですね！」その通りです。Red（失敗）→ Green（成功）→ Refactor（改善）のサイクルで進めていきましょう。

### 実装: 落下タイマー

```typescript
// src/player.ts（続き）
class Player {
    private dropTimer: number = 0;
    private dropInterval: number = 1000; // 1秒ごとに落下

    // タイマーをリセットする
    resetDropTimer(): void {
        this.dropTimer = 0;
    }

    // 落下間隔を取得する
    getDropInterval(): number {
        return this.dropInterval;
    }

    // ゲームの更新処理
    update(deltaTime: number): void {
        // タイマーを進める
        this.dropTimer += deltaTime;

        // 落下間隔を超えたら落下処理を実行
        if (this.dropTimer >= this.dropInterval) {
            this.applyGravity();
            this.dropTimer = 0; // タイマーをリセット
        }
    }

    // 重力を適用する（ぷよを1マス下に落とす）
    private applyGravity(): void {
        // 下に移動できるかチェック
        if (this.canMoveDown()) {
            this.puyoY += 1;
        } else {
            // 着地した場合の処理（後で実装）
            this.onLanded();
        }
    }

    // 下に移動できるかチェックする
    private canMoveDown(): boolean {
        // 子ぷよの位置も考慮してチェック
        const nextY = this.puyoY + 1;
        const childNextY = this.puyoY + this.childOffsetY + 1;

        // 親ぷよと子ぷよが範囲内かチェック
        if (nextY >= config.stageRows || childNextY >= config.stageRows) {
            return false;
        }

        // フィールドに衝突するかチェック（後で実装）
        // if (this.checkCollision(this.puyoX, nextY) ||
        //     this.checkCollision(this.puyoX + this.childOffsetX, childNextY)) {
        //     return false;
        // }

        return true;
    }

    // 着地したときの処理
    private onLanded(): void {
        // 後で実装
        console.log('ぷよが着地しました');
    }
}
```

「タイマーを使って一定間隔で落下させるんですね！」そうです！この実装では、以下のことを行っています：

1. `dropTimer` でタイマーを管理
2. `update()` メソッドで経過時間を加算
3. 一定間隔（`dropInterval`）を超えたら `applyGravity()` を実行
4. `applyGravity()` で下に移動できるかチェックし、移動またはは着地処理を実行

「でも、`canMoveDown()` の中でフィールドとの衝突チェックがコメントアウトされていますね？」鋭い指摘です！確かに、フィールドに配置されたぷよとの衝突チェックはまだ実装していません。今は基本的な落下の仕組みだけを実装して、フィールドとの衝突チェックは次のステップで追加していきましょう。

### テスト: 着地判定

「ぷよが着地したときの処理もテストしたいです！」いいですね！次は、ぷよが着地したときの振る舞いをテストしましょう。

```typescript
// src/tests/player.test.ts（続き）
describe('着地判定', () => {
    beforeEach(() => {
        player.createNewPuyo();
    });

    it('ぷよが一番下まで落ちたら着地する', () => {
        // ぷよを一番下の1つ上の位置に配置
        player['puyoY'] = config.stageRows - 2;
        player['childOffsetY'] = 1; // 子ぷよは下

        // スパイを設定して着地処理が呼ばれるか確認
        const landedSpy = jest.spyOn(player as any, 'onLanded');

        // 重力を適用
        player['applyGravity']();

        // 着地処理が呼ばれたことを確認
        expect(landedSpy).toHaveBeenCalled();
    });

    it('着地したぷよはフィールドに固定される', () => {
        // ぷよを一番下まで落とす
        player['puyoY'] = config.stageRows - 1;

        // 着地処理を実行
        player['onLanded']();

        // フィールドにぷよが配置されているか確認（後で実装）
        // const field = player.getField();
        // expect(field[player['puyoY']][player['puyoX']]).not.toBe(0);
    });
});
```

### 実装: 着地処理

```typescript
// src/player.ts（続き）
class Player {
    // フィールドの状態を保持する2次元配列
    private field: number[][];

    constructor() {
        // フィールドを初期化（0で埋める）
        this.field = Array.from(
            { length: config.stageRows },
            () => Array(config.stageCols).fill(0)
        );
    }

    // フィールドを取得する
    getField(): number[][] {
        return this.field;
    }

    // 着地したときの処理
    private onLanded(): void {
        // 親ぷよをフィールドに配置
        this.field[this.puyoY][this.puyoX] = this.puyoColor;

        // 子ぷよをフィールドに配置
        const childX = this.puyoX + this.childOffsetX;
        const childY = this.puyoY + this.childOffsetY;
        this.field[childY][childX] = this.childColor;

        // 次のぷよを生成
        this.createNewPuyo();
    }

    // 下に移動できるかチェックする（更新版）
    private canMoveDown(): boolean {
        const nextY = this.puyoY + 1;
        const childNextY = this.puyoY + this.childOffsetY + 1;

        // 範囲外チェック
        if (nextY >= config.stageRows || childNextY >= config.stageRows) {
            return false;
        }

        // フィールドとの衝突チェック
        if (this.field[nextY][this.puyoX] !== 0) {
            return false;
        }

        const childX = this.puyoX + this.childOffsetX;
        if (this.field[childNextY][childX] !== 0) {
            return false;
        }

        return true;
    }
}
```

「着地したらフィールドに配置して、次のぷよを生成するんですね！」そうです！この実装では、以下のことを行っています：

1. `field` でフィールドの状態を管理（0 は空、それ以外はぷよの色）
2. `onLanded()` で親ぷよと子ぷよをフィールドに配置
3. 着地後、`createNewPuyo()` で次のぷよを生成
4. `canMoveDown()` でフィールドとの衝突もチェック

「テストは通りましたか？」はい、これでテストは通るはずです！これでぷよが自動的に落下し、着地したらフィールドに固定される機能が実装できました。

### TODO リストの更新

実装が完了したので、TODO リストを更新しましょう：

- [x] 落下タイマーの実装
- [x] 自動落下処理の実装
- [x] 落下可能判定の実装
- [x] 着地処理の実装
- [ ] ゲームループとの統合

「あとはゲームループとの統合だけですね！」そうです！実際のゲームでは、`update()` メソッドをゲームループから定期的に呼び出す必要があります。これは次のイテレーションで、他の機能と一緒に統合していきましょう。

「自由落下が実装できて、だんだんぷよぷよらしくなってきましたね！」その通りです！次のイテレーションでは、プレイヤーが下キーを押したときに「高速落下」する機能を実装していきます。

### 画面の確認

では、現在の進行状況を確認してみましょう。ぷよは落下しながら回転し左右に動きます。おや？着地したはずなのに次のぷよが出てきませんね？
それに、着地したぷよが回転できて左右に動きますね追加の作業が必要です TODOリストを追加しましょう。

- [ ] ぷよが着地したら固定する
- [ ] ぷよが着地したら次のぷよを出す
- [ ] 着地したぷよの上にぷよが重なる

ぷよの着地、衝突判定は機能しているようですが以下のケースがうまく機能していません。ぷよは個別に重力が働く必要があるようです。

```markdown
   0  1  2  3  4  5
┌──┬──┬──┬──┬──┬──┐ 0
│  │  │  │  │  │  │
├──┼──┼──┼──┼──┼──┤ 1
│  │  │  │  │  │  │
├──┼──┼──┼──┼──┼──┤ 2
│  │  │  │ Y│ B│  │
├──┼──┼──┼──┼──┼──┤ 3
│  │  │  │ Y│  │  │
├──┼──┼──┼──┼──┼──┤ 4
│  │  │  │ Y│  │  │
└──┴──┴──┴──┴──┴──┘

凡例: Y=黄色 B=青色
```

- [ ] 個別のぷよに重力が作用する

### テスト: 重力判定

```typescript
it('個別のぷよに重力が作用する', () => {
    // Y=黄色 B=青色
    // 位置 (3, 9), (3, 10), (3, 11) に黄色（下端から3段積み）
    stage.setPuyo(3, 9, 1)
    stage.setPuyo(3, 10, 1)
    stage.setPuyo(3, 11, 1)
    // 位置 (4, 2) に青色 (浮いている)
    stage.setPuyo(4, 2, 2)

    // 重力を適用
    stage.applyGravity()

    // 青ぷよが1マス落ちていることを確認
    expect(stage.getPuyo(4, 2)).toBe(0)
    expect(stage.getPuyo(4, 3)).toBe(2)
    // 黄色ぷよは変わらない（下端に積み重なっているので動かない）
    expect(stage.getPuyo(3, 9)).toBe(1)
    expect(stage.getPuyo(3, 10)).toBe(1)
    expect(stage.getPuyo(3, 11)).toBe(1)
})
```

### 実装: 重力判定

```typescript
// ステージ上のぷよに重力を適用（1マスずつ落とす）
// 戻り値: 落下したぷよがあれば true
applyGravity(): boolean {
    // フィールドのコピーを作成（移動前の状態を保存）
    const originalField: number[][] = this.field.map((row) => [...row])

    let hasFallen = false

    // 下から上に向かって各列をスキャン（列ごとに処理）
    for (let x = 0; x < this.config.stageCols; x++) {
        for (let y = this.config.stageRows - 2; y >= 0; y--) {
            const color = originalField[y][x]
            if (color > 0) {
                // 元のフィールドで下に空きがあるかチェック
                if (originalField[y + 1][x] === 0) {
                    // 1マス下に移動
                    this.field[y + 1][x] = color
                    this.field[y][x] = 0
                    hasFallen = true
                }
            }
        }
    }

    return hasFallen
}
```

## イテレーション5: ぷよの高速落下の実装

「回転ができるようになったけど、ぷよぷよってもっと早く落とせたよね？」そうですね！ぷよぷよでは、プレイヤーが下キーを押すことで、ぷよを素早く落下させることができます。今回は、その「高速落下」機能を実装していきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、ぷよを素早く落下させることができる

「早く次のぷよを落としたい！」というときに、下キーを押して素早く落下させる機能は、ゲームのテンポを良くするために重要ですね。

### TODOリスト

「どんな作業が必要になりますか？」このユーザーストーリーを実現するために、TODOリストを作成してみましょう。

「ぷよを素早く落下させる」という機能を実現するためには、以下のようなタスクが必要そうですね：

- 下キー入力の検出を実装する（キーボードの下キーが押されたことを検知する）
- 高速落下処理を実装する（下キーが押されているときは落下速度を上げる）
- 落下可能かどうかのチェックを実装する（下に障害物がある場合は落下できないようにする）
- 着地判定を実装する（ぷよが着地したことを検知する）

「なるほど、順番に実装していけばいいんですね！」そうです、一つずつ進めていきましょう。テスト駆動開発の流れに沿って、まずはテストから書いていきますよ。

### テスト: 高速落下

「最初に何をテストすればいいんでしょうか？」まずは、下キーが押されたときに落下速度が上がることと、ぷよが下に移動できるかどうかをテストしましょう。

```typescript
// src/tests/player.test.ts（続き）
describe('高速落下', () => {
    beforeEach(() => {
        // 新しいぷよを作成
        player.createNewPuyo();
    });

    it('下キーが押されていると、落下速度が上がる', () => {
        // 下キーを押す
        document.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown' }));

        // 通常の落下処理
        const normalDropSpeed = 1;
        const fastDropSpeed = player.getDropSpeed();

        // 高速落下の速度が通常より速いことを確認
        expect(fastDropSpeed).toBeGreaterThan(normalDropSpeed);
    });

    it('下に移動できる場合、下に移動する', () => {
        // 初期位置を記録
        const initialY = player['puyoY'];

        // 下に移動
        player.moveDown();

        // 位置が1つ下に移動していることを確認
        expect(player['puyoY']).toBe(initialY + 1);
    });

    it('下に障害物がある場合、下に移動できない', () => {
        // ステージの一番下に移動
        player['puyoY'] = config.stageRows - 1;

        // 下に移動を試みる
        const canMove = player.moveDown();

        // 移動できないことを確認
        expect(canMove).toBe(false);
        expect(player['puyoY']).toBe(config.stageRows - 1);
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、以下の3つのケースを確認しています：

1. 下キーが押されていると、落下速度が通常より速くなるか
2. 通常の状態で下に移動できるか
3. ステージの一番下にいるときに下に移動しようとしても移動できないか

「なるほど、ゲームの端を超えて移動できないようにするんですね！」そうです！ゲームの画面外にぷよが出てしまうと困りますからね。では、このテストが通るように実装していきましょう。

### 実装: 高速落下

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、高速落下の機能を実装していきましょう。

```typescript
// src/player.ts（続き）
getDropSpeed(): number {
    // 下キーが押されていれば高速落下
    return this.inputKeyDown ? 10 : 1;
}

moveDown(): boolean {
    // 下に移動できるかチェック
    if (this.puyoY < this.config.stageRows - 1) {
        this.puyoY++;
        return true;
    }
    return false;
}
```

「シンプルですね！」そうですね。高速落下の処理自体はとてもシンプルです。`getDropSpeed`メソッドでは、下キーが押されているかどうかを確認し、押されていれば通常の10倍の速度で落下するようにしています。また、`moveDown`メソッドでは、ぷよがステージの下端に到達していなければ下に移動できるようにしています。

「なぜ`moveDown`メソッドは`boolean`を返すんですか？」良い質問ですね！`moveDown`メソッドは、ぷよが実際に下に移動できたかどうかを返します。これは、ぷよが着地したかどうかを判定するために使われます。ぷよが下に移動できなかった場合（`false`が返された場合）、それはぷよが着地したことを意味します。

「これでテストは通りましたか？」はい、これでテストは通るはずです！これでぷよを素早く落下させる基本的な機能が実装できました。プレイヤーがキーボードの下キーを押すと、ぷよが素早く落下し、ステージの下端や他のぷよに衝突すると停止するようになりました。

「でも、まだ実際にキー入力に応じて落下速度が変わる処理が実装されていませんよね？」鋭い指摘ですね！確かに、キーが押されたことを検知するフラグと、落下速度を変更するメソッドはできましたが、それらを連携させる部分はまだ実装していません。これは次のイテレーションで、ゲームループの中で処理していきますね。

「なるほど、少しずつ機能を追加していくんですね！」そうです！テスト駆動開発では、小さな機能を一つずつ確実に実装していくことで、複雑なシステムを構築していきます。今回は「ぷよを素早く落下させる」という基本機能を実装しました。次のイテレーションでは、「ぷよを消去する」機能を実装していきましょう！

## イテレーション6: ぷよの消去の実装

「ぷよが落ちてくるようになったけど、ぷよぷよの醍醐味はぷよを消すことですよね？」そうですね！ぷよぷよの最も重要な要素の一つは、同じ色のぷよを4つ以上つなげると消去できる機能です。今回は、その「ぷよの消去」機能を実装していきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、同じ色のぷよを4つ以上つなげると消去できる

「これがぷよぷよの基本ルールですね！」そうです！同じ色のぷよを4つ以上つなげると消去できるというのが、ぷよぷよの基本的なルールです。これを実装することで、ゲームとしての面白さが大きく向上しますね。

### TODOリスト

「どんな作業が必要になりますか？」このユーザーストーリーを実現するために、TODOリストを作成してみましょう。

「ぷよを消去する」という機能を実現するためには、以下のようなタスクが必要そうですね：

- ぷよの接続判定を実装する（隣接する同じ色のぷよを検出する）
- 4つ以上つながったぷよの検出を実装する（消去対象となるぷよのグループを特定する）
- ぷよの消去処理を実装する（消去対象のぷよを実際に消す）
- 消去後の落下処理を実装する（消去された後の空きスペースにぷよが落ちてくる）

「なるほど、順番に実装していけばいいんですね！」そうです、一つずつ進めていきましょう。テスト駆動開発の流れに沿って、まずはテストから書いていきますよ。

### テスト: ぷよの接続判定

「最初に何をテストすればいいんでしょうか？」まずは、ぷよの接続判定をテストしましょう。同じ色のぷよが4つ以上つながっているかどうかを判定する機能が必要です。

```typescript
// src/tests/stage.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { Stage } from '../stage';
import { Config } from '../config';
import { PuyoImage } from '../puyoimage';

describe('ステージ', () => {
    let config: Config;
    let puyoImage: PuyoImage;
    let stage: Stage;

    beforeEach(() => {
        // DOMの準備
        document.body.innerHTML = `
            <div id="stage"></div>
        `;
        config = new Config();
        puyoImage = new PuyoImage(config);
        stage = new Stage(config, puyoImage);
    });

    describe('ぷよの接続判定', () => {
        it('同じ色のぷよが4つつながっていると、消去対象になる', () => {
            // ステージにぷよを配置（1は赤ぷよ）
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 1 1 0 0 0
            // 0 1 1 0 0 0
            stage.setPuyo(1, 10, 1);
            stage.setPuyo(2, 10, 1);
            stage.setPuyo(1, 11, 1);
            stage.setPuyo(2, 11, 1);

            // 消去判定
            const eraseInfo = stage.checkErase();

            // 4つのぷよが消去対象になっていることを確認
            expect(eraseInfo.erasePuyoCount).toBe(4);
            expect(eraseInfo.eraseInfo.length).toBeGreaterThan(0);
        });

        it('異なる色のぷよは消去対象にならない', () => {
            // ステージにぷよを配置（1は赤ぷよ、2は青ぷよ）
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 0 0 0 0 0
            // 0 1 2 0 0 0
            // 0 2 1 0 0 0
            stage.setPuyo(1, 10, 1);
            stage.setPuyo(2, 10, 2);
            stage.setPuyo(1, 11, 2);
            stage.setPuyo(2, 11, 1);

            // 消去判定
            const eraseInfo = stage.checkErase();

            // 消去対象がないことを確認
            expect(eraseInfo.erasePuyoCount).toBe(0);
            expect(eraseInfo.eraseInfo.length).toBe(0);
        });
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、以下の2つのケースを確認しています：

1. 同じ色のぷよが4つつながっている場合、それらが消去対象になるか
2. 異なる色のぷよが隣接している場合、それらは消去対象にならないか

「ステージにぷよを配置しているのはわかりますが、その図はどういう意味ですか？」良い質問ですね！コメントの図は、ステージ上のぷよの配置を視覚的に表現しています。0は空きマス、1は赤ぷよ、2は青ぷよを表しています。最初のテストでは2×2の正方形に赤ぷよを配置し、2つ目のテストでは市松模様に赤と青のぷよを配置しています。

「なるほど、視覚的に確認できるのは便利ですね！」そうですね。では、このテストが通るように実装していきましょう。

### 実装: ぷよの接続判定

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、ぷよの接続判定を実装していきましょう。

```typescript
// src/stage.ts
import { Config } from './config';
import { PuyoImage } from './puyoimage';

export interface EraseInfo {
    erasePuyoCount: number;
    eraseInfo: {
        x: number;
        y: number;
        type: number;
    }[];
}

export class Stage {
    private board: number[][] = [];
    private stageElement: HTMLElement;

    constructor(
        private config: Config,
        private puyoImage: PuyoImage
    ) {
        // ステージ要素の取得
        this.stageElement = document.getElementById('stage')!;

        // ステージの初期化
        this.initialize();
    }

    initialize(): void {
        // ボードの初期化
        this.board = [];
        for (let y = 0; y < this.config.stageRows; y++) {
            this.board[y] = [];
            for (let x = 0; x < this.config.stageCols; x++) {
                this.board[y][x] = 0;
            }
        }
    }

    setPuyo(x: number, y: number, type: number): void {
        // ぷよをボードに設定
        this.board[y][x] = type;
    }

    getPuyo(x: number, y: number): number {
        // ボード外の場合は0（空）を返す
        if (x < 0 || x >= this.config.stageCols || y < 0 || y >= this.config.stageRows) {
            return 0;
        }
        return this.board[y][x];
    }

    checkErase(): EraseInfo {
        // 消去情報
        const eraseInfo: EraseInfo = {
            erasePuyoCount: 0,
            eraseInfo: []
        };

        // 一時的なチェック用ボード
        const checked: boolean[][] = [];
        for (let y = 0; y < this.config.stageRows; y++) {
            checked[y] = [];
            for (let x = 0; x < this.config.stageCols; x++) {
                checked[y][x] = false;
            }
        }

        // 全マスをチェック
        for (let y = 0; y < this.config.stageRows; y++) {
            for (let x = 0; x < this.config.stageCols; x++) {
                // ぷよがあり、まだチェックしていない場合
                if (this.board[y][x] !== 0 && !checked[y][x]) {
                    // 接続しているぷよを探索
                    const puyoType = this.board[y][x];
                    const connected: {x: number, y: number}[] = [];
                    this.searchConnectedPuyo(x, y, puyoType, checked, connected);

                    // 4つ以上つながっている場合は消去対象
                    if (connected.length >= 4) {
                        for (const puyo of connected) {
                            eraseInfo.eraseInfo.push({
                                x: puyo.x,
                                y: puyo.y,
                                type: puyoType
                            });
                        }
                        eraseInfo.erasePuyoCount += connected.length;
                    }
                }
            }
        }

        return eraseInfo;
    }

    private searchConnectedPuyo(
        startX: number,
        startY: number,
        puyoType: number,
        checked: boolean[][],
        connected: {x: number, y: number}[]
    ): void {
        // 探索済みにする
        checked[startY][startX] = true;
        connected.push({x: startX, y: startY});

        // 4方向を探索
        const directions = [
            {dx: 1, dy: 0},  // 右
            {dx: -1, dy: 0}, // 左
            {dx: 0, dy: 1},  // 下
            {dx: 0, dy: -1}  // 上
        ];

        for (const direction of directions) {
            const nextX = startX + direction.dx;
            const nextY = startY + direction.dy;

            // ボード内かつ同じ色のぷよがあり、まだチェックしていない場合
            if (
                nextX >= 0 && nextX < this.config.stageCols &&
                nextY >= 0 && nextY < this.config.stageRows &&
                this.board[nextY][nextX] === puyoType &&
                !checked[nextY][nextX]
            ) {
                // 再帰的に探索
                this.searchConnectedPuyo(nextX, nextY, puyoType, checked, connected);
            }
        }
    }
}
```

### 解説: ぷよの接続判定

ぷよの接続判定では、以下のことを行っています。

1. ボード上の全マスを順番にチェック
2. まだチェックしていないぷよがある場合、そのぷよと同じ色で接続しているぷよを探索
3. 接続しているぷよが4つ以上ある場合、それらを消去対象として記録

接続しているぷよの探索には[深さ優先探索（DFS）アルゴリズム](https://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2)を使用しています。このアルゴリズムでは、あるぷよから始めて、上下左右に隣接する同じ色のぷよを再帰的に探索していきます。探索済みのぷよは`checked`配列でマークし、重複してカウントしないようにしています。

### テスト: ぷよの消去と落下

次に、ぷよの消去と落下処理をテストします。

```typescript
// src/tests/stage.test.ts（続き）
describe('ぷよの消去と落下', () => {
    it('消去対象のぷよを消去する', () => {
        // ステージにぷよを配置
        stage.setPuyo(1, 10, 1);
        stage.setPuyo(2, 10, 1);
        stage.setPuyo(1, 11, 1);
        stage.setPuyo(2, 11, 1);

        // 消去判定
        const eraseInfo = stage.checkErase();

        // 消去実行
        stage.eraseBoards(eraseInfo.eraseInfo);

        // ぷよが消去されていることを確認
        expect(stage.getPuyo(1, 10)).toBe(0);
        expect(stage.getPuyo(2, 10)).toBe(0);
        expect(stage.getPuyo(1, 11)).toBe(0);
        expect(stage.getPuyo(2, 11)).toBe(0);
    });

    it('消去後、上にあるぷよが落下する', () => {
        // ステージにぷよを配置
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 2 0 0 0
        // 0 0 2 0 0 0
        // 0 1 1 0 0 0
        // 0 1 1 0 0 0
        stage.setPuyo(1, 10, 1);
        stage.setPuyo(2, 10, 1);
        stage.setPuyo(1, 11, 1);
        stage.setPuyo(2, 11, 1);
        stage.setPuyo(2, 8, 2);
        stage.setPuyo(2, 9, 2);

        // 消去判定と実行
        const eraseInfo = stage.checkErase();
        stage.eraseBoards(eraseInfo.eraseInfo);

        // 落下処理
        stage.fall();

        // 上にあったぷよが落下していることを確認
        expect(stage.getPuyo(2, 10)).toBe(2);
        expect(stage.getPuyo(2, 11)).toBe(2);
    });
});
```

このテストでは、消去対象のぷよが正しく消去されることと、消去後に上にあるぷよが落下することをテストしています。

### 実装: ぷよの消去と落下

テストが失敗することを確認したら、テストが通るように最小限のコードを実装します。

```typescript
// src/stage.ts（続き）
eraseBoards(eraseInfo: {x: number, y: number, type: number}[]): void {
    // 消去対象のぷよを消去
    for (const info of eraseInfo) {
        this.board[info.y][info.x] = 0;
    }
}

fall(): void {
    // 下から上に向かって処理
    for (let y = this.config.stageRows - 2; y >= 0; y--) {
        for (let x = 0; x < this.config.stageCols; x++) {
            if (this.board[y][x] !== 0) {
                // 現在のぷよの下が空いている場合、落下させる
                let fallY = y;
                while (fallY + 1 < this.config.stageRows && this.board[fallY + 1][x] === 0) {
                    this.board[fallY + 1][x] = this.board[fallY][x];
                    this.board[fallY][x] = 0;
                    fallY++;
                }
            }
        }
    }
}
```

### 解説: ぷよの消去と落下

ぷよの消去と落下処理では、以下のことを行っています。

1. 消去対象のぷよをボード上から消去する`eraseBoards`メソッドを実装
2. 消去後に上にあるぷよを落下させる`fall`メソッドを実装

落下処理では、下から上に向かって各列を処理し、ぷよがある場合はその下が空いていれば落下させます。これを繰り返すことで、すべてのぷよが適切な位置に落下します。

## イテレーション7: 連鎖反応の実装

「ぷよを消せるようになったけど、ぷよぷよの醍醐味は連鎖じゃないですか？」そうですね！ぷよぷよの最も魅力的な要素の一つは、連鎖反応です。ぷよが消えて落下した結果、新たな消去パターンが生まれ、連続して消去が発生する「連鎖」を実装していきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、連鎖反応を起こしてより高いスコアを獲得できる

「れ〜んさ〜ん！」と叫びたくなるような連鎖反応を実装して、プレイヤーがより高いスコアを目指せるようにしましょう。

### TODOリスト

「どんな作業が必要になりますか？」このユーザーストーリーを実現するために、TODOリストを作成してみましょう。

「連鎖反応を実装する」という機能を実現するためには、以下のようなタスクが必要そうですね：

- 連鎖判定を実装する（ぷよが消えた後に新たな消去パターンがあるかを判定する）
- 連鎖カウントを実装する（何連鎖目かをカウントする）
- 連鎖ボーナスの計算を実装する（連鎖数に応じたボーナス点を計算する）
- スコア表示を実装する（プレイヤーに現在のスコアを表示する）

「なるほど、順番に実装していけばいいんですね！」そうです、一つずつ進めていきましょう。テスト駆動開発の流れに沿って、まずはテストから書いていきますよ。

### テスト: 連鎖判定

「最初に何をテストすればいいんでしょうか？」まずは、連鎖判定をテストしましょう。ぷよが消えて落下した後に、新たな消去パターンが発生するかどうかを判定する機能が必要です。

```typescript
// src/tests/game.test.ts（続き）
describe('連鎖反応', () => {
    beforeEach(() => {
        game.initialize();
    });

    it('ぷよの消去と落下後、新たな消去パターンがあれば連鎖が発生する', () => {
        // ゲームのステージにぷよを配置
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 0 0 0 0
        // 0 0 2 0 0 0
        // 0 0 2 0 0 0
        // 0 0 2 0 0 0
        // 0 1 1 2 0 0
        // 0 1 1 0 0 0
        const stage = game['stage'];
        stage.setPuyo(1, 10, 1);
        stage.setPuyo(2, 10, 1);
        stage.setPuyo(1, 11, 1);
        stage.setPuyo(2, 11, 1);
        stage.setPuyo(3, 10, 2);
        stage.setPuyo(2, 7, 2);
        stage.setPuyo(2, 8, 2);
        stage.setPuyo(2, 9, 2);

        // 消去判定
        const eraseInfo = stage.checkErase();

        // 消去実行
        stage.eraseBoards(eraseInfo.eraseInfo);

        // 落下処理
        stage.fall();

        // 連鎖判定
        const chainEraseInfo = stage.checkErase();

        // 連鎖が発生していることを確認
        expect(chainEraseInfo.erasePuyoCount).toBeGreaterThan(0);
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、以下のシナリオを確認しています：

1. まず、特定のパターンでぷよを配置します（赤ぷよの2×2の正方形と、その上に青ぷよが縦に3つ並んでいる状態）
2. 最初の消去判定で赤ぷよの正方形が消えます
3. 消去後に落下処理を行うと、上にあった青ぷよが落下します
4. 落下した結果、新たに青ぷよが4つつながり、連鎖が発生することを確認します

「なるほど、連鎖の仕組みがテストで表現されているんですね！」そうです！このテストは、ぷよぷよの連鎖の基本的な仕組みを表現しています。では、このテストが通るように実装していきましょう。

### 実装: 連鎖判定

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、連鎖判定を実装していきましょう。

```typescript
// src/game.ts（続き）
loop(): void {
    // フレームカウントを更新
    this.frame++;

    // ゲームの状態に応じた処理
    switch (this.mode) {
        case 'start':
            // ゲーム開始時の処理
            this.mode = 'checkFall';
            break;

        case 'checkFall':
            // 落下判定
            if (this.stage.checkFall()) {
                this.mode = 'fall';
            } else {
                this.mode = 'checkErase';
            }
            break;

        case 'fall':
            // 落下処理
            if (!this.stage.fall()) {
                this.mode = 'checkErase';
            }
            break;

        case 'checkErase':
            // 消去判定
            const eraseInfo = this.stage.checkErase();
            if (eraseInfo.erasePuyoCount > 0) {
                this.mode = 'erasing';
                this.combinationCount++;
                // スコア計算
                this.score.addScore(eraseInfo.erasePuyoCount, this.combinationCount);
            } else {
                if (this.combinationCount > 0) {
                    // 連鎖が終了
                    this.combinationCount = 0;
                }
                this.mode = 'newPuyo';
            }
            break;

        case 'erasing':
            // 消去処理
            if (this.frame % 10 === 0) {
                const eraseInfo = this.stage.checkErase();
                this.stage.eraseBoards(eraseInfo.eraseInfo);
                this.mode = 'checkFall';
            }
            break;

        case 'newPuyo':
            // 新しいぷよの生成
            this.player.createNewPuyo();
            this.mode = 'playing';
            break;

        case 'playing':
            // プレイヤーの操作
            this.player.control();
            break;

        case 'gameOver':
            // ゲームオーバー処理
            break;
    }

    // 画面の更新
    this.stage.draw();
    this.player.draw();
    this.score.draw();

    // 次のフレームの処理を予約
    requestAnimationFrame(this.loop.bind(this));
}
```

### 解説: 連鎖判定

連鎖判定では、以下のことを行っています。

1. ゲームループ内で状態遷移を管理
2. 落下判定（`checkFall`）→落下処理（`fall`）→消去判定（`checkErase`）→消去処理（`erasing`）の流れを実装
3. 消去処理後に再度落下判定を行い、新たな消去パターンがあれば連鎖としてカウント

ゲームの状態は`mode`プロパティで管理され、各状態に応じた処理が実行されます。連鎖数は`combinationCount`プロパティでカウントされ、消去が発生するたびに増加します。連鎖が終了すると（消去判定で消去対象がない場合）、連鎖数はリセットされます。

### テスト: スコア計算

次に、連鎖ボーナスを含むスコア計算をテストします。

```typescript
// src/tests/score.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { Score } from '../score';

describe('スコア', () => {
    let score: Score;

    beforeEach(() => {
        // DOMの準備
        document.body.innerHTML = `
            <div id="score">0</div>
        `;
        score = new Score();
    });

    describe('スコア計算', () => {
        it('ぷよを消去するとスコアが加算される', () => {
            // 4つのぷよを消去
            score.addScore(4, 1);

            // スコアが加算されていることを確認
            expect(score.getScore()).toBeGreaterThan(0);
        });

        it('連鎖数が増えるとボーナスが加算される', () => {
            // 1連鎖目のスコア
            score.addScore(4, 1);
            const score1 = score.getScore();

            // スコアをリセット
            score.reset();

            // 2連鎖目のスコア
            score.addScore(4, 2);
            const score2 = score.getScore();

            // 2連鎖目のスコアが1連鎖目より大きいことを確認
            expect(score2).toBeGreaterThan(score1);
        });
    });
});
```

このテストでは、ぷよの消去によるスコア加算と、連鎖数に応じたボーナス加算をテストしています。

### 実装: スコア計算

テストが失敗することを確認したら、テストが通るように最小限のコードを実装します。

```typescript
// src/score.ts
export class Score {
    private score: number = 0;
    private scoreElement: HTMLElement;

    constructor() {
        // スコア表示要素の取得
        this.scoreElement = document.getElementById('score')!;
    }

    addScore(erasePuyoCount: number, combinationCount: number): void {
        // 基本点（消去したぷよの数 × 10）
        let baseScore = erasePuyoCount * 10;

        // 連鎖ボーナス（連鎖数が増えるほど大きくなる）
        const chainBonus = this.getChainBonus(combinationCount);

        // 最終スコア
        const additionalScore = baseScore * chainBonus;
        this.score += additionalScore;

        // スコア表示の更新
        this.draw();
    }

    getScore(): number {
        return this.score;
    }

    reset(): void {
        this.score = 0;
        this.draw();
    }

    draw(): void {
        // スコアを表示
        this.scoreElement.textContent = this.score.toString();
    }

    private getChainBonus(combinationCount: number): number {
        // 連鎖ボーナステーブル
        const bonusTable = [
            1,    // 1連鎖
            8,    // 2連鎖
            16,   // 3連鎖
            32,   // 4連鎖
            64,   // 5連鎖
            96,   // 6連鎖
            128,  // 7連鎖
            160,  // 8連鎖
            192,  // 9連鎖
            224,  // 10連鎖
            256,  // 11連鎖以上
        ];

        return bonusTable[Math.min(combinationCount - 1, bonusTable.length - 1)];
    }
}
```

### 解説: スコア計算

スコア計算では、以下のことを行っています。

1. 基本点の計算（消去したぷよの数 × 10）
2. 連鎖ボーナスの計算（連鎖数に応じたボーナス倍率）
3. 最終スコアの計算と加算
4. スコア表示の更新

連鎖ボーナスは連鎖数に応じて大きくなり、連鎖が続くほど高いスコアを獲得できます。これにより、プレイヤーは単にぷよを消すだけでなく、連鎖を狙った配置を考えるようになります。

## イテレーション8: 全消しボーナスの実装

「連鎖ができるようになったけど、ぷよぷよには全消しボーナスもありますよね？」そうですね！ぷよぷよには、盤面上のぷよをすべて消すと得られる「全消し（ぜんけし）ボーナス」という特別な報酬があります。今回は、その全消しボーナスを実装していきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、全消し（ぜんけし）ボーナスを獲得できる

「やった！全部消えた！」という達成感と共に、特別なボーナスポイントを獲得できる機能を実装します。これにより、プレイヤーは全消しを狙った戦略を考えるようになりますね。

### TODOリスト

「どんな作業が必要になりますか？」このユーザーストーリーを実現するために、TODOリストを作成してみましょう。

「全消しボーナスを実装する」という機能を実現するためには、以下のようなタスクが必要そうですね：

- 全消し判定を実装する（盤面上のぷよがすべて消えたかどうかを判定する）
- 全消しボーナスの計算を実装する（全消し時に加算するボーナス点を計算する）
- 全消し演出を実装する（全消し時に特別な演出を表示する）

「なるほど、順番に実装していけばいいんですね！」そうです、一つずつ進めていきましょう。テスト駆動開発の流れに沿って、まずはテストから書いていきますよ。

### テスト: 全消し判定

「最初に何をテストすればいいんでしょうか？」まずは、全消し判定をテストしましょう。盤面上のぷよがすべて消えたかどうかを判定する機能が必要です。

```typescript
// src/tests/stage.test.ts（続き）
describe('全消し判定', () => {
    it('盤面上のぷよがすべて消えると全消しになる', () => {
        // ステージにぷよを配置
        stage.setPuyo(1, 10, 1);
        stage.setPuyo(2, 10, 1);
        stage.setPuyo(1, 11, 1);
        stage.setPuyo(2, 11, 1);

        // 消去判定と実行
        const eraseInfo = stage.checkErase();
        stage.eraseBoards(eraseInfo.eraseInfo);

        // 全消し判定
        const isZenkeshi = stage.checkZenkeshi();

        // 全消しになっていることを確認
        expect(isZenkeshi).toBe(true);
    });

    it('盤面上にぷよが残っていると全消しにならない', () => {
        // ステージにぷよを配置
        stage.setPuyo(1, 10, 1);
        stage.setPuyo(2, 10, 1);
        stage.setPuyo(1, 11, 1);
        stage.setPuyo(2, 11, 1);
        stage.setPuyo(3, 11, 2); // 消えないぷよ

        // 消去判定と実行
        const eraseInfo = stage.checkErase();
        stage.eraseBoards(eraseInfo.eraseInfo);

        // 全消し判定
        const isZenkeshi = stage.checkZenkeshi();

        // 全消しになっていないことを確認
        expect(isZenkeshi).toBe(false);
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、以下の2つのケースを確認しています：

1. 盤面上のぷよがすべて消えた場合、全消しと判定されるか
2. 盤面上にぷよが残っている場合、全消しと判定されないか

「最初のテストでは、2×2の正方形に赤ぷよを配置して、それらが消えた後に全消しになるんですね？」そうです！最初のテストでは、2×2の正方形に赤ぷよを配置し、それらが消去された後に盤面が空になるので、全消しと判定されるはずです。

「2つ目のテストでは、消えないぷよが残るようにしているんですね？」その通りです！2つ目のテストでは、2×2の正方形に赤ぷよを配置した上で、別の場所に青ぷよを1つ配置しています。赤ぷよは消えますが、青ぷよは消えないので、全消しにはならないはずです。

「なるほど、全消し判定の条件がよく分かりますね！」では、このテストが通るように実装していきましょう。

### 実装: 全消し判定

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、全消し判定を実装していきましょう。

```typescript
// src/stage.ts（続き）
checkZenkeshi(): boolean {
    // 盤面上にぷよがあるかチェック
    for (let y = 0; y < this.config.stageRows; y++) {
        for (let x = 0; x < this.config.stageCols; x++) {
            if (this.board[y][x] !== 0) {
                return false;
            }
        }
    }
    return true;
}
```

「シンプルですね！」そうですね。全消し判定の実装自体はとてもシンプルです。盤面上のすべてのマスを順番にチェックし、ぷよがある（値が0でない）マスが見つかった時点で`false`を返します。すべてのマスをチェックして、ぷよが見つからなければ`true`を返します。

「二重ループを使って、すべてのマスをチェックしているんですね！」その通りです！外側のループで行（y座標）を、内側のループで列（x座標）を順番にチェックしています。これにより、盤面上のすべてのマスを効率的にチェックできます。

### 解説: 全消し判定

全消し判定では、以下のことを行っています：

1. 盤面上のすべてのマスをチェック
2. ぷよがある（値が0でない）マスがあれば全消しではない
3. すべてのマスが空（値が0）であれば全消し

「全消し判定はいつ行われるんですか？」良い質問ですね！全消し判定は、ぷよの消去処理後に行われます。ぷよが消えた後、盤面上にぷよが残っていないかをチェックするんです。

「テストは通りましたか？」はい、これでテストは通るはずです！次は、全消しボーナスの計算を実装していきましょう。

### テスト: 全消しボーナス

「全消しボーナスはどのようにテストすればいいですか？」全消しボーナスは、全消し時に特別なボーナス点が加算されることをテストする必要があります。

```typescript
// src/tests/score.test.ts（続き）
describe('全消しボーナス', () => {
    it('全消しするとボーナスが加算される', () => {
        // 通常のスコア加算
        score.addScore(4, 1);
        const normalScore = score.getScore();

        // 全消しボーナス加算
        score.addZenkeshiBonus();

        // 全消しボーナスが加算されていることを確認
        expect(score.getScore()).toBeGreaterThan(normalScore);
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、全消しボーナスが加算されると、スコアが増加することを確認しています。具体的には：

1. まず通常のスコア加算を行い、現在のスコアを記録します
2. 次に全消しボーナスを加算します
3. 最後に、スコアが増加していることを確認します

このテストでは、全消しボーナスが正しく加算されることをテストしています。

### 実装: 全消しボーナス

テストが失敗することを確認したら、テストが通るように最小限のコードを実装します。

```typescript
// src/score.ts（続き）
addZenkeshiBonus(): void {
    // 全消しボーナス（固定値）
    const zenkeshiBonus = 3600;
    this.score += zenkeshiBonus;

    // スコア表示の更新
    this.draw();
}
```

### 解説: 全消しボーナス

全消しボーナスでは、以下のことを行っています。

1. 全消しボーナスの計算（固定値3600点）
2. スコアへの加算
3. スコア表示の更新

全消しボーナスは、盤面上のぷよをすべて消去した場合に加算される特別なボーナスです。これにより、プレイヤーは全消しを狙った戦略を考えるようになります。

## イテレーション9: ゲームオーバーの実装

「全消しボーナスまで実装できましたが、ゲームが終わる条件も必要ですよね？」そうですね！どんなゲームにも終わりがあります。ぷよぷよでは、新しいぷよを配置できなくなったときにゲームオーバーとなります。今回は、そのゲームオーバー判定と演出を実装していきましょう！

### ユーザーストーリー

まずは、このイテレーションで実装するユーザーストーリーを確認しましょう：

> プレイヤーとして、ゲームオーバーになるとゲーム終了の演出を見ることができる

「ゲームが終わったことが明確に分かるといいですね！」そうですね。ゲームの終わりが明確でないと、プレイヤーはモヤモヤした気持ちになってしまいます。ゲームオーバーになったことを明確に伝え、適切な演出を行うことで、プレイヤーに達成感や次回への意欲を持ってもらうことができます。

### TODOリスト

「どんな作業が必要になりますか？」このユーザーストーリーを実現するために、TODOリストを作成してみましょう。

「ゲームオーバーを実装する」という機能を実現するためには、以下のようなタスクが必要そうですね：

- ゲームオーバー判定を実装する（新しいぷよを配置できない状態を検出する）
- ゲームオーバー演出を実装する（ゲームオーバー時に特別な表示や効果を追加する）
- リスタート機能を実装する（ゲームオーバー後に新しいゲームを始められるようにする）

「なるほど、順番に実装していけばいいんですね！」そうです、一つずつ進めていきましょう。テスト駆動開発の流れに沿って、まずはテストから書いていきますよ。

### テスト: ゲームオーバー判定

「最初に何をテストすればいいんでしょうか？」まずは、ゲームオーバー判定をテストしましょう。新しいぷよを配置できない状態を検出する機能が必要です。

```typescript
// src/tests/game.test.ts（続き）
describe('ゲームオーバー', () => {
    beforeEach(() => {
        game.initialize();
    });

    it('新しいぷよを配置できない場合、ゲームオーバーになる', () => {
        // ステージの上部にぷよを配置
        const stage = game['stage'];
        stage.setPuyo(2, 0, 1);
        stage.setPuyo(2, 1, 1);

        // 新しいぷよの生成（通常は中央上部に配置される）
        game['player'].createNewPuyo();

        // ゲームオーバー判定
        const isGameOver = game['player'].checkGameOver();

        // ゲームオーバーになっていることを確認
        expect(isGameOver).toBe(true);
    });
});
```

「このテストでは何を確認しているんですか？」このテストでは、新しいぷよを配置できない状態がゲームオーバーと判定されるかを確認しています。具体的には：

1. ステージの上部（新しいぷよが配置される位置）にぷよを配置します
2. 新しいぷよを生成します
3. ゲームオーバー判定を行い、ゲームオーバーになっていることを確認します

「なるほど、新しいぷよの配置位置にすでにぷよがあると、ゲームオーバーになるんですね！」そうです！ぷよぷよでは、新しいぷよを配置する位置（通常はステージの中央上部）にすでにぷよがある場合、これ以上ゲームを続行できないため、ゲームオーバーとなります。では、このテストが通るように実装していきましょう。

### 実装: ゲームオーバー判定

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、ゲームオーバー判定を実装していきましょう。

```typescript
// src/player.ts（続き）
checkGameOver(): boolean {
    // 新しいぷよの配置位置（中央上部）
    const x = Math.floor(this.config.stageCols / 2) - 1;
    const y = 0;

    // 配置位置にすでにぷよがある場合はゲームオーバー
    return this.stage.getPuyo(x, y) !== 0 || this.stage.getPuyo(x + 1, y) !== 0;
}
```

「シンプルですね！」そうですね。ゲームオーバー判定の実装自体はとてもシンプルです。新しいぷよの配置位置（中央上部）を計算し、その位置にすでにぷよがあるかどうかをチェックしています。

「`x + 1`もチェックしているのはなぜですか？」良い質問ですね！ぷよぷよでは、新しいぷよは2つ連なった状態で登場します。通常、1つは中央（x）に、もう1つはその右隣（x + 1）に配置されます。そのため、どちらかの位置にすでにぷよがある場合は、新しいぷよを配置できないと判断します。

### 解説: ゲームオーバー判定

ゲームオーバー判定では、以下のことを行っています：

1. 新しいぷよの配置位置（中央上部）を確認
2. その位置にすでにぷよがある場合、ゲームオーバーと判定

「ゲームオーバー判定はいつ行われるんですか？」良い質問ですね！ゲームオーバー判定は、新しいぷよを生成するタイミングで行われます。新しいぷよを生成しようとしたときに、配置位置にすでにぷよがあれば、ゲームオーバーとなります。

「テストは通りましたか？」はい、これでテストは通るはずです！次は、ゲームオーバー演出を実装していきましょう。

### テスト: ゲームオーバー演出

「ゲームオーバー演出はどのようにテストすればいいですか？」ゲームオーバー演出は、ゲームの状態（モード）が変わることをテストするといいでしょう。

```typescript
// src/tests/game.test.ts（続き）
it('ゲームオーバーになると、ゲームモードがgameOverに変わる', () => {
    // ステージの上部にぷよを配置
    const stage = game['stage'];
    stage.setPuyo(2, 0, 1);
    stage.setPuyo(2, 1, 1);

    // ゲームモードを設定
    game['mode'] = 'newPuyo';

    // ゲームループを実行
    game.loop();

    // ゲームモードがgameOverになっていることを確認
    expect(game['mode']).toBe('gameOver');
});
```

「このテストでは何を確認しているんですか？」このテストでは、ゲームオーバー条件が満たされた場合に、ゲームの状態（モード）が`gameOver`に変わることを確認しています。具体的には：

1. ステージの上部にぷよを配置して、ゲームオーバー条件を作ります
2. ゲームモードを`newPuyo`（新しいぷよを生成するモード）に設定します
3. ゲームループを実行します
4. ゲームモードが`gameOver`に変わっていることを確認します

「なるほど、ゲームの状態遷移をテストしているんですね！」そうです！ゲームオーバーになると、ゲームの状態が変わり、それに応じた演出が行われるようになります。では、このテストが通るように実装していきましょう。

### 実装: ゲームオーバー演出

「テストが失敗することを確認したら、実装に進みましょう！」そうですね。では、ゲームオーバー演出を実装していきましょう。

```typescript
// src/game.ts（続き）
loop(): void {
    // フレームカウントを更新
    this.frame++;

    // ゲームの状態に応じた処理
    switch (this.mode) {
        // 省略...

        case 'newPuyo':
            // 新しいぷよの生成
            this.player.createNewPuyo();

            // ゲームオーバー判定
            if (this.player.checkGameOver()) {
                this.mode = 'gameOver';
            } else {
                this.mode = 'playing';
            }
            break;

        case 'playing':
            // プレイヤーの操作
            this.player.control();
            break;

        case 'gameOver':
            // ゲームオーバー演出
            this.drawGameOver();
            break;
    }

    // 画面の更新
    this.stage.draw();
    this.player.draw();
    this.score.draw();

    // 次のフレームの処理を予約
    requestAnimationFrame(this.loop.bind(this));
}

private drawGameOver(): void {
    // ゲームオーバー表示
    const stageElement = document.getElementById('stage')!;
    const gameOverElement = document.createElement('div');
    gameOverElement.id = 'gameOver';
    gameOverElement.textContent = 'GAME OVER';
    gameOverElement.style.position = 'absolute';
    gameOverElement.style.top = '50%';
    gameOverElement.style.left = '50%';
    gameOverElement.style.transform = 'translate(-50%, -50%)';
    gameOverElement.style.color = 'red';
    gameOverElement.style.fontSize = '36px';
    gameOverElement.style.fontWeight = 'bold';

    // すでにゲームオーバー表示がある場合は追加しない
    if (!document.getElementById('gameOver')) {
        stageElement.appendChild(gameOverElement);
    }
}
```

### 解説: ゲームオーバー演出

ゲームオーバー演出では、以下のことを行っています。

1. ゲームループ内でゲームオーバー判定を行い、条件が満たされた場合はゲームモードを`gameOver`に変更
2. `gameOver`モードでは、ゲームオーバー表示を画面に追加

ゲームオーバー表示は、ステージの中央に「GAME OVER」というテキストを表示します。これにより、プレイヤーはゲームが終了したことを視覚的に認識できます。

## ふりかえり

ぷよぷよゲームの実装を完了することができたので、これまでのふりかえりをしておきましょう。

### Keep（続けること）

まず **TODOリスト** を作成して **テストファースト** で１つずつ小さなステップで開発を進めていきました。テスト駆動開発の「Red-Green-Refactor」サイクルに従うことで、コードの品質を保ちながら、段階的に機能を追加していくことができました。

各章では、ユーザーストーリーに基づいた機能を、テスト、実装、解説の順に進めていきました。この流れは非常に効果的で、実装の方針が明確になり、必要最小限のコードで機能を実現することができました。

特に以下の点は今後も続けていきたいプラクティスです：

1. ユーザーストーリーからTODOリストへの分解
2. テストファーストの原則に従った実装
3. 小さなステップでの開発
4. リファクタリングによるコードの継続的な改善

### Problem（課題）

開発を進める中で、いくつかの課題も見えてきました。

まず、テストの粒度をどの程度にするかという判断が難しい場面がありました。細かすぎるテストは冗長になり、大きすぎるテストは問題の特定が難しくなります。

また、リファクタリングのタイミングも課題でした。機能追加とリファクタリングのバランスをどう取るか、特に初期段階でのリファクタリングの重要性と、後回しにすることのリスクを実感しました。

ゲームロジックの複雑さが増すにつれて、テストの維持も難しくなりました。特に、ゲームの状態遷移や重力処理のテストは工夫が必要でした。

### Try（挑戦）

今後は以下のことに挑戦していきたいと思います：

1. より効率的なテスト戦略の模索 - ユニットテストとインテグレーションテストのバランスを考慮する
2. 自動化テストのカバレッジを高める工夫
3. より複雑なゲーム機能（マルチプレイヤー、ネットワーク対戦など）への挑戦
4. パフォーマンス最適化とそのテスト手法の習得

これらの知識と経験は、他のプロジェクトにも応用できるものです。テスト駆動開発は、コードの品質を高め、保守性を向上させるための強力な手法です。ぜひ、自分のプロジェクトにも取り入れてみてください。

> 私がかつて発見した、そして多くの人に気づいてもらいたい効果とは、反復可能な振る舞いを規則にまで還元することで、規則の適用は機会的に反復可能になるということだ。
>
> — Kent Beck 『テスト駆動開発』

## アーキテクチャ図解

実装したぷよぷよゲームのアーキテクチャを視覚的に理解するために、状態遷移図、クラス図、シーケンス図を示します。

### 状態遷移図

ゲームの状態（モード）遷移を示します。

```plantuml
@startuml
title ゲームモード状態遷移図

[*] --> start : ゲーム開始

start --> newPuyo : 初期化完了

newPuyo --> playing : ぷよ配置可能
newPuyo --> gameOver : ぷよ配置不可

playing --> checkFall : ぷよ着地

checkFall --> checkFall : 落下中
checkFall --> checkErase : 落下完了

checkErase --> erasing : 消去あり
checkErase --> newPuyo : 消去なし\n(全消し判定)

erasing --> checkFall : 消去完了\n(連鎖判定)

gameOver --> [*] : ゲーム終了

note right of newPuyo
  新しいぷよを生成し
  配置可能かチェック
end note

note right of checkFall
  重力適用
  全ぷよが落下完了まで
  繰り返す
end note

note right of checkErase
  4個以上の同色判定
  全消し判定
  連鎖カウント更新
end note

note right of erasing
  消去後は必ず
  checkFallに戻り
  連鎖をチェック
end note

@enduml
```

### クラス図

各クラスの責務と関係性を示します。

```plantuml
@startuml
title クラス図

class Game {
  - mode: GameMode
  - frame: number
  - combinationCount: number
  - maxChainCount: number
  - config: Config
  - puyoImage: PuyoImage
  - stage: Stage
  - player: Player
  - score: Score
  - lastTime: number
  - chainElement: HTMLElement

  + initialize(): void
  + loop(currentTime): void
  - update(deltaTime): void
  - draw(): void
  - updateChainDisplay(): void
  - drawGameOver(): void
}

class Config {
  + stageRows: number
  + stageCols: number
  + puyoSize: number
  + dropInterval: number
}

class PuyoImage {
  - config: Config
  - canvas: HTMLCanvasElement
  - ctx: CanvasRenderingContext2D

  + draw(ctx, x, y, color): void
  - drawPuyo(color): void
}

class Stage {
  - config: Config
  - puyoImage: PuyoImage
  - field: number[][]
  - canvas: HTMLCanvasElement
  - ctx: CanvasRenderingContext2D

  + getField(): number[][]
  + getPuyo(x, y): number
  + setPuyo(x, y, color): void
  + draw(): void
  + applyGravity(): boolean
  + checkErase(): EraseInfo
  + eraseBoards(eraseInfo): void
  + checkZenkeshi(): boolean
  - drawBackground(): void
  - drawGrid(): void
  - drawPuyos(): void
  - searchConnectedPuyo(...): void
}

class Player {
  - config: Config
  - stage: Stage
  - puyoImage: PuyoImage
  - puyoX: number
  - puyoY: number
  - puyoColor: number
  - childColor: number
  - rotation: number
  - landed: boolean
  - inputKeyLeft: boolean
  - inputKeyRight: boolean
  - inputKeyDown: boolean
  - dropTimer: number

  + createNewPuyo(): void
  + update(deltaTime): void
  + draw(ctx): void
  + isLanded(): boolean
  + checkGameOver(): boolean
  + moveLeft(): void
  + moveRight(): void
  + moveDown(): boolean
  + rotateRight(): void
  + rotateLeft(): void
  + getDropSpeed(): number
  - applyGravity(): void
  - onLanded(): void
  - fixPuyoToStage(): void
  - canMoveLeft(): boolean
  - canMoveRight(): boolean
  - canMoveDown(): boolean
  - canRotate(...): boolean
}

class Score {
  - score: number
  - element: HTMLElement

  + addScore(puyoCount, chainCount): void
  + addZenkeshiBonus(): void
  + getScore(): number
  + reset(): void
  - updateDisplay(): void
}

enum GameMode {
  start
  checkFall
  fall
  checkErase
  erasing
  newPuyo
  playing
  gameOver
}

interface EraseInfo {
  + erasePuyoCount: number
  + eraseInfo: Array<{x, y, type}>
}

Game "1" *-- "1" Config : 設定管理
Game "1" *-- "1" PuyoImage : ぷよ画像
Game "1" *-- "1" Stage : ステージ
Game "1" *-- "1" Player : プレイヤー
Game "1" *-- "1" Score : スコア
Game ..> GameMode : 使用

Player "1" --> "1" Config : 参照
Player "1" --> "1" Stage : 参照
Player "1" --> "1" PuyoImage : 参照

Stage "1" --> "1" Config : 参照
Stage "1" --> "1" PuyoImage : 参照
Stage ..> EraseInfo : 生成

PuyoImage "1" --> "1" Config : 参照

note right of Game
  ゲーム全体を統括
  状態遷移を管理
  各コンポーネントを協調
end note

note right of Stage
  盤面管理
  落下・消去判定
  全消し判定
end note

note right of Player
  操作可能なぷよ管理
  キー入力処理
  着地・ゲームオーバー判定
end note

note right of Score
  スコア計算
  連鎖ボーナス
  全消しボーナス
end note

@enduml
```

### シーケンス図（通常プレイ）

通常のプレイフローを示します。

```plantuml
@startuml
title 通常プレイのシーケンス図

actor Player as player
participant Game
participant Player as playerObj
participant Stage
participant Score

== ゲーム開始 ==
player -> Game: ゲーム開始
activate Game
Game -> Game: initialize()
Game -> playerObj: createNewPuyo()
activate playerObj
playerObj -> playerObj: 新しいぷよ生成
playerObj --> Game:
deactivate playerObj
Game -> Game: mode = 'playing'

== プレイ中 ==
loop ゲームループ
  Game -> Game: loop()

  alt mode == 'playing'
    Game -> playerObj: update(deltaTime)
    activate playerObj
    playerObj -> playerObj: applyGravity()

    alt ぷよ着地
      playerObj -> playerObj: onLanded()
      playerObj -> Stage: setPuyo(x, y, color)
      activate Stage
      Stage --> playerObj:
      deactivate Stage
      playerObj -> playerObj: landed = true
    end

    playerObj --> Game:
    deactivate playerObj

    alt ぷよ着地した
      Game -> Game: mode = 'checkFall'
    end
  end

  alt mode == 'checkFall'
    loop 落下中
      Game -> Stage: applyGravity()
      activate Stage
      Stage -> Stage: 全ぷよを1マス落下
      Stage --> Game: hasFallen
      deactivate Stage
    end
    Game -> Game: mode = 'checkErase'
  end

  alt mode == 'checkErase'
    Game -> Stage: checkErase()
    activate Stage
    Stage -> Stage: 4個以上の同色判定
    Stage --> Game: eraseInfo
    deactivate Stage

    alt 消去あり
      Game -> Game: combinationCount++
      Game -> Score: addScore(count, chain)
      activate Score
      Score -> Score: スコア計算\n(連鎖ボーナス含む)
      Score --> Game:
      deactivate Score

      Game -> Stage: eraseBoards(eraseInfo)
      activate Stage
      Stage -> Stage: ぷよを消去
      Stage --> Game:
      deactivate Stage

      Game -> Game: mode = 'erasing'
    else 消去なし
      Game -> Stage: checkZenkeshi()
      activate Stage
      Stage -> Stage: 全マス空チェック
      Stage --> Game: isZenkeshi
      deactivate Stage

      alt 全消し
        Game -> Score: addZenkeshiBonus()
        activate Score
        Score -> Score: 3600点加算
        Score --> Game:
        deactivate Score
      end

      Game -> Game: combinationCount = 0
      Game -> Game: mode = 'newPuyo'
    end
  end

  alt mode == 'erasing'
    Game -> Game: mode = 'checkFall'
    note right: 連鎖判定のため\n再度落下チェック
  end

  alt mode == 'newPuyo'
    Game -> playerObj: createNewPuyo()
    activate playerObj
    playerObj --> Game:
    deactivate playerObj

    Game -> playerObj: checkGameOver()
    activate playerObj
    playerObj -> Stage: getPuyo(x, y)
    activate Stage
    Stage --> playerObj: puyoColor
    deactivate Stage
    playerObj --> Game: isGameOver
    deactivate playerObj

    alt ゲームオーバー
      Game -> Game: mode = 'gameOver'
    else 続行可能
      Game -> Game: mode = 'playing'
    end
  end

  Game -> Game: draw()
end

deactivate Game

@enduml
```

### シーケンス図（連鎖発生時）

連鎖が発生した場合の詳細フローを示します。

```plantuml
@startuml
title 連鎖発生時のシーケンス図

participant Game
participant Stage
participant Score

== 1連鎖目 ==
Game -> Game: mode = 'checkErase'
Game -> Stage: checkErase()
activate Stage
Stage -> Stage: 4個以上の同色を検索
Stage --> Game: eraseInfo(4個)
deactivate Stage

Game -> Game: combinationCount = 1
Game -> Score: addScore(4, 1)
activate Score
Score -> Score: baseScore = 4 × 10 = 40
Score -> Score: chainBonus = 0 (1連鎖)
Score -> Score: totalScore = 40
Score --> Game:
deactivate Score

Game -> Stage: eraseBoards(eraseInfo)
activate Stage
Stage -> Stage: 指定位置を0に
Stage --> Game:
deactivate Stage

Game -> Game: mode = 'erasing'

== 落下処理 ==
Game -> Game: mode = 'checkFall'
loop 落下完了まで
  Game -> Stage: applyGravity()
  activate Stage
  Stage -> Stage: 1マス落下
  Stage --> Game: true/false
  deactivate Stage
end

== 2連鎖目判定 ==
Game -> Game: mode = 'checkErase'
Game -> Stage: checkErase()
activate Stage
Stage -> Stage: 再度4個以上を検索
Stage --> Game: eraseInfo(4個)
deactivate Stage

alt 連鎖発生
  Game -> Game: combinationCount = 2
  Game -> Score: addScore(4, 2)
  activate Score
  Score -> Score: baseScore = 40
  Score -> Score: chainBonus = 2^(2+1) = 8
  Score -> Score: totalScore = 40 × 9 = 360
  Score --> Game:
  deactivate Score

  Game -> Stage: eraseBoards(eraseInfo)
  activate Stage
  Stage --> Game:
  deactivate Stage

  Game -> Game: mode = 'erasing'
  note right: 再度checkFallへ\nさらに連鎖チェック
else 連鎖終了
  Game -> Stage: checkZenkeshi()
  activate Stage
  Stage --> Game: false
  deactivate Stage

  Game -> Game: combinationCount = 0
  Game -> Game: mode = 'newPuyo'
end

@enduml
```

これらの図を参照することで、ゲーム全体のアーキテクチャと動作フローが理解しやすくなります。

## 参考資料

- [テスト駆動開発入門](https://amzn.asia/d/6425grx)
- [実践テスト駆動開発](https://www.amazon.co.jp/dp/4798124583)
- [ぷよぷよプログラミング](https://puyo.sega.jp/program/)
- [TypeScriptハンドブック](https://www.typescriptlang.org/docs/)
- [Vitest公式ドキュメント](https://vitest.dev/)
