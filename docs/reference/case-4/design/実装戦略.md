# å®Ÿè£…æˆ¦ç•¥

## æ¦‚è¦

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€ã·ã‚ˆã·ã‚ˆã‚²ãƒ¼ãƒ é–‹ç™ºã«ãŠã‘ã‚‹å…·ä½“çš„ãªå®Ÿè£…æˆ¦ç•¥ã‚’å®šç¾©ã—ã¾ã™ã€‚CLAUDE.local.mdã§æŒ‡å®šã•ã‚ŒãŸTDDé–‹ç™ºãƒ•ãƒ­ãƒ¼ã¨ã€è¨­è¨ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«åŸºã¥ã„ãŸæ®µéšçš„å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æ¡ç”¨ã—ã¾ã™ã€‚

## å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

### 1. é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®æ¡ç”¨

æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ä»¥ä¸‹ã®é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åŸå‰‡ã‚’æ¡ç”¨ã—ã€ã‚ˆã‚Šå …ç‰¢ã§ä¿å®ˆæ€§ã®é«˜ã„ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

```plantuml
@startuml "é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æ ¸å¿ƒåŸå‰‡"
!define PURE_COLOR #E8F5E8
!define IMMUTABLE_COLOR #E6F3FF
!define HIGHER_COLOR #FFE6CC
!define COMPOSE_COLOR #F0E6FF

package "é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°åŸå‰‡" {
  class "ç´”ç²‹é–¢æ•° (Pure Functions)" PURE_COLOR {
    + åŒã˜å…¥åŠ›â†’åŒã˜å‡ºåŠ›
    + å‰¯ä½œç”¨ãªã—
    + ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§
    + ä¸¦è¡Œå‡¦ç†å®‰å…¨
  }
  
  class "ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£" IMMUTABLE_COLOR {
    + ãƒ‡ãƒ¼ã‚¿ã®ä¸å¤‰æ€§
    + çŠ¶æ…‹å¤‰æ›´ã®è¿½è·¡
    + ãƒã‚°ã®å‰Šæ¸›
    + ä¸¦è¡Œå‡¦ç†ã®å®‰å…¨æ€§
  }
  
  class "é«˜éšé–¢æ•°" HIGHER_COLOR {
    + é–¢æ•°ã‚’å¼•æ•°ã«å–ã‚‹
    + é–¢æ•°ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã™
    + æŠ½è±¡åŒ–ã®å‘ä¸Š
    + å†åˆ©ç”¨æ€§ã®ä¿ƒé€²
  }
  
  class "é–¢æ•°åˆæˆ" COMPOSE_COLOR {
    + è¤‡æ•°é–¢æ•°ã®çµ„ã¿åˆã‚ã›
    + ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†
    + å®£è¨€çš„è¨˜è¿°
    + ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§
  }
}

"ç´”ç²‹é–¢æ•° (Pure Functions)" --> "ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£"
"é«˜éšé–¢æ•°" --> "é–¢æ•°åˆæˆ"
"ç´”ç²‹é–¢æ•° (Pure Functions)" --> "é«˜éšé–¢æ•°"
"ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£" --> "é–¢æ•°åˆæˆ"

@enduml
```

#### 1.1 ç´”ç²‹é–¢æ•°ã®å®Ÿè£…

ã·ã‚ˆã·ã‚ˆã‚²ãƒ¼ãƒ ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã¯ç´”ç²‹é–¢æ•°ã¨ã—ã¦å®Ÿè£…ã—ã€ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ã¨äºˆæ¸¬å¯èƒ½æ€§ã‚’ç¢ºä¿ã—ã¾ã™ã€‚

```typescript
// ç´”ç²‹é–¢æ•°ã®ä¾‹: ã·ã‚ˆã®ç§»å‹•
export const movePuyo = (puyo: Puyo, direction: Direction): Puyo => {
  const newPosition = calculateNewPosition(puyo.position, direction);
  return Puyo.create(puyo.color, newPosition);
};

// ç´”ç²‹é–¢æ•°ã®ä¾‹: é€£é–æ¤œå‡º
export const detectChain = (field: Field): PuyoGroup[] => {
  return field.getAllPuyos()
    .groupBy(puyo => puyo.color)
    .map(group => findConnectedGroup(field, group))
    .filter(group => group.size >= 4);
};

// ç´”ç²‹é–¢æ•°ã®ä¾‹: ã‚¹ã‚³ã‚¢è¨ˆç®—  
export const calculateScore = (chainCount: number, puyoCount: number): number => {
  const baseScore = puyoCount * 10;
  const chainBonus = chainCount > 1 ? Math.pow(2, chainCount - 1) * 50 : 0;
  return baseScore + chainBonus;
};
```

#### 1.2 ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ 

ã™ã¹ã¦ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã«è¨­è¨ˆã—ã€çŠ¶æ…‹å¤‰æ›´æ™‚ã¯æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚

```typescript
// ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªFieldå®Ÿè£…
export class Field {
  private constructor(private readonly grid: ReadonlyArray<ReadonlyArray<Puyo | null>>) {
    Object.freeze(this);
  }
  
  // æ–°ã—ã„Fieldã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™
  placePuyo(puyo: Puyo): Field {
    const newGrid = this.grid.map((row, y) =>
      row.map((cell, x) =>
        x === puyo.position.x && y === puyo.position.y ? puyo : cell
      )
    );
    return new Field(newGrid);
  }
  
  // é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã§ã®ã·ã‚ˆå‰Šé™¤
  removePuyos(positions: Position[]): Field {
    const positionSet = new Set(positions.map(p => `${p.x},${p.y}`));
    const newGrid = this.grid.map((row, y) =>
      row.map((cell, x) =>
        positionSet.has(`${x},${y}`) ? null : cell
      )
    );
    return new Field(newGrid);
  }
}
```

#### 1.3 Lodashã«ã‚ˆã‚‹é–¢æ•°å‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

Lodash/fpã‚’æ´»ç”¨ã—ã¦ã€å®£è¨€çš„ã§èª­ã¿ã‚„ã™ã„ãƒ‡ãƒ¼ã‚¿å¤‰æ›å‡¦ç†ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```typescript
import * as fp from 'lodash/fp';

// é–¢æ•°åˆæˆã«ã‚ˆã‚‹é€£é–å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
const processChain = fp.flow(
  detectErasableGroups,
  groups => groups.filter(group => group.size >= 4),
  erasableGroups => ({
    field: removeGroups(field, erasableGroups),
    score: calculateChainScore(erasableGroups),
    chainCount: erasableGroups.length
  })
);

// ã‚«ãƒªãƒ¼åŒ–ã•ã‚ŒãŸé–¢æ•°ã®æ´»ç”¨
const filterPuyosByColor = fp.curry((color: PuyoColor, puyos: Puyo[]) =>
  puyos.filter(puyo => puyo.color === color)
);

const filterRedPuyos = filterPuyosByColor(PuyoColor.RED);
const filterBluePuyos = filterPuyosByColor(PuyoColor.BLUE);

// é«˜éšé–¢æ•°ã«ã‚ˆã‚‹æŠ½è±¡åŒ–
const createPuyoTransformer = (transform: (puyo: Puyo) => Puyo) =>
  (field: Field): Field =>
    field.mapPuyos(transform);

const movePuyosDown = createPuyoTransformer(puyo => 
  puyo.moveTo(puyo.position.moveDown())
);
```

### 2. ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆ vs ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³

```plantuml
@startuml "å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒé¸æŠãƒ•ãƒ­ãƒ¼"
start
:ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆãƒ¼ãƒªãƒ¼;
if (CRUDå®Ÿè£…æ¸ˆã¿?) then (ã¯ã„)
  :ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«;
  :ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³;
  :ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤;
  :ã‚µãƒ¼ãƒ“ã‚¹å±¤;
  :ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤;
  :ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤;
  :ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹;
else (ã„ã„ãˆ)
  :è²§è¡€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«;
  :ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆ;
  :ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹;
  :ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤;
  :ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤;
  :ã‚µãƒ¼ãƒ“ã‚¹å±¤;
  :ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤;
endif
if (APIå®Ÿè£…æ¸ˆã¿?) then (ã¯ã„)
  :ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆ;
else (ã„ã„ãˆ)
  :ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³;
endif
stop
@enduml
```

### 2. é¸æŠåŸºæº–

**ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆæ¨å¥¨ï¼‰:**

- **å¯¾è±¡:** ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ï¼ˆPuyo, Field, Game, Chainï¼‰

- **ç†ç”±:** 

  - æ–°è¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§CRUDæœªå®Ÿè£…
  - è¤‡é›‘ãªã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸­å¿ƒã§æ§‹ç¯‰
  - ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãªé–‹ç™ºãŒå¯èƒ½

**ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆéƒ¨åˆ†æ¡ç”¨ï¼‰:**

- **å¯¾è±¡:** UI ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã€ã‚¿ãƒƒãƒæ“ä½œï¼‰

- **ç†ç”±:**
  - ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’æ—©æœŸã«ç¢ºèª
  - ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã‚’çŸ­ç¸®

## TDDå®Ÿè£…ã‚µã‚¤ã‚¯ãƒ«

### Red-Green-Refactorã‚µã‚¤ã‚¯ãƒ«

```plantuml
@startuml "TDDå®Ÿè£…ã‚µã‚¤ã‚¯ãƒ«è©³ç´°"
start
:TODOãƒªã‚¹ãƒˆç¢ºèª;

partition "Red Phase" {
  :å¤±æ•—ãƒ†ã‚¹ãƒˆä½œæˆ;
  :æœŸå¾…ã™ã‚‹å‹•ä½œã‚’å®šç¾©;
  :æœ€å°é™ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹;
  :ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ â†’ å¤±æ•—ç¢ºèª;
}

partition "Green Phase" {
  :æœ€å°å®Ÿè£…;
  :ãƒ†ã‚¹ãƒˆãŒé€šã‚‹æœ€å°ã‚³ãƒ¼ãƒ‰;
  :é€Ÿåº¦å„ªå…ˆã€å“è³ªã¯äºŒã®æ¬¡;
  :ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ â†’ æˆåŠŸç¢ºèª;
}

partition "Refactor Phase" {
  :ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°;
  :é‡è¤‡ã‚³ãƒ¼ãƒ‰é™¤å»;
  :è¨­è¨ˆã®æ”¹å–„;
  :ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–;
  :ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ â†’ æˆåŠŸç¶­æŒ;
}

partition "å“è³ªãƒã‚§ãƒƒã‚¯" {
  :ã‚³ãƒ¼ãƒ‰ã®æ•´å½¢ (npm run format);
  :ãƒªãƒ³ãƒˆ (npm run lint);
  :ãƒ“ãƒ«ãƒ‰ (npm run build);
  :ãƒ†ã‚¹ãƒˆ (npm run test);
  if (ã‚¨ãƒ©ãƒ¼ã‚ã‚Š?) then (yes)
    :ä¿®æ­£;
    :ä¿®æ­£; --> :ã‚³ãƒ¼ãƒ‰ã®æ•´å½¢ (npm run format);
  else (no)
    :ã‚³ãƒŸãƒƒãƒˆ;
  endif
}

if (TODOå®Œäº†?) then (no)
  :æ¬¡ã®TODOé¸æŠ;
  :æ¬¡ã®TODOé¸æŠ; --> :å¤±æ•—ãƒ†ã‚¹ãƒˆä½œæˆ;
else (yes)
  stop
endif
@enduml
```

## å®Ÿè£…é †åº

### Phase 3: é–‹ç™ºãƒ•ã‚§ãƒ¼ã‚º

#### Iteration 1: ã‚²ãƒ¼ãƒ åŸºç›¤ï¼ˆMVPï¼‰

```plantuml
@startuml "Iteration 1 å®Ÿè£…é †åº"
!define DOMAIN_COLOR #FFE6CC
!define APP_COLOR #E6F3FF  
!define INFRA_COLOR #E6FFE6

skinparam shadowing false

package "Week 1: ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«å®Ÿè£…" DOMAIN_COLOR {
  [1. Puyo ã‚¯ãƒ©ã‚¹] --> [2. Field ã‚¯ãƒ©ã‚¹] 
  [2. Field ã‚¯ãƒ©ã‚¹] --> [3. Game ã‚¯ãƒ©ã‚¹]
  [3. Game ã‚¯ãƒ©ã‚¹] --> [4. åŸºæœ¬ãƒ­ã‚¸ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ]
}

package "Week 2: åŸºæœ¬UIãƒ»çµ±åˆ" APP_COLOR {
  [5. GameBoard ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ] --> [6. çŠ¶æ…‹ç®¡ç† (Zustand)]
  [6. çŠ¶æ…‹ç®¡ç† (Zustand)] --> [7. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›]
  [7. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›] --> [8. çµ±åˆãƒ†ã‚¹ãƒˆ]
}

[4. åŸºæœ¬ãƒ­ã‚¸ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ] --> [5. GameBoard ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ]

@enduml
```

#### Iteration 2: æ¶ˆå»ãƒ»é€£é–ã‚·ã‚¹ãƒ†ãƒ 

```plantuml
@startuml "Iteration 2 å®Ÿè£…é †åº"
!define WEEK1_COLOR #FFE6CC
!define WEEK2_COLOR #E6F3FF

skinparam shadowing false

package "Week 1: é€£é–æ¤œå‡º" WEEK1_COLOR {
  [1. é€£çµã·ã‚ˆæ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ] --> [2. æ¶ˆå»åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯]
  [2. æ¶ˆå»åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯] --> [3. é‡åŠ›é©ç”¨ã‚·ã‚¹ãƒ†ãƒ ]
  [3. é‡åŠ›é©ç”¨ã‚·ã‚¹ãƒ†ãƒ ] --> [4. ãƒã‚§ãƒ¼ãƒ³ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹]
}

package "Week 2: ã‚¹ã‚³ã‚¢ãƒ»ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼" WEEK2_COLOR {
  [5. ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯] --> [6. é€£é–ãƒœãƒ¼ãƒŠã‚¹]
  [6. é€£é–ãƒœãƒ¼ãƒŠã‚¹] --> [7. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š]
  [7. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š] --> [8. UIçµ±åˆãƒ»çµæœè¡¨ç¤º]
}

[4. ãƒã‚§ãƒ¼ãƒ³ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹] --> [5. ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯]

@enduml
```

## ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤å®Ÿè£…æˆ¦ç•¥

### 1. é–¢æ•°å‹ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«

#### 1.1 ç´”ç²‹é–¢æ•°ã«ã‚ˆã‚‹å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

é–¢æ•°å‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç´”ç²‹é–¢æ•°ã¨ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãƒ‡ãƒ¼ã‚¿ã§å®Ÿè£…ã—ã¾ã™ã€‚

```typescript
// é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã®Puyoå®Ÿè£…
export interface PuyoData {
  readonly color: PuyoColor;
  readonly position: Position;
}

// ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ï¼ˆç´”ç²‹é–¢æ•°ï¼‰
export const createPuyo = (color: PuyoColor, position: Position): PuyoData => {
  validatePuyoColor(color);
  validatePosition(position);
  return Object.freeze({ color, position });
};

// ç´”ç²‹é–¢æ•°ã«ã‚ˆã‚‹æ“ä½œ
export const movePuyo = (puyo: PuyoData, newPosition: Position): PuyoData =>
  createPuyo(puyo.color, newPosition);

export const isPuyoEqual = (puyo1: PuyoData, puyo2: PuyoData): boolean =>
  puyo1.color === puyo2.color && isPositionEqual(puyo1.position, puyo2.position);

export const isPuyoAt = (position: Position) => (puyo: PuyoData): boolean =>
  isPositionEqual(puyo.position, position);

export const isSameColor = (color: PuyoColor) => (puyo: PuyoData): boolean =>
  puyo.color === color;

// TDDãƒ†ã‚¹ãƒˆã®ä¾‹
describe('é–¢æ•°å‹Puyoæ“ä½œ', () => {
  test('createPuyoã¯ä¸å¤‰ãªPuyoãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹', () => {
    // Given
    const color = PuyoColor.RED;
    const position = { x: 1, y: 2 };
    
    // When
    const puyo = createPuyo(color, position);
    
    // Then
    expect(puyo.color).toBe(color);
    expect(puyo.position).toEqual(position);
    expect(Object.isFrozen(puyo)).toBe(true);
  });
  
  test('movePuyoã¯æ–°ã—ã„Puyoã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™', () => {
    // Given
    const puyo = createPuyo(PuyoColor.RED, { x: 1, y: 2 });
    const newPosition = { x: 2, y: 3 };
    
    // When
    const movedPuyo = movePuyo(puyo, newPosition);
    
    // Then
    expect(movedPuyo.position).toEqual(newPosition);
    expect(puyo.position).toEqual({ x: 1, y: 2 }); // å…ƒã®puyoã¯å¤‰æ›´ã•ã‚Œãªã„
    expect(movedPuyo).not.toBe(puyo); // æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
  });
});
```

#### 1.2 Lodash/fpã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿å¤‰æ›

```typescript
import * as fp from 'lodash/fp';

// é–¢æ•°åˆæˆã«ã‚ˆã‚‹Puyoæ“ä½œãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
export const processPuyoGroup = fp.flow(
  // ã·ã‚ˆãƒªã‚¹ãƒˆã‚’è‰²ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
  fp.groupBy((puyo: PuyoData) => puyo.color),
  
  // å„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é€£çµã·ã‚ˆæ¤œç´¢
  fp.mapValues(findConnectedPuyos),
  
  // 4å€‹ä»¥ä¸Šã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
  fp.pickBy(group => group.length >= 4),
  
  // ãƒ•ãƒ©ãƒƒãƒˆãªé…åˆ—ã«å¤‰æ›
  fp.flatten
);

// ã‚«ãƒªãƒ¼åŒ–ã•ã‚ŒãŸæ¤œç´¢é–¢æ•°
export const findPuyosBy = fp.curry(
  (predicate: (puyo: PuyoData) => boolean, puyos: PuyoData[]) =>
    puyos.filter(predicate)
);

export const findPuyosByColor = findPuyosBy(isSameColor);
export const findPuyosAt = findPuyosBy(isPuyoAt);

// ä½¿ç”¨ä¾‹
const redPuyos = findPuyosByColor(PuyoColor.RED)(allPuyos);
const puyosAtPosition = findPuyosAt({ x: 0, y: 0 })(allPuyos);
```

### 2. ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆEntitiesï¼‰

#### Fieldå®Ÿè£…ä¾‹

```typescript
// Red: å¤±æ•—ãƒ†ã‚¹ãƒˆ
describe('Field', () => {
  test('ç©ºã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½œæˆã§ãã‚‹', () => {
    // Given & When
    const field = Field.createEmpty();
    
    // Then
    expect(field.isEmpty()).toBe(true);
    expect(field.getWidth()).toBe(6);
    expect(field.getHeight()).toBe(12);
  });
  
  test('æŒ‡å®šä½ç½®ã«Puyoã‚’é…ç½®ã§ãã‚‹', () => {
    // Given
    const field = Field.createEmpty();
    const puyo = Puyo.create(PuyoColor.RED, new Position(0, 0));
    
    // When
    const newField = field.placePuyo(puyo);
    
    // Then
    expect(newField.getPuyoAt(new Position(0, 0))).toEqual(puyo);
  });
});

// Green: æœ€å°å®Ÿè£…
export class Field {
  private constructor(
    private readonly grid: (Puyo | null)[][],
    private readonly width: number = 6,
    private readonly height: number = 12
  ) {}
  
  static createEmpty(): Field {
    const grid = Array(12).fill(null)
      .map(() => Array(6).fill(null));
    return new Field(grid);
  }
  
  isEmpty(): boolean {
    return this.grid.every(row => 
      row.every(cell => cell === null)
    );
  }
  
  placePuyo(puyo: Puyo): Field {
    const newGrid = this.copyGrid();
    const pos = puyo.getPosition();
    newGrid[pos.getY()][pos.getX()] = puyo;
    return new Field(newGrid);
  }
  
  getPuyoAt(position: Position): Puyo | null {
    return this.grid[position.getY()][position.getX()];
  }
}
```

### 3. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆDomain Servicesï¼‰

#### ChainDetectionServiceå®Ÿè£…ä¾‹

```typescript
// Red: å¤±æ•—ãƒ†ã‚¹ãƒˆ
describe('ChainDetectionService', () => {
  test('4ã¤ä»¥ä¸Šã®åŒè‰²ã·ã‚ˆãŒéš£æ¥ã—ã¦ã„ã‚‹å ´åˆã€æ¶ˆå»å¯¾è±¡ã¨ã—ã¦æ¤œå‡ºã•ã‚Œã‚‹', () => {
    // Given
    const field = createFieldWithPattern([
      ['R', 'R', '.', '.', '.', '.'],
      ['R', 'R', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.'],
    ]);
    const service = new ChainDetectionService();
    
    // When
    const result = service.detectErasableGroups(field);
    
    // Then
    expect(result).toHaveLength(1);
    expect(result[0].size).toBe(4);
    expect(result[0].color).toBe(PuyoColor.RED);
  });
});

// Green: æœ€å°å®Ÿè£…
export class ChainDetectionService {
  detectErasableGroups(field: Field): PuyoGroup[] {
    const visited = new Set<string>();
    const erasableGroups: PuyoGroup[] = [];
    
    for (let y = 0; y < field.getHeight(); y++) {
      for (let x = 0; x < field.getWidth(); x++) {
        const position = new Position(x, y);
        const puyo = field.getPuyoAt(position);
        
        if (puyo && !visited.has(position.toString())) {
          const group = this.findConnectedGroup(
            field, position, puyo.getColor(), visited
          );
          
          if (group.size >= 4) {
            erasableGroups.push(group);
          }
        }
      }
    }
    
    return erasableGroups;
  }
  
  private findConnectedGroup(
    field: Field, 
    startPos: Position, 
    color: PuyoColor, 
    visited: Set<string>
  ): PuyoGroup {
    // æ·±åº¦å„ªå…ˆæ¢ç´¢ã«ã‚ˆã‚‹é€£çµã·ã‚ˆæ¤œç´¢
    const group = new PuyoGroup(color);
    const stack = [startPos];
    
    while (stack.length > 0) {
      const currentPos = stack.pop()!;
      
      if (visited.has(currentPos.toString())) continue;
      
      const puyo = field.getPuyoAt(currentPos);
      if (!puyo || puyo.getColor() !== color) continue;
      
      visited.add(currentPos.toString());
      group.addPuyo(puyo);
      
      // éš£æ¥ä½ç½®ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ 
      const neighbors = currentPos.getNeighbors();
      stack.push(...neighbors.filter(pos => 
        field.isValidPosition(pos) && 
        !visited.has(pos.toString())
      ));
    }
    
    return group;
  }
}
```

## ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤å®Ÿè£…æˆ¦ç•¥

### 1. ã‚²ãƒ¼ãƒ ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆGame Serviceï¼‰

```typescript
// Red: å¤±æ•—ãƒ†ã‚¹ãƒˆ
describe('GameService', () => {
  test('ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«åˆæœŸçŠ¶æ…‹ãŒæ­£ã—ãè¨­å®šã•ã‚Œã‚‹', () => {
    // Given
    const gameRepository = createMockGameRepository();
    const service = new GameService(gameRepository);
    
    // When
    const gameId = service.startNewGame();
    
    // Then
    const game = service.getGame(gameId);
    expect(game.getState()).toBe(GameState.READY);
    expect(game.getScore().getCurrent()).toBe(0);
    expect(game.getField().isEmpty()).toBe(true);
  });
  
  test('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¥åŠ›ã‚’å‡¦ç†ã—ã¦ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°ã§ãã‚‹', () => {
    // Given
    const service = new GameService(createMockGameRepository());
    const gameId = service.startNewGame();
    const command = new MovePuyoCommand(Direction.LEFT);
    
    // When
    const result = service.handlePlayerInput(gameId, command);
    
    // Then
    expect(result.isSuccess()).toBe(true);
    expect(result.getEvents()).toContainEqual(
      expect.objectContaining({ type: 'PuyoMovedEvent' })
    );
  });
});

// Green: æœ€å°å®Ÿè£…
export class GameService {
  constructor(
    private gameRepository: GameRepository,
    private chainDetectionService: ChainDetectionService = new ChainDetectionService()
  ) {}
  
  startNewGame(): GameId {
    const gameId = GameId.generate();
    const game = Game.startNew(gameId);
    
    this.gameRepository.save(game);
    return gameId;
  }
  
  handlePlayerInput(gameId: GameId, command: InputCommand): GameResult {
    const game = this.gameRepository.findById(gameId);
    if (!game) {
      return GameResult.failure('Game not found');
    }
    
    const events = game.handleInput(command);
    this.gameRepository.save(game);
    
    return GameResult.success(events);
  }
  
  getGame(gameId: GameId): Game {
    return this.gameRepository.findById(gameId);
  }
}
```

## ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤å®Ÿè£…æˆ¦ç•¥

### 1. Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

```typescript
// React Testing Library ã‚’ä½¿ç”¨ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ†ã‚¹ãƒˆ
describe('GameBoardComponent', () => {
  test('ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’æ­£ã—ãè¡¨ç¤ºã™ã‚‹', () => {
    // Given
    const field = createFieldWithPattern([
      ['R', 'G', '.', '.', '.', '.'],
      ['B', 'Y', '.', '.', '.', '.'],
    ]);
    
    // When
    render(<GameBoard field={field} />);
    
    // Then
    expect(screen.getByTestId('puyo-0-0')).toHaveClass('puyo-red');
    expect(screen.getByTestId('puyo-1-0')).toHaveClass('puyo-green');
    expect(screen.getByTestId('puyo-0-1')).toHaveClass('puyo-blue');
    expect(screen.getByTestId('puyo-1-1')).toHaveClass('puyo-yellow');
  });
  
  test('ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã‚’é©åˆ‡ã«å‡¦ç†ã™ã‚‹', () => {
    // Given
    const mockHandleInput = jest.fn();
    render(<GameBoard onInput={mockHandleInput} />);
    
    // When
    fireEvent.keyDown(document, { key: 'ArrowLeft' });
    
    // Then
    expect(mockHandleInput).toHaveBeenCalledWith(
      expect.objectContaining({ type: 'MOVE_LEFT' })
    );
  });
});

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå®Ÿè£…
interface GameBoardProps {
  field: Field;
  currentPuyo?: PuyoPair;
  onInput?: (command: InputCommand) => void;
}

export const GameBoard: React.FC<GameBoardProps> = ({ 
  field, 
  currentPuyo, 
  onInput 
}) => {
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const command = mapKeyToCommand(event.key);
      if (command && onInput) {
        onInput(command);
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [onInput]);
  
  return (
    <div className="game-board" data-testid="game-board">
      {Array.from({ length: field.getHeight() }, (_, y) => 
        Array.from({ length: field.getWidth() }, (_, x) => {
          const position = new Position(x, y);
          const puyo = field.getPuyoAt(position);
          
          return (
            <div 
              key={`${x}-${y}`}
              data-testid={`puyo-${x}-${y}`}
              className={`cell ${puyo ? `puyo-${puyo.getColor().toLowerCase()}` : 'empty'}`}
            />
          );
        })
      )}
    </div>
  );
};
```

### 2. é–¢æ•°å‹çŠ¶æ…‹ç®¡ç†ï¼ˆZustandï¼‰

é–¢æ•°å‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€çŠ¶æ…‹æ›´æ–°ã‚’ç´”ç²‹é–¢æ•°ã§è¡Œã„ã€Immerç­‰ã‚’ä½¿ç”¨ã—ã¦ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªæ›´æ–°ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

```typescript
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import * as fp from 'lodash/fp';

// é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹
interface GameState {
  readonly currentGame: GameData | null;
  readonly gameStatus: GameStatus;
  readonly history: GameData[];
}

// ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
interface GameActions {
  startNewGame: () => void;
  handleInput: (command: InputCommand) => void;
  resetGame: () => void;
  undoMove: () => void;
}

// ç´”ç²‹é–¢æ•°ã«ã‚ˆã‚‹çŠ¶æ…‹æ›´æ–°é–¢æ•°
const gameStateReducers = {
  startNewGame: (state: GameState): GameState => ({
    ...state,
    currentGame: createInitialGame(),
    gameStatus: GameStatus.PLAYING,
    history: []
  }),
  
  updateGame: (state: GameState, newGame: GameData): GameState => ({
    ...state,
    currentGame: newGame,
    history: [...state.history, state.currentGame].filter(Boolean).slice(-10) // æœ€æ–°10æ‰‹ã‚’ä¿æŒ
  }),
  
  resetGame: (state: GameState): GameState => ({
    currentGame: null,
    gameStatus: GameStatus.NOT_STARTED,
    history: []
  }),
  
  undoMove: (state: GameState): GameState => {
    const previousGame = state.history[state.history.length - 1];
    if (!previousGame) return state;
    
    return {
      ...state,
      currentGame: previousGame,
      history: state.history.slice(0, -1)
    };
  }
};

// Zustandã‚¹ãƒˆã‚¢ã®ä½œæˆ
export const useGameStore = create<GameState & GameActions>()(
  immer((set, get) => ({
    // åˆæœŸçŠ¶æ…‹
    currentGame: null,
    gameStatus: GameStatus.NOT_STARTED,
    history: [],
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆç´”ç²‹é–¢æ•°ã‚’ä½¿ç”¨ï¼‰
    startNewGame: () => set(gameStateReducers.startNewGame),
    
    handleInput: (command: InputCommand) => {
      const { currentGame } = get();
      if (!currentGame) return;
      
      // ç´”ç²‹é–¢æ•°ã«ã‚ˆã‚‹ã‚²ãƒ¼ãƒ çŠ¶æ…‹æ›´æ–°
      const newGame = processGameCommand(currentGame, command);
      set(state => gameStateReducers.updateGame(state, newGame));
    },
    
    resetGame: () => set(gameStateReducers.resetGame),
    undoMove: () => set(gameStateReducers.undoMove)
  }))
);

// ç´”ç²‹é–¢æ•°ã«ã‚ˆã‚‹ã‚²ãƒ¼ãƒ å‡¦ç†
const processGameCommand = (game: GameData, command: InputCommand): GameData => {
  return fp.flow(
    validateCommand(command),
    applyCommand(command),
    checkForChains,
    updateScore,
    checkGameOver
  )(game);
};

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã®ä½¿ç”¨ï¼ˆé–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ï¼‰
export const GameContainer: React.FC = () => {
  const gameState = useGameStore();
  
  return (
    <GameView 
      gameState={gameState}
      onInput={gameState.handleInput}
      onStart={gameState.startNewGame}
      onReset={gameState.resetGame}
      onUndo={gameState.undoMove}
    />
  );
};

// ç´”ç²‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const GameView: React.FC<GameViewProps> = ({ 
  gameState, 
  onInput, 
  onStart, 
  onReset, 
  onUndo 
}) => {
  if (gameState.gameStatus === GameStatus.NOT_STARTED) {
    return <StartScreen onStart={onStart} />;
  }
  
  return (
    <div>
      <GameBoard 
        field={gameState.currentGame?.field}
        currentPuyo={gameState.currentGame?.currentPuyo}
        onInput={onInput}
      />
      <GameControls 
        onReset={onReset}
        onUndo={onUndo}
        canUndo={gameState.history.length > 0}
      />
      <ScoreDisplay score={gameState.currentGame?.score} />
    </div>
  );
};
```

## é–¢æ•°å‹ãƒ†ã‚¹ãƒˆæˆ¦ç•¥å®Ÿè£…

### 1. ç´”ç²‹é–¢æ•°ã®ãƒ†ã‚¹ãƒˆ

é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã¯ã€ç´”ç²‹é–¢æ•°ãŒä¸­å¿ƒã¨ãªã‚‹ãŸã‚ã€ãƒ†ã‚¹ãƒˆãŒéå¸¸ã«ç°¡æ½”ã«ãªã‚Šã¾ã™ã€‚

```typescript
// ç´”ç²‹é–¢æ•°ã®ãƒ†ã‚¹ãƒˆä¾‹
describe('ç´”ç²‹é–¢æ•°ã®ãƒ†ã‚¹ãƒˆ', () => {
  test('movePuyo: ç´”ç²‹é–¢æ•°ã¯åŒã˜å…¥åŠ›ã«å¯¾ã—ã¦å¸¸ã«åŒã˜å‡ºåŠ›ã‚’è¿”ã™', () => {
    // Given
    const puyo = createPuyo(PuyoColor.RED, { x: 1, y: 2 });
    const direction = Direction.LEFT;
    
    // When
    const result1 = movePuyo(puyo, direction);
    const result2 = movePuyo(puyo, direction);
    
    // Then
    expect(result1).toEqual(result2);
    expect(result1.position).toEqual({ x: 0, y: 2 });
  });
  
  test('calculateScore: å‰¯ä½œç”¨ãŒãªã„ãŸã‚ç°¡å˜ã«ãƒ†ã‚¹ãƒˆã§ãã‚‹', () => {
    // Given & When & Then
    expect(calculateScore(1, 4)).toBe(40);  // åŸºæœ¬ã‚¹ã‚³ã‚¢
    expect(calculateScore(2, 4)).toBe(90);  // 2é€£é–ãƒœãƒ¼ãƒŠã‚¹
    expect(calculateScore(3, 4)).toBe(240); // 3é€£é–ãƒœãƒ¼ãƒŠã‚¹
  });
});
```

### 2. Property-Based Testing

é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ç›¸æ€§ã®è‰¯ã„Property-Based Testingã‚’æ´»ç”¨ã—ã¾ã™ã€‚

```typescript
import fc from 'fast-check';

describe('Property-Based Testing', () => {
  test('movePuyo: ç§»å‹•å¾Œã®ã·ã‚ˆã¯å…ƒã®è‰²ã‚’ä¿æŒã™ã‚‹', () => {
    fc.assert(fc.property(
      fc.constantFrom(...Object.values(PuyoColor)), // è‰²ã®ç”Ÿæˆ
      fc.record({ x: fc.integer(0, 5), y: fc.integer(0, 11) }), // ä½ç½®ã®ç”Ÿæˆ
      fc.constantFrom(...Object.values(Direction)), // æ–¹å‘ã®ç”Ÿæˆ
      (color, position, direction) => {
        // Given
        const puyo = createPuyo(color, position);
        
        // When
        const movedPuyo = movePuyo(puyo, direction);
        
        // Then
        expect(movedPuyo.color).toBe(color); // è‰²ã¯å¤‰ã‚ã‚‰ãªã„
        expect(movedPuyo).not.toBe(puyo);    // æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
      }
    ));
  });
  
  test('å‡¦ç†ãƒã‚§ãƒ¼ãƒ³ã®çµåˆæ³•å‰‡', () => {
    fc.assert(fc.property(
      fc.array(fc.record({ 
        color: fc.constantFrom(...Object.values(PuyoColor)),
        position: fc.record({ x: fc.integer(0, 5), y: fc.integer(0, 11) })
      })),
      (puyoDataList) => {
        const puyos = puyoDataList.map(data => createPuyo(data.color, data.position));
        
        // å‡¦ç†ãƒã‚§ãƒ¼ãƒ³ãŒçµåˆæ³•å‰‡ã‚’æº€ãŸã™ã“ã¨ã‚’ç¢ºèª
        const process1 = fp.flow(filterRedPuyos, movePuyosDown);
        const process2 = fp.flow(movePuyosDown, filterRedPuyos);
        
        // ç‰¹å®šã®æ¡ä»¶ä¸‹ã§çµæœãŒåŒã˜ã«ãªã‚‹ã“ã¨ã‚’ç¢ºèª
        // (ã“ã®ä¾‹ã§ã¯ã€èµ¤ã·ã‚ˆä»¥å¤–ã¯ç§»å‹•ã«å½±éŸ¿ã—ãªã„å‰æ)
        if (puyos.every(puyo => puyo.color === PuyoColor.RED)) {
          expect(process1(puyos)).toEqual(process2(puyos));
        }
      }
    ));
  });
});
```

### 3. é–¢æ•°å‹ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ“ãƒ«ãƒ€ãƒ¼

```typescript
export class GameTestDataBuilder {
  private game: Game;
  
  constructor() {
    this.game = Game.startNew(GameId.generate());
  }
  
  withField(pattern: string[][]): GameTestDataBuilder {
    const field = FieldFactory.createFromPattern(pattern);
    this.game = this.game.withField(field);
    return this;
  }
  
  withScore(score: number): GameTestDataBuilder {
    this.game = this.game.withScore(new Score(score, 0));
    return this;
  }
  
  withState(state: GameState): GameTestDataBuilder {
    this.game = this.game.withState(state);
    return this;
  }
  
  build(): Game {
    return this.game;
  }
}

// ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ˜ãƒ«ãƒ‘ãƒ¼
export class FieldFactory {
  static createFromPattern(pattern: string[][]): Field {
    const field = Field.createEmpty();
    
    return pattern.reduce((acc, row, y) => {
      return row.reduce((fieldAcc, cell, x) => {
        if (cell !== '.') {
          const color = this.mapCharToColor(cell);
          const puyo = Puyo.create(color, new Position(x, y));
          return fieldAcc.placePuyo(puyo);
        }
        return fieldAcc;
      }, acc);
    }, field);
  }
  
  private static mapCharToColor(char: string): PuyoColor {
    const colorMap = {
      'R': PuyoColor.RED,
      'G': PuyoColor.GREEN,
      'B': PuyoColor.BLUE,
      'Y': PuyoColor.YELLOW,
      'P': PuyoColor.PURPLE
    };
    
    return colorMap[char] || PuyoColor.RED;
  }
}
```

### 2. çµ±åˆãƒ†ã‚¹ãƒˆ

```typescript
describe('ã‚²ãƒ¼ãƒ çµ±åˆãƒ†ã‚¹ãƒˆ', () => {
  test('å®Œå…¨ãªã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ãŒæ­£ã—ãå‹•ä½œã™ã‚‹', async () => {
    // Given: ã‚²ãƒ¼ãƒ é–‹å§‹
    const gameService = new GameService(new InMemoryGameRepository());
    const gameId = gameService.startNewGame();
    
    // When: ä¸€é€£ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œã‚’å®Ÿè¡Œ
    await gameService.handlePlayerInput(gameId, new MovePuyoCommand(Direction.LEFT));
    await gameService.handlePlayerInput(gameId, new RotatePuyoCommand());
    await gameService.handlePlayerInput(gameId, new QuickDropCommand());
    
    // Then: ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãŒæœŸå¾…é€šã‚Šã«æ›´æ–°ã•ã‚Œã‚‹
    const game = gameService.getGame(gameId);
    expect(game.getState()).toBe(GameState.PLACING_NEXT_PUYO);
    expect(game.getField().isEmpty()).toBe(false);
  });
  
  test('é€£é–ãŒæ­£ã—ãç™ºç”Ÿã—ã¦ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã‚‹', async () => {
    // Given: é€£é–ãŒç™ºç”Ÿã—ã‚„ã™ã„åˆæœŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    const field = FieldFactory.createFromPattern([
      ['.', '.', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.'],
      ['R', 'R', 'R', '.', '.', '.'],
      ['G', 'G', 'B', '.', '.', '.'],
      ['G', 'B', 'B', '.', '.', '.']
    ]);
    
    const game = new GameTestDataBuilder()
      .withField(field)
      .withScore(0)
      .build();
    
    const gameService = new GameService(new InMemoryGameRepository());
    gameService.saveGame(game);
    
    // When: é€£é–ã‚’ç™ºç”Ÿã•ã›ã‚‹æ“ä½œ
    const redPuyo = Puyo.create(PuyoColor.RED, new Position(3, 2));
    const placePuyoCommand = new PlacePuyoCommand(redPuyo);
    const result = await gameService.handlePlayerInput(game.getId(), placePuyoCommand);
    
    // Then: é€£é–ãŒç™ºç”Ÿã—ã¦ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã‚‹
    const updatedGame = gameService.getGame(game.getId());
    expect(updatedGame.getScore().getCurrent()).toBeGreaterThan(0);
    expect(result.getEvents()).toContainEqual(
      expect.objectContaining({ type: 'ChainOccurredEvent' })
    );
  });
});
```

## ã‚³ãƒŸãƒƒãƒˆæˆ¦ç•¥

### TODOãƒ™ãƒ¼ã‚¹ã®ã‚³ãƒŸãƒƒãƒˆ

```plantuml
@startuml "ã‚³ãƒŸãƒƒãƒˆæˆ¦ç•¥"
start
:TODOé¸æŠ;
:Red-Green-Refactor ã‚µã‚¤ã‚¯ãƒ«å®Ÿè¡Œ;
:å“è³ªãƒã‚§ãƒƒã‚¯;
if (å“è³ªOK?) then (yes)
  :TODOå˜ä½ã§ã‚³ãƒŸãƒƒãƒˆ;
  :Angularã‚¹ã‚¿ã‚¤ãƒ«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä½œæˆ;
  note right
    feat: ã·ã‚ˆå›è»¢æ©Ÿèƒ½ã‚’å®Ÿè£…
    
    - Puyo ã‚¯ãƒ©ã‚¹ã«å›è»¢ãƒ­ã‚¸ãƒƒã‚¯è¿½åŠ 
    - è¡çªåˆ¤å®šã‚’è€ƒæ…®ã—ãŸå›è»¢å‡¦ç†
    - å˜ä½“ãƒ†ã‚¹ãƒˆè¿½åŠ ï¼ˆã‚«ãƒãƒ¬ãƒƒã‚¸95%ï¼‰
    
    ğŸ¤– Generated with [Claude Code](https://claude.ai/code)
    Co-Authored-By: Claude <noreply@anthropic.com>
  end note
else (no)
  :ä¿®æ­£;
  :ä¿®æ­£; --> :å“è³ªãƒã‚§ãƒƒã‚¯;
endif
if (æ¬¡ã®TODO?) then (yes)
  :æ¬¡ã®TODO; --> :TODOé¸æŠ;
else (no)
  stop
endif
@enduml
```

### ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¦ç´„

```markdown
<type>(<scope>): <subject>

<body>

<footer>
```

**Type:**
- `feat`: æ–°æ©Ÿèƒ½è¿½åŠ 
- `fix`: ãƒã‚°ä¿®æ­£  
- `refactor`: ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
- `test`: ãƒ†ã‚¹ãƒˆè¿½åŠ ãƒ»ä¿®æ­£
- `docs`: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°
- `style`: ã‚³ãƒ¼ãƒ‰æ•´å½¢
- `chore`: ãƒ“ãƒ«ãƒ‰ãƒ»è¨­å®šå¤‰æ›´

**Scope:**
- `domain`: ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤
- `app`: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
- `ui`: ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤
- `infra`: ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

### 1. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼

```typescript
// ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ã®å®šç¾©
export abstract class DomainError extends Error {
  abstract readonly code: string;
  abstract readonly severity: 'warning' | 'error' | 'critical';
}

export class InvalidPuyoPlacementError extends DomainError {
  readonly code = 'INVALID_PUYO_PLACEMENT';
  readonly severity = 'warning';
  
  constructor(position: Position, reason: string) {
    super(`Cannot place puyo at ${position}: ${reason}`);
  }
}

export class GameOverError extends DomainError {
  readonly code = 'GAME_OVER';
  readonly severity = 'error';
  
  constructor(finalScore: number) {
    super(`Game over with final score: ${finalScore}`);
  }
}

// ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã§ã®ä½¿ç”¨
export class Game {
  handleInput(command: InputCommand): DomainEvent[] {
    try {
      switch (command.type) {
        case 'MOVE_PUYO':
          return this.handleMovePuyo(command as MovePuyoCommand);
        case 'PLACE_PUYO':
          return this.handlePlacePuyo(command as PlacePuyoCommand);
        default:
          throw new InvalidCommandError(command.type);
      }
    } catch (error) {
      if (error instanceof DomainError) {
        return [new GameErrorEvent(this.id, error)];
      }
      throw error; // äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã¯å†ã‚¹ãƒ­ãƒ¼
    }
  }
  
  private handlePlacePuyo(command: PlacePuyoCommand): DomainEvent[] {
    const position = command.puyo.getPosition();
    
    if (!this.field.canPlacePuyoAt(position)) {
      throw new InvalidPuyoPlacementError(
        position, 
        'Position is already occupied'
      );
    }
    
    // æ­£å¸¸å‡¦ç†...
    return [new PuyoPlacedEvent(this.id, command.puyo)];
  }
}
```

### 2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤ã‚¨ãƒ©ãƒ¼å‡¦ç†

```typescript
export class GameService {
  async handlePlayerInput(
    gameId: GameId, 
    command: InputCommand
  ): Promise<GameResult> {
    try {
      const game = await this.gameRepository.findById(gameId);
      if (!game) {
        return GameResult.failure('Game not found', 'GAME_NOT_FOUND');
      }
      
      const events = game.handleInput(command);
      await this.gameRepository.save(game);
      
      // ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã«å¤‰æ›
      await this.eventBus.publishAll(events);
      
      return GameResult.success(events);
      
    } catch (error) {
      if (error instanceof DomainError) {
        return GameResult.failure(error.message, error.code);
      }
      
      // äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã¯ãƒ­ã‚°ã«è¨˜éŒ²ã—ã¦æ±ç”¨ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
      this.logger.error('Unexpected error in GameService', error);
      return GameResult.failure('Internal server error', 'INTERNAL_ERROR');
    }
  }
}

export class GameResult {
  private constructor(
    private readonly success: boolean,
    private readonly events: DomainEvent[] = [],
    private readonly errorMessage?: string,
    private readonly errorCode?: string
  ) {}
  
  static success(events: DomainEvent[]): GameResult {
    return new GameResult(true, events);
  }
  
  static failure(message: string, code: string): GameResult {
    return new GameResult(false, [], message, code);
  }
  
  isSuccess(): boolean { return this.success; }
  getEvents(): DomainEvent[] { return [...this.events]; }
  getErrorMessage(): string | undefined { return this.errorMessage; }
  getErrorCode(): string | undefined { return this.errorCode; }
}
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æˆ¦ç•¥

### 1. ãƒ¡ãƒ¢åŒ–ã¨Reactã®æœ€é©åŒ–

```typescript
// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ€é©åŒ–
export const GameBoard = React.memo<GameBoardProps>(({ 
  field, 
  currentPuyo, 
  onInput 
}) => {
  // é‡ã„è¨ˆç®—ã®ãƒ¡ãƒ¢åŒ–
  const fieldCells = useMemo(() => {
    return field.getCells().map((row, y) => 
      row.map((puyo, x) => ({
        key: `${x}-${y}`,
        puyo,
        position: new Position(x, y)
      }))
    );
  }, [field]);
  
  // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã®ãƒ¡ãƒ¢åŒ–
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    const command = mapKeyToCommand(event.key);
    if (command && onInput) {
      onInput(command);
    }
  }, [onInput]);
  
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
  
  return (
    <div className="game-board">
      {fieldCells.map(row => 
        row.map(({ key, puyo, position }) => (
          <PuyoCell key={key} puyo={puyo} position={position} />
        ))
      )}
    </div>
  );
});

// æ¯”è¼ƒé–¢æ•°ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
GameBoard.displayName = 'GameBoard';
```

### 2. ãƒãƒ³ãƒ‰ãƒ«æœ€é©åŒ–

```typescript
// å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã‚ˆã‚‹é…å»¶ãƒ­ãƒ¼ãƒ‰
const GameSettingsModal = lazy(() => import('./GameSettingsModal'));
const GameHistoryModal = lazy(() => import('./GameHistoryModal'));

export const GameContainer: React.FC = () => {
  const [showSettings, setShowSettings] = useState(false);
  
  return (
    <div>
      <GameBoard />
      
      <Suspense fallback={<div>Loading...</div>}>
        {showSettings && (
          <GameSettingsModal onClose={() => setShowSettings(false)} />
        )}
      </Suspense>
    </div>
  );
};
```

### 3. é–¢æ•°å‹ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ“ãƒ«ãƒ€ãƒ¼

é–¢æ•°å‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚‚ç´”ç²‹é–¢æ•°ã§è¡Œã„ã¾ã™ã€‚

```typescript
// é–¢æ•°å‹ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ“ãƒ«ãƒ€ãƒ¼
export const createTestGame = (overrides: Partial<GameData> = {}): GameData => ({
  field: createEmptyField(),
  currentPuyo: createRandomPuyoPair(),
  nextPuyo: createRandomPuyoPair(),
  score: 0,
  chainCount: 0,
  gameStatus: GameStatus.PLAYING,
  ...overrides
});

// ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç”Ÿæˆ
export const createFieldFromPattern = (pattern: string[][]): FieldData =>
  pattern.map((row, y) =>
    row.map((char, x) => 
      char !== '.' ? createPuyo(charToColor(char), { x, y }) : null
    )
  );

// é–¢æ•°åˆæˆã«ã‚ˆã‚‹ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ªç”Ÿæˆ
export const createChainScenario = fp.flow(
  createFieldFromPattern([
    ['.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.'],
    ['R', 'R', 'R', '.', '.', '.'],
    ['G', 'G', 'B', '.', '.', '.'],
    ['G', 'B', 'B', '.', '.', '.']
  ]),
  field => createTestGame({ field }),
  game => ({ ...game, currentPuyo: createPuyo(PuyoColor.RED, { x: 3, y: 2 }) })
);

// ä½¿ç”¨ä¾‹
describe('é€£é–ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª', () => {
  test('3é€£é–ãŒæ­£ã—ãå‹•ä½œã™ã‚‹', () => {
    // Given
    const gameData = createChainScenario();
    
    // When
    const result = processGameCommand(gameData, { type: 'PLACE_PUYO' });
    
    // Then
    expect(result.chainCount).toBe(3);
    expect(result.score).toBeGreaterThan(200);
  });
});
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼ˆé–¢æ•°å‹ï¼‰

### 1. ãƒ¡ãƒ¢åŒ–ã«ã‚ˆã‚‹è¨ˆç®—æœ€é©åŒ–

```typescript
import memoize from 'lodash/memoize';

// é‡ã„è¨ˆç®—ã®çµæœã‚’ãƒ¡ãƒ¢åŒ–
export const findConnectedPuyos = memoize(
  (field: FieldData, startPosition: Position, color: PuyoColor): PuyoData[] => {
    // è¨ˆç®—é›†ç´„çš„ãªé€£çµæ¢ç´¢
    return searchConnectedPuyos(field, startPosition, color);
  },
  // ã‚­ãƒ¼ã®ç”Ÿæˆé–¢æ•°
  (field, position, color) => `${fieldToString(field)}_${position.x}_${position.y}_${color}`
);

// React.useMemoã¨ã®çµ„ã¿åˆã‚ã›
export const GameBoard: React.FC<GameBoardProps> = ({ field, currentPuyo }) => {
  const renderedCells = useMemo(() =>
    field.map(row => 
      row.map(puyo => puyo ? renderPuyo(puyo) : renderEmptyCell())
    ),
    [field] // fieldãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã®ã¿å†è¨ˆç®—
  );
  
  return <div className="game-board">{renderedCells}</div>;
};
```

### 2. é–¢æ•°åˆæˆã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

```typescript
// åŠ¹ç‡çš„ãªãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
export const optimizedChainProcess = fp.flow(
  // 1ãƒ‘ã‚¹ã§è¤‡æ•°ã®å‡¦ç†ã‚’å®Ÿè¡Œ
  field => field.reduce((acc, row, y) => {
    row.forEach((puyo, x) => {
      if (puyo) {
        acc.puyosByColor[puyo.color] = acc.puyosByColor[puyo.color] || [];
        acc.puyosByColor[puyo.color].push({ puyo, position: { x, y } });
        acc.totalCount++;
      }
    });
    return acc;
  }, { puyosByColor: {}, totalCount: 0 }),
  
  // é€£çµæ¤œç´¢ã‚’è‰²ã”ã¨ã«ä¸¦åˆ—å®Ÿè¡Œ
  ({ puyosByColor, totalCount }) => ({
    erasableGroups: Object.entries(puyosByColor)
      .map(([color, puyos]) => findConnectedGroups(puyos))
      .flat()
      .filter(group => group.length >= 4),
    totalCount
  })
);
```

## ã¾ã¨ã‚

ã“ã®é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°å®Ÿè£…æˆ¦ç•¥ã«ã‚ˆã‚Šä»¥ä¸‹ã‚’å®Ÿç¾ï¼š

1. **é–¢æ•°å‹åŸå‰‡**: ç´”ç²‹é–¢æ•°ãƒ»ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£ãƒ»é«˜éšé–¢æ•°ãƒ»é–¢æ•°åˆæˆã®æ¡ç”¨
2. **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: å‰¯ä½œç”¨ã®ãªã„ç´”ç²‹é–¢æ•°ã«ã‚ˆã‚‹ç°¡æ½”ãªãƒ†ã‚¹ãƒˆ
3. **ä¿å®ˆæ€§**: äºˆæ¸¬å¯èƒ½ã§ç†è§£ã—ã‚„ã™ã„ã‚³ãƒ¼ãƒ‰æ§‹é€ 
4. **ä¸¦è¡Œå‡¦ç†å®‰å…¨æ€§**: å…±æœ‰çŠ¶æ…‹å¤‰æ›´ã®ãªã„å®‰å…¨ãªä¸¦è¡Œå‡¦ç†
5. **å®£è¨€çš„è¨˜è¿°**: Lodash/fpã«ã‚ˆã‚‹èª­ã¿ã‚„ã™ã„ãƒ‡ãƒ¼ã‚¿å¤‰æ›
6. **å‹å®‰å…¨æ€§**: TypeScriptã«ã‚ˆã‚‹å³å¯†ãªå‹ãƒã‚§ãƒƒã‚¯

### é–¢æ•°å‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®åˆ©ç‚¹

- **ãƒã‚°å‰Šæ¸›**: ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£ã«ã‚ˆã‚ŠäºˆæœŸã—ãªã„å‰¯ä½œç”¨ã‚’é˜²æ­¢
- **ãƒ†ã‚¹ãƒˆåŠ¹ç‡**: ç´”ç²‹é–¢æ•°ã¯å…¥åŠ›ãƒ»å‡ºåŠ›ãŒæ˜ç¢ºã§ãƒ†ã‚¹ãƒˆãŒç°¡å˜
- **ä¸¦è¡Œå‡¦ç†**: çŠ¶æ…‹å…±æœ‰ãŒãªã„ãŸã‚ç«¶åˆçŠ¶æ…‹ãŒç™ºç”Ÿã—ãªã„
- **ãƒ‡ãƒãƒƒã‚°å®¹æ˜“æ€§**: ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ãŒæ˜ç¢ºã§è¿½è·¡ã—ã‚„ã™ã„
- **å†åˆ©ç”¨æ€§**: æ±ç”¨çš„ãªç´”ç²‹é–¢æ•°ã¯æ§˜ã€…ãªå ´é¢ã§å†åˆ©ç”¨å¯èƒ½

æ¬¡ã®Phase 3ï¼ˆé–‹ç™ºï¼‰ã§ã¯ã€ã“ã®é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æˆ¦ç•¥ã«åŸºã¥ã„ã¦ã€Lodash/fpã‚’æ´»ç”¨ã—ãŸã·ã‚ˆã·ã‚ˆã‚²ãƒ¼ãƒ ã®å®Ÿè£…ã‚’é€²ã‚ã¦ã„ãã¾ã™ã€‚